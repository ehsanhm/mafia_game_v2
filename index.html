<!doctype html>
<html lang="fa" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="theme-color" content="#0b0f14" />
    <title>Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù† Ø¨Ø§Ø²ÛŒ Ù…Ø§ÙÛŒØ§</title>
    <style>
      :root{
        --bg0:#121a29;
        --bg1:#2a394b;
        --card:#111824;
        --card2:#6489be;
        --text:#eaf0ff;
        --muted:#9fb0cf;
        --line:rgba(255,255,255,.08);
        --shadow: 0 14px 40px rgba(0,0,0,.45);
        --accent:#6ea8ff;
        --accent2:#8b5cff;
        --good:#35d07f;
        --warn:#ffcc66;
        --bad:#ff5c74;
        --radius:18px;
      }

      *{ box-sizing:border-box; }
      html, body{ min-height:100%; }
      html{
        background:
          radial-gradient(1200px 700px at 80% -10%, rgba(139,92,255,.20), transparent 55%),
          radial-gradient(1000px 600px at 10% 0%, rgba(110,168,255,.18), transparent 60%),
          linear-gradient(180deg, var(--bg0), var(--bg1));
        background-repeat: no-repeat;
        background-color: var(--bg1);
      }
      body{
        margin:0;
        font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans Arabic", "Noto Naskh Arabic", sans-serif;
        background: transparent;
        color:var(--text);
        -webkit-tap-highlight-color: transparent;
      }

      .app{
        max-width: 520px;
        margin: 0 auto;
        min-height: 100%;
        display:flex;
        flex-direction:column;
        padding:
          calc(env(safe-area-inset-top) + 16px)
          14px
          calc(env(safe-area-inset-bottom) + 16px);
        gap:12px;
      }

      .topbar{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
      }
      .topActions{
        display:flex;
        align-items:center;
        gap:10px;
      }
      .title{
        font-weight:800;
        letter-spacing:-.2px;
        font-size: 18px;
      }

      .pill{
        width:100%;
        display:flex;
        gap:10px;
        padding: 10px;
        border-radius: 18px;
        border:1px solid var(--line);
        background: rgba(17,24,36,.35);
      }
      .pill button{
        flex:1;
        border:1px solid transparent;
        background: rgba(255,255,255,.04);
        color: var(--muted);
        font-weight:950;
        font-size:12px;
        padding: 10px 10px;
        border-radius: 14px;
        cursor:pointer;
      }
      .pill button.active{
        color: var(--text);
        background: rgba(110,168,255,.12);
        border-color: rgba(110,168,255,.25);
      }
      .chip{
        display:inline-flex;
        align-items:center;
        gap:8px;
        border:1px solid var(--line);
        background:rgba(255,255,255,.04);
        padding:10px 12px;
        border-radius:999px;
        color:var(--muted);
        font-weight:700;
        font-size:13px;
      }
      .chip.clickable{
        cursor:pointer;
        user-select:none;
      }
      .chip.clickable .label{
        pointer-events:none;
      }
      .chip button{
        border:none;
        background:transparent;
        color:var(--text);
        font-weight:800;
        padding:0;
        cursor:pointer;
      }

      .card{
        background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
        border:1px solid var(--line);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow:hidden;
      }
      .card .hd{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        padding: 14px 14px 10px;
        border-bottom:1px solid var(--line);
        background: rgba(0,0,0,.14);
      }
      .card .hd h2{
        margin:0;
        font-size:14px;
        font-weight:900;
        color: var(--text);
      }
      .card .bd{ padding: 12px 14px 14px; }

      .row{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap:10px;
        margin-bottom:10px;
      }
      .row.one{ grid-template-columns: 1fr; }

      label{
        display:flex;
        flex-direction:column;
        gap:6px;
        color: var(--muted);
        font-weight:800;
        font-size:12px;
      }

      select, input[type="number"]{
        width:100%;
        padding: 12px 12px;
        border-radius: 14px;
        border:1px solid var(--line);
        background: rgba(17,24,36,.65);
        color: var(--text);
        outline:none;
        font-weight:800;
        font-size:14px;
      }
      select:focus, input[type="number"]:focus{
        border-color: rgba(110,168,255,.55);
        box-shadow: 0 0 0 3px rgba(110,168,255,.14);
      }

      .toggles{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap:10px;
        margin-top: 4px;
      }
      .teamHdr{
        grid-column: 1 / -1;
        display:flex;
        align-items:center;
        gap:10px;
        margin-top: 6px;
        color: var(--muted);
        font-weight:1000;
        font-size:12px;
        letter-spacing:-.2px;
        user-select:none;
        -webkit-user-select:none;
      }
      .teamHdr:first-child{ margin-top: 0; }
      .teamHdr::after{
        content:"";
        flex:1;
        height:1px;
        background: rgba(255,255,255,.10);
      }
      .teamHdr.team-mafia{ color: rgba(255,92,116,.95); }
      .teamHdr.team-city{ color: rgba(53,208,127,.95); }
      .teamHdr.team-ind{ color: rgba(255,189,46,.95); }
      .teamHdr.team-mafia::after{ background: rgba(255,92,116,.22); }
      .teamHdr.team-city::after{ background: rgba(53,208,127,.22); }
      .teamHdr.team-ind::after{ background: rgba(255,189,46,.22); }
      .toggle{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        padding: 12px 12px;
        border-radius: 16px;
        border:1px solid var(--line);
        background: rgba(17,24,36,.45);
        cursor:pointer;
        user-select:none;
        -webkit-user-select:none;
      }
      .toggle:active{ transform: translateY(1px); }
      .toggle:focus-visible{
        outline: 3px solid rgba(110,168,255,.22);
        outline-offset: 2px;
      }
      .toggle.on{
        border-color: rgba(110,168,255,.55);
        background: rgba(110,168,255,.10);
      }
      .toggle.team-mafia.on{
        border-color: rgba(255,92,116,.55);
        background: rgba(255,92,116,.10);
      }
      .toggle.team-city.on{
        border-color: rgba(53,208,127,.55);
        background: rgba(53,208,127,.10);
      }
      .toggle.team-ind.on{
        border-color: rgba(255,189,46,.55);
        background: rgba(255,189,46,.10);
      }
      .toggle.disabled{
        opacity:.55;
        cursor:not-allowed;
      }
      .toggle .meta{
        display:flex;
        flex-direction:column;
        gap:3px;
        min-width:0;
      }
      .toggle .name{
        font-weight:950;
        font-size:13px;
        color: var(--text);
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }
      .toggle .hint{
        font-size:11px;
        font-weight:800;
        color: var(--muted);
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }
      .toggle .right{
        display:flex;
        align-items:center;
        gap:8px;
        flex: 0 0 auto;
      }
      .toggle .countpill{
        padding: 7px 10px;
        border-radius: 999px;
        border:1px solid var(--line);
        background: rgba(255,255,255,.04);
        color: var(--muted);
        font-weight:950;
        font-size:12px;
        flex: 0 0 auto;
      }
      .toggle.base{
        background: rgba(17,24,36,.30);
        cursor: default;
      }
      .toggle.base:active{ transform: none; }
      .toggle.base.on{
        border-color: rgba(110,168,255,.55);
        background: rgba(110,168,255,.10);
      }
      .toggle.base.team-mafia.on{
        border-color: rgba(255,92,116,.55);
        background: rgba(255,92,116,.10);
      }
      .toggle.base.team-city.on{
        border-color: rgba(53,208,127,.55);
        background: rgba(53,208,127,.10);
      }

      .cardsGrid{
        margin-top: 12px;
        display:grid;
        grid-template-columns: repeat(3, 1fr);
        gap:10px;
      }
      .cardBtn{
        width:100%;
        /* Make deal cards square */
        aspect-ratio: 1 / 1;
        border-radius: 18px;
        border:1px solid rgba(255,255,255,.26);
        background:
          radial-gradient(260px 210px at 30% 20%, rgba(110,168,255,.42), transparent 62%),
          radial-gradient(260px 210px at 80% 80%, rgba(139,92,255,.34), transparent 62%),
          rgba(28,40,60,.92);
        color: var(--text);
        font-weight:1000;
        cursor:pointer;
        display:flex;
        align-items:center;
        justify-content:center;
        text-align:center;
        padding: 10px;
        box-shadow:
          0 12px 34px rgba(0,0,0,.38),
          0 0 0 1px rgba(255,255,255,.06),
          inset 0 1px 0 rgba(255,255,255,.10),
          0 0 0 4px rgba(110,168,255,.08);
      }
      .cardBtn:hover{
        transform: translateY(-1px);
        border-color: rgba(255,255,255,.34);
        box-shadow:
          0 14px 40px rgba(0,0,0,.42),
          0 0 0 1px rgba(255,255,255,.08),
          inset 0 1px 0 rgba(255,255,255,.12),
          0 0 0 6px rgba(110,168,255,.10);
      }
      .cardBtn:focus-visible{
        outline: none;
        box-shadow:
          0 14px 40px rgba(0,0,0,.42),
          inset 0 1px 0 rgba(255,255,255,.12),
          0 0 0 3px rgba(110,168,255,.30);
        border-color: rgba(110,168,255,.55);
      }
      .cardBtn.used{
        opacity:.55;
        cursor:not-allowed;
        border-color: rgba(255,255,255,.10);
        background: rgba(17,24,36,.26);
        box-shadow: none;
      }
      .cardBtn:active{ transform: translateY(1px); }
      @media (max-width: 380px){
        .cardsGrid{ grid-template-columns: repeat(2, 1fr); }
      }

      /* Vertically center the cards area on tall screens */
      #cardsCard{
        flex: 1;
        display:flex;
        flex-direction:column;
        min-height: 0;
      }
      #cardsCard .bd{
        display:flex;
        flex-direction:column;
        gap:12px;
        flex: 1;
        min-height: 0;
      }
      #cardsCard .cardsCenter{
        flex: 1;
        display:flex;
        flex-direction:column;
        justify-content:center;
        gap:12px;
      }
      #cardsCard .actions{
        margin-top: 6px;
      }

      .actions{
        display:flex;
        gap:10px;
        margin-top: 12px;
      }
      .actions.wrap{
        flex-wrap: wrap;
      }
      .btn{
        border:none;
        cursor:pointer;
        font-weight:950;
        font-size:14px;
        padding: 13px 14px;
        border-radius: 16px;
        color: var(--text);
        background: rgba(255,255,255,.06);
        border:1px solid var(--line);
        flex: 1;
      }
      .btn.primary{
        background: linear-gradient(135deg, rgba(110,168,255,.95), rgba(139,92,255,.92));
        border: 0;
        box-shadow: 0 10px 28px rgba(110,168,255,.14);
      }
      .btn.danger{
        background: rgba(255,92,116,.10);
        border-color: rgba(255,92,116,.35);
        color: #ffd7dd;
      }
      /* (Reset button removed from main UI) */
      .btn:active{ transform: translateY(1px); }

      .note{
        margin-top:10px;
        font-size:12px;
        line-height:1.6;
        color: var(--muted);
        font-weight:750;
      }
      .note b{ color: var(--text); }
      .defaultsBar{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        padding: 10px 12px;
        border-radius: 16px;
        border:1px solid var(--line);
        background: rgba(17,24,36,.35);
        color: var(--muted);
        font-weight:900;
        font-size:12px;
        line-height:1.5;
      }
      .defaultsBar .txt{ min-width:0; }
      .defaultsBar .actions{ display:flex; gap:8px; flex: 0 0 auto; }
      .defaultsBar.savedGame{
        border-color: rgba(110,168,255,.22);
        background: rgba(110,168,255,.10);
        color: var(--text);
        font-weight:850;
      }
      .error{
        margin-top:10px;
        padding: 10px 12px;
        border-radius: 14px;
        border:1px solid rgba(255,92,116,.35);
        background: rgba(255,92,116,.10);
        color: #ffd7dd;
        font-weight:850;
        font-size:12px;
        line-height:1.5;
        display:none;
      }

      .players{
        display:grid;
        grid-template-columns: 1fr;
        gap:10px;
      }

      .nameGrid{
        display:grid;
        grid-template-columns: 1fr;
        gap:10px;
        margin-top: 10px;
      }
      .nameRow{
        display:flex;
        align-items:center;
        gap:10px;
      }
      .nameRow .num{
        width:34px;
        height:34px;
        border-radius: 14px;
        display:grid;
        place-items:center;
        font-weight:950;
        background: rgba(255,255,255,.06);
        border:1px solid var(--line);
        color: var(--text);
        flex: 0 0 auto;
      }
      .nameRow input{
        width:100%;
        padding: 12px 12px;
        border-radius: 14px;
        border:1px solid var(--line);
        background: rgba(255,255,255,.90);
        color: #111;
        outline:none;
        font-weight:900;
        font-size:14px;
      }
      .nameRow input::placeholder{
        color: rgba(0,0,0,.55);
        font-weight:900;
      }

      .bigbtn{
        border:none;
        cursor:pointer;
        width:100%;
        padding: 14px 14px;
        border-radius: 18px;
        color: #f5f8ff;
        font-weight:1000;
        font-size:14px;
      }
      .bigbtn.blue{
        background: linear-gradient(135deg, rgba(60,118,255,.95), rgba(110,168,255,.88));
        box-shadow: 0 10px 28px rgba(60,118,255,.16);
      }
      .bigbtn.purple{
        background: linear-gradient(135deg, rgba(139,92,255,.92), rgba(190,98,255,.85));
        box-shadow: 0 10px 28px rgba(139,92,255,.16);
      }
      .bigbtn.primary{
        background: linear-gradient(135deg, rgba(110,168,255,.95), rgba(139,92,255,.92));
        box-shadow: 0 10px 28px rgba(110,168,255,.14);
      }
      .bigbtn.redbar{
        background: rgba(140,35,35,.55);
        border:1px solid rgba(255,255,255,.10);
      }
      .bigbtn:active{ transform: translateY(1px); }

      .banner{
        display:flex;
        align-items:center;
        justify-content:center;
        gap:10px;
        padding: 14px 12px;
        border-radius: 18px;
        border:1px solid var(--line);
        background: rgba(255,255,255,.92);
        color: #14161a;
        font-weight:1000;
        font-size: 18px;
        text-align:center;
      }
      .castBox{
        border-radius: 18px;
        border:2px solid rgba(255,255,255,.15);
        background: rgba(255,255,255,.95);
        overflow:hidden;
      }
      .castBox.mafia{ border-color: rgba(255,92,116,.55); }
      .castBox.city{ border-color: rgba(110,168,255,.55); }
      .castRow{
        display:grid;
        grid-template-columns: 1fr 1.2fr;
        gap:10px;
        padding: 10px 10px;
        border-top: 1px solid rgba(0,0,0,.08);
        align-items:center;
        color:#111;
        font-weight:950;
        font-size:13px;
      }
      .castRow[data-idx]{
        cursor:pointer;
      }
      .castRow.dead{
        opacity:.55;
        filter: grayscale(.25);
      }
      .castRow .leftMeta{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        min-width:0;
      }
      .castRow .statusPill{
        padding: 6px 9px;
        border-radius: 999px;
        border:1px solid rgba(0,0,0,.10);
        background: rgba(0,0,0,.06);
        font-weight:1000;
        font-size:11px;
        white-space:nowrap;
      }
      .castRow .statusPill.dead{
        background: rgba(255,92,116,.12);
        border-color: rgba(255,92,116,.25);
      }
      .castRow .statusPill.alive{
        background: rgba(53,208,127,.14);
        border-color: rgba(53,208,127,.25);
      }
      .castRow .statusPill.pending{
        background: rgba(255,196,77,.18);
        border-color: rgba(255,196,77,.35);
      }
      .castRow:first-child{ border-top:none; }
      .castRow .p{
        background: rgba(0,0,0,.08);
        border-radius: 12px;
        height: 12px;
        width: 100%;
        max-width: 140px;
        opacity: .55;
      }
      .castRow .who{
        display:flex;
        align-items:center;
        justify-content:flex-start;
        gap:10px;
        min-width:0;
      }
      .castRow .who .avatar{
        width: 34px;
        height: 34px;
        border-radius: 12px;
        background: rgba(0,0,0,.10);
        border:1px solid rgba(0,0,0,.10);
        display:grid;
        place-items:center;
        font-weight:1000;
        color:#111;
        flex: 0 0 auto;
        overflow:hidden;
      }
      .castRow .who .avatar svg{
        width: 22px;
        height: 22px;
        display:block;
      }
      .castRow.team-mafia .who .avatar{
        background: rgba(255,92,116,.16);
        border-color: rgba(255,92,116,.26);
        color: rgba(155,25,55,1);
      }
      .castRow.team-city .who .avatar{
        background: rgba(53,208,127,.16);
        border-color: rgba(53,208,127,.26);
        color: rgba(16,110,60,1);
      }
      .castRow.team-ind .who .avatar{
        background: rgba(255,189,46,.16);
        border-color: rgba(255,189,46,.26);
        color: rgba(122,78,10,1);
      }
      .castRow .who .role{
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }
      .player{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        padding: 12px 12px;
        border-radius: 18px;
        border:1px solid var(--line);
        background: rgba(17,24,36,.40);
      }
      .player .left{
        display:flex;
        align-items:center;
        gap:10px;
        min-width:0;
      }
      .badge{
        width:34px;
        height:34px;
        border-radius: 14px;
        display:grid;
        place-items:center;
        font-weight:950;
        background: rgba(255,255,255,.06);
        border:1px solid var(--line);
        color: var(--text);
        flex: 0 0 auto;
      }
      .player .txt{
        display:flex;
        flex-direction:column;
        gap:3px;
        min-width:0;
      }
      .player .pname{
        font-weight:950;
        font-size:13px;
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }
      .player .pstate{
        font-size:11px;
        font-weight:850;
        color: var(--muted);
      }
      .player .pstate.ok{ color: rgba(53,208,127,.95); }

      .smallbtn{
        border:none;
        cursor:pointer;
        font-weight:950;
        font-size:12px;
        padding: 10px 12px;
        border-radius: 14px;
        color: var(--text);
        background: rgba(255,255,255,.06);
        border:1px solid var(--line);
        flex: 0 0 auto;
      }
      .smallbtn.primary{
        background: rgba(110,168,255,.12);
        border-color: rgba(110,168,255,.28);
      }

      .roleBtn{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        padding: 12px 12px;
        border-radius: 18px;
        border:1px solid var(--line);
        background: rgba(17,24,36,.40);
        cursor:pointer;
        width:100%;
      }
      .roleBtn .left{
        display:flex;
        align-items:center;
        gap:10px;
        min-width:0;
      }
      .roleBtn .ravatar{
        width:34px;
        height:34px;
        border-radius: 14px;
        display:grid;
        place-items:center;
        font-weight:1000;
        background: rgba(255,255,255,.06);
        border:1px solid var(--line);
        color: var(--text);
        flex: 0 0 auto;
      }
      .roleBtn .rmeta{
        display:flex;
        flex-direction:column;
        gap:3px;
        min-width:0;
      }
      .roleBtn .rname{
        font-weight:1000;
        font-size:13px;
        color: var(--text);
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }
      .roleBtn .rteam{
        font-size:11px;
        font-weight:850;
        color: var(--muted);
      }
      .roleBtn .right{
        display:flex;
        align-items:center;
        gap:8px;
        flex: 0 0 auto;
      }
      .roleBtn .count{
        padding: 7px 10px;
        border-radius: 999px;
        border:1px solid var(--line);
        background: rgba(255,255,255,.04);
        color: var(--muted);
        font-weight:950;
        font-size:12px;
      }
      .roleBtn:active{ transform: translateY(1px); }

      .modal{
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.78);
        backdrop-filter: blur(3px);
        display:none;
        align-items:flex-end;
        justify-content:center;
        padding:
          16px
          14px
          calc(env(safe-area-inset-bottom) + 16px);
      }
      /* Center the role reveal modal (card description) */
      #modal{
        align-items:center;
        padding: 16px 14px 16px;
      }
      /* Tool modal (status/timer/etc.) looks better centered */
      #toolModal{
        align-items:center;
        padding:
          16px
          14px
          16px;
      }
      /* Make tool modals scrollable on small screens */
      #toolModal .sheet{
        max-height: 92vh;
        display:flex;
        flex-direction:column;
      }
      #toolModal .sheet .content{
        flex: 1 1 auto;
        min-height: 0;
        overflow:auto;
        -webkit-overflow-scrolling: touch;
      }
      #toolModal .sheet .bottom{
        flex: 0 0 auto;
      }
      .sheet{
        width:min(520px, 100%);
        border-radius: 22px;
        border:1px solid var(--line);
        background: linear-gradient(180deg, rgba(17,24,36,.98), rgba(15,23,34,.98));
        box-shadow: var(--shadow);
        overflow:hidden;
      }
      .sheet .top{
        padding: 12px 14px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        border-bottom:1px solid var(--line);
        background: rgba(0,0,0,.32);
      }
      .sheet .top .who{
        font-weight:950;
        font-size:13px;
      }
      .sheet .top .close{
        border:none;
        background: rgba(255,255,255,.06);
        border:1px solid var(--line);
        color: var(--text);
        font-weight:950;
        border-radius: 14px;
        padding: 9px 12px;
        cursor:pointer;
      }
      .sheet .content{
        padding: 14px 14px 12px;
        display:flex;
        flex-direction:column;
        gap:10px;
      }
      .roleCard{
        border-radius: 20px;
        border:1px solid var(--line);
        padding: 14px 14px;
        background: rgba(17,24,36,.55);
        position: relative;
        display:flex;
        flex-direction:column;
        gap:6px;
      }
      .roleHelpBtn{
        position:absolute;
        inset-inline-end: 10px;
        top: 10px;
        width: 34px;
        height: 34px;
        border-radius: 14px;
        border:1px solid var(--line);
        background: rgba(255,255,255,.06);
        color: var(--text);
        font-weight:1000;
        cursor:pointer;
      }
      .roleHelpBtn:active{ transform: translateY(1px); }
      .roleCard .rdesc.collapsed{ display:none; }
      .note.collapsed{ display:none; }
      .miniHelp{
        border:1px solid rgba(0,0,0,.10);
        background: rgba(255,255,255,.92);
        color:#111;
        width: 28px;
        height: 28px;
        border-radius: 12px;
        display:grid;
        place-items:center;
        font-weight:1100;
        cursor:pointer;
        flex: 0 0 auto;
      }
      .miniHelp:active{ transform: translateY(1px); }
      .roleCard .rname{
        font-weight:1000;
        font-size:18px;
        letter-spacing:-.2px;
      }
      .roleCard .rteam{
        display:inline-flex;
        align-self:flex-start;
        padding: 7px 10px;
        border-radius: 999px;
        font-weight:950;
        font-size:12px;
        border:1px solid var(--line);
        background: rgba(255,255,255,.04);
        color: var(--muted);
      }
      .roleCard .rdesc{
        margin-top:6px;
        font-size:13px;
        line-height:1.75;
        color: var(--text);
        font-weight:750;
      }

      /* Role reveal card (shown after picking a card) */
      .roleCard.roleReveal{
        text-align:center;
        align-items:center;
        gap:10px;
        padding: 18px 16px;
      }
      /* No need for "?" help button in role reveal */
      .roleCard.roleReveal .roleHelpBtn{ display:none; }
      .roleCard.roleReveal .ricon{
        width: 64px;
        height: 64px;
        border-radius: 22px;
        display:grid;
        place-items:center;
        border:1px solid rgba(255,255,255,.10);
        background: rgba(255,255,255,.06);
        color: var(--text);
      }
      .roleCard.roleReveal .ricon svg{
        width: 34px;
        height: 34px;
        display:block;
      }
      .roleCard.roleReveal .rname{
        font-size:26px;
        font-weight:1150;
        line-height:1.25;
      }
      .roleCard.roleReveal .rteam{
        align-self:center;
        font-size:14px;
        padding: 8px 12px;
      }
      .note.roleRevealNote{
        margin-top: 0;
        padding: 14px 14px;
        border-radius: 18px;
        border:1px solid rgba(255,255,255,.10);
        background: rgba(255,255,255,.06);
        font-size:16px;
        line-height:1.85;
        font-weight:850;
        color: var(--text);
        text-align:center;
      }
      /* Team tint for role reveal */
      .roleCard.roleReveal.team-mafia .rname,
      .note.roleRevealNote.team-mafia{ color: rgba(255,92,116,1); }
      .roleCard.roleReveal.team-city .rname,
      .note.roleRevealNote.team-city{ color: rgba(53,208,127,1); }
      .roleCard.roleReveal.team-ind .rname,
      .note.roleRevealNote.team-ind{ color: rgba(255,189,46,1); }
      .roleCard.roleReveal.team-mafia .ricon{
        border-color: rgba(255,92,116,.30);
        background: rgba(255,92,116,.10);
        color: rgba(255,92,116,1);
      }
      .roleCard.roleReveal.team-city .ricon{
        border-color: rgba(53,208,127,.30);
        background: rgba(53,208,127,.10);
        color: rgba(53,208,127,1);
      }
      .roleCard.roleReveal.team-ind .ricon{
        border-color: rgba(255,189,46,.30);
        background: rgba(255,189,46,.10);
        color: rgba(255,189,46,1);
      }
      .roleCard.roleReveal.team-mafia .rteam{
        border-color: rgba(255,92,116,.30);
        background: rgba(255,92,116,.10);
        color: rgba(255,92,116,1);
      }
      .roleCard.roleReveal.team-city .rteam{
        border-color: rgba(53,208,127,.30);
        background: rgba(53,208,127,.10);
        color: rgba(53,208,127,1);
      }
      .roleCard.roleReveal.team-ind .rteam{
        border-color: rgba(255,189,46,.30);
        background: rgba(255,189,46,.10);
        color: rgba(255,189,46,1);
      }
      .sheet .bottom{
        padding: 12px 14px 14px;
        display:flex;
        gap:10px;
        border-top:1px solid var(--line);
      }

      .hidden{ display:none !important; }

      .toolBar{
        display:grid;
        grid-template-columns: repeat(6, 1fr);
        gap:10px;
        margin-bottom: 10px;
      }
      .toolBtn{
        border:1px solid var(--line);
        background: rgba(255,255,255,.85);
        color:#111;
        border-radius: 14px;
        padding: 10px 8px;
        cursor:pointer;
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:center;
        gap:6px;
        min-height: 64px;
        font-weight:1000;
      }
      .toolBtn .ico{
        width: 30px;
        height: 30px;
        border-radius: 12px;
        display:grid;
        place-items:center;
        background: rgba(0,0,0,.08);
        border:1px solid rgba(0,0,0,.10);
        font-weight:1000;
      }
      .toolBtn .lbl{
        font-size:12px;
        font-weight:1000;
        color:#111;
        white-space:nowrap;
      }
      @media (max-width: 420px){
        .toolBar{ grid-template-columns: repeat(3, 1fr); }
      }

      .toolGrid{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap:10px;
      }
      .toolBox{
        border:1px solid rgba(255,255,255,.10);
        background: rgba(255,255,255,.08);
        border-radius: 16px;
        padding: 12px;
        color: var(--text);
      }
      .helpBox{
        border:1px solid var(--line);
        background: rgba(255,255,255,.04);
        border-radius: 18px;
        padding: 12px;
      }
      .helpBox .helpTitle{
        font-weight:1100;
        font-size:13px;
        margin-bottom: 8px;
      }
      .helpBox .helpText{
        font-weight:850;
        font-size:12px;
        line-height:1.8;
        color: var(--muted);
      }
      .helpBox .helpActions{
        margin-top: 10px;
        display:flex;
        justify-content:flex-start;
      }
      .toolBox.light{
        background: rgba(255,255,255,.92);
        color:#111;
        border-color: rgba(0,0,0,.08);
      }
      /* Player status sheet tweaks */
      .toolBox.lifeSheet{
        text-align:center;
      }
      .toolBox.lifeSheet .actions{
        justify-content:center;
      }
      .toolBox.lifeSheet .lifeActions{
        margin-top: 6px;
        display:flex;
        flex-direction:column;
        gap:10px;
      }
      .toolBox.lifeSheet .lifeActions .btn{
        width:100%;
        flex: 0 0 auto;
      }
      .toolBox.lifeSheet .lifeIcon{
        width: 64px;
        height: 64px;
        margin: 2px auto 0;
        border-radius: 22px;
        display:grid;
        place-items:center;
        border:1px solid rgba(255,255,255,.10);
        background: rgba(255,255,255,.06);
        color: var(--text);
      }
      .toolBox.lifeSheet .lifeIcon svg{
        width: 34px;
        height: 34px;
        display:block;
      }
      /* unify action button styling in life sheet */
      .toolBox.lifeSheet .lifeActionBtn{
        font-size:15px;
        font-weight:1100;
        padding: 14px 14px;
        border-radius: 18px;
        border: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
        box-shadow: 0 8px 22px rgba(102, 126, 234, 0.30);
        transition:
          transform .12s ease,
          filter .12s ease,
          box-shadow .12s ease;
      }
      .toolBox.lifeSheet .lifeActionBtn:hover{
        filter: brightness(1.05) saturate(1.05);
        transform: translateY(-1px);
        box-shadow: 0 10px 28px rgba(102, 126, 234, 0.36);
      }
      .toolBox.lifeSheet .lifeActionBtn:active{
        transform: scale(0.98);
        filter: brightness(.98) saturate(1.02);
        box-shadow: 0 6px 16px rgba(102, 126, 234, 0.28);
      }
      .toolBox.lifeSheet .lifeActionBtn.is-danger{
        /* from spy_game */
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        box-shadow: 0 8px 22px rgba(245, 87, 108, 0.30);
      }
      .toolBox.lifeSheet .lifeActionBtn.is-warn{
        /* from spy_game (primary) */
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        box-shadow: 0 8px 22px rgba(102, 126, 234, 0.30);
      }
      .toolBox.lifeSheet .lifeActionBtn.is-ok{
        /* from spy_game */
        background: linear-gradient(135deg, #3b95e4 0%, #43dbe3 100%);
        box-shadow: 0 8px 22px rgba(79, 172, 254, 0.30);
      }
      .toolBox.lifeSheet .lifeName{
        font-weight:1150;
        font-size:26px;
        line-height:1.3;
      }
      .toolBox.lifeSheet .lifeMeta{
        margin-top: 12px;
        font-weight:1000;
        font-size:19px;
        line-height:1.75;
      }
      .toolBox.lifeSheet .lifeMeta .k{
        opacity:.75;
        font-weight:950;
      }
      .toolBox.lifeSheet.team-mafia .lifeMeta{ color: rgba(255,92,116,1); }
      .toolBox.lifeSheet.team-city .lifeMeta{ color: rgba(53,208,127,1); }
      .toolBox.lifeSheet.team-ind .lifeMeta{ color: rgba(255,189,46,1); }
      .toolBox.lifeSheet.team-mafia .lifeIcon{
        border-color: rgba(255,92,116,.30);
        background: rgba(255,92,116,.10);
        color: rgba(255,92,116,1);
      }
      .toolBox.lifeSheet.team-city .lifeIcon{
        border-color: rgba(53,208,127,.30);
        background: rgba(53,208,127,.10);
        color: rgba(53,208,127,1);
      }
      .toolBox.lifeSheet.team-ind .lifeIcon{
        border-color: rgba(255,189,46,.30);
        background: rgba(255,189,46,.10);
        color: rgba(255,189,46,1);
      }
      .kv{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
      }
      .kv .k{ font-weight:950; font-size:12px; opacity:.9; }
      .kv .v{ font-weight:1100; font-size:22px; letter-spacing:.3px; }
      .stepper{
        display:flex;
        align-items:center;
        gap:8px;
      }
      .stepper button{
        border:1px solid rgba(0,0,0,.12);
        background: rgba(255,255,255,.92);
        color:#111;
        font-weight:1100;
        width: 34px;
        height: 34px;
        border-radius: 14px;
        cursor:pointer;
      }
      .stepper .num{
        min-width: 36px;
        text-align:center;
        font-weight:1100;
        font-size:16px;
      }

      .timerRow{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap:10px;
      }
      .timerCard{
        border-radius: 18px;
        border:1px solid rgba(255,255,255,.10);
        background: rgba(255,255,255,.92);
        color:#111;
        padding: 12px;
        display:flex;
        flex-direction:column;
        gap:8px;
        align-items:center;
      }
      .timerCard .tname{ font-weight:1000; font-size:13px; }
      .timerCard .tval{ font-weight:1200; font-size:34px; letter-spacing:1px; }
      .timerCard .tval.clickable{
        cursor:pointer;
        user-select:none;
      }
      .timerCard .tbtn{
        border:none;
        cursor:pointer;
        width: 52px;
        height: 52px;
        border-radius: 999px;
        display:grid;
        place-items:center;
        background: linear-gradient(135deg, rgba(110,168,255,.95), rgba(139,92,255,.92));
        color:#fff;
        font-weight:1200;
        font-size:16px;
        box-shadow: 0 10px 24px rgba(110,168,255,.22);
        -webkit-tap-highlight-color: transparent;
      }
      .timerCard .tbtn.is-running{
        background: rgba(0,0,0,.86);
        box-shadow: 0 10px 24px rgba(0,0,0,.16);
      }
      .timerCard .tbtn svg{
        width: 22px;
        height: 22px;
        display:block;
        fill: currentColor;
      }
      .timerCard .tbtn:active{
        transform: translateY(1px) scale(.98);
      }
      .timerActions{
        display:flex;
        gap:10px;
        margin-top: 10px;
      }
      .timerActions button{
        flex:1;
        border:none;
        cursor:pointer;
        padding: 12px 12px;
        border-radius: 16px;
        font-weight:1100;
      }
      .timerActions .reset{
        background: rgba(255,255,255,.88);
        color:#111;
        border:1px solid rgba(0,0,0,.10);
      }
      .timerActions .close{
        background: rgba(110,168,255,.18);
        color: var(--text);
        border:1px solid rgba(110,168,255,.30);
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="topbar">
        <div class="title" data-i18n="app.title">Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù† Ø¨Ø§Ø²ÛŒ Ù…Ø§ÙÛŒØ§</div>
        <div class="topActions">
          <div class="chip clickable" id="langChip" role="button" tabindex="0" aria-label="ØªØºÛŒÛŒØ± Ø²Ø¨Ø§Ù†">
            <span class="label" id="langLabel">English</span>
            <button id="langBtn" type="button" aria-hidden="true">ğŸŒ</button>
          </div>
          <div class="chip clickable" id="helpChip" role="button" tabindex="0" aria-label="Ø±Ø§Ù‡Ù†Ù…Ø§" data-i18n-aria-label="top.help">
            <span class="label" data-i18n="top.help">Ø±Ø§Ù‡Ù†Ù…Ø§</span>
          </div>
        </div>
      </div>

      <div class="card" id="setupCard">
        <div class="hd">
          <h2 data-i18n="setup.title">ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ</h2>
          <span class="chip" id="quickStat">â€”</span>
        </div>
        <div class="bd">
          <button class="bigbtn redbar" id="backBarBtn" type="button" style="display:none" data-i18n="setup.backToSetup">Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ</button>

          <div class="row">
            <label>
              <span data-i18n="setup.scenario">Ø³Ù†Ø§Ø±ÛŒÙˆ</span>
              <select id="scenario">
                <option value="bazras">Ø¨Ø§Ø²Ù¾Ø±Ø³</option>
                <option value="namayande">Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡</option>
                <option value="mozaker">Ù…Ø°Ø§Ú©Ø±Ù‡</option>
                <option value="classic">Ú©Ù„Ø§Ø³ÛŒÚ©</option>
                <option value="takavar">ØªÚ©Ø§ÙˆØ±</option>
                <option value="kabo">Ú©Ø§Ù¾Ùˆ</option>
                <option value="pedarkhande">Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡</option>
                <option value="zodiac">Ø²ÙˆØ¯ÛŒØ§Ú©</option>
                <option value="meeting_epic">Ù…ÛŒØªÛŒÙ†Ú¯/Ø§Ù¾ÛŒÚ©</option>
                <option value="pishrafte">Ù¾ÛŒØ´Ø±ÙØªÙ‡</option>
                <option value="shab_mafia">Ø´Ø¨ Ù…Ø§ÙÛŒØ§</option>
              </select>
            </label>
            <label>
              <span data-i18n="setup.playersCount">ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†â€ŒÙ‡Ø§</span>
              <select id="playersCount"></select>
            </label>
          </div>

          <div class="row one">
            <label>
              <span data-i18n="setup.mafiaCount">ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§</span>
              <select id="mafiaCount"></select>
            </label>
          </div>

          <div class="row one">
            <div class="error" id="errorBox"></div>
          </div>

          <div class="toggles" id="toggles">
            <!-- injected -->
          </div>

          <div class="row one" style="margin-top:12px">
            <div class="actions">
              <button class="btn" id="scenarioDefaultsBtn" type="button" data-i18n="setup.defaults">Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø³Ù†Ø§Ø±ÛŒÙˆ</button>
              <button class="btn primary" id="startGameBtn" type="button" data-i18n="setup.start">Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ</button>
            </div>
            <button class="btn" id="resumeBtn" type="button" style="display:none">Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø§Ø²ÛŒ</button>
          </div>

          <div class="row one" id="savedGameBarRow" style="display:none; margin-top:12px">
            <div class="defaultsBar savedGame">
              <div class="txt" id="savedGameBarText" data-i18n="setup.savedGame">ÛŒÚ© Ø¨Ø§Ø²ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª.</div>
              <div class="actions" id="savedGameBarActions">
                <button class="btn" id="savedGameResumeBtn" type="button" data-i18n="setup.resume">Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø§Ø²ÛŒ</button>
                <button class="btn danger" id="savedGameClearBtn" type="button" data-i18n="setup.delete">Ø­Ø°Ù</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="card hidden" id="playersCard">
        <div class="hd">
          <h2 data-i18n="players.title">Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†</h2>
          <span class="chip" id="playersStat">â€”</span>
        </div>
        <div class="bd">
          <div class="row one">
            <div class="pill" role="tablist" aria-label="Ø­Ø§Ù„Øª Ù†Ø§Ù…â€ŒÙ‡Ø§" data-i18n-aria-label="players.namesModeAria">
              <button id="namesDefaultBtn" type="button" class="active" data-i18n="players.namesDefault">Ø§Ø³Ø§Ù…ÛŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶</button>
              <button id="namesLastBtn" type="button" data-i18n="players.namesLast">Ø§Ø³Ø§Ù…ÛŒ Ø¨Ø§Ø²ÛŒ Ù‚Ø¨Ù„</button>
            </div>
            <div class="note" data-i18n="players.note">Ø§Ø³Ø§Ù…ÛŒ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯. Ø§Ú¯Ø± Â«Ø§Ø³Ø§Ù…ÛŒ Ø¨Ø§Ø²ÛŒ Ù‚Ø¨Ù„Â» Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ØŒ Ø§Ø² Ø°Ø®ÛŒØ±Ù‡â€ŒÛŒ Ù…Ø±ÙˆØ±Ú¯Ø± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.</div>
            <div class="nameGrid" id="nameGrid"></div>
            <div class="error" id="errorBoxPlayers"></div>
          </div>

          <div class="row one" style="margin-top:12px">
            <button class="bigbtn primary" id="dealBtn" type="button" data-i18n="players.deal">ØªÙ‚Ø³ÛŒÙ… Ù†Ù‚Ø´</button>
            <div class="actions">
              <button class="btn" id="playersBackBtn" type="button" data-i18n="players.back">Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª</button>
            </div>
          </div>
        </div>
      </div>

      <div class="card hidden" id="cardsCard">
        <div class="hd">
          <h2 data-i18n="cards.title">ØªÙ‚Ø³ÛŒÙ… Ù†Ù‚Ø´</h2>
          <span class="chip" id="cardsStat">â€”</span>
        </div>
        <div class="bd">
          <div class="cardsCenter">
            <div class="banner">
              <div id="cardsWho">Ù†ÙˆØ¨Øª: â€”</div>
            </div>

            <div class="note" id="cardsHint" data-i18n="cards.hint">Ø¨Ø§Ø²ÛŒÚ©Ù† ÛŒÚ© Ú©Ø§Ø±Øª Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ù†Ù‚Ø´ Ø®ÙˆØ¯Ø´ Ø±Ø§ Ù…ÛŒâ€ŒØ¨ÛŒÙ†Ø¯.</div>

            <div class="cardsGrid" id="cardsGrid"></div>
          </div>

          <div class="actions wrap">
            <button class="btn" id="cardsBackBtn" type="button" data-i18n="cards.back">Ø¨Ø§Ø²Ú¯Ø´Øª</button>
            <button class="btn" id="autoAssignBtn" type="button" data-i18n="cards.autoAssign">Ø§Ø®ØªØµØ§Øµ Ø§ØªÙˆÙ…Ø§Øª Ù†Ù‚Ø´â€ŒÙ‡Ø§</button>
            <button class="btn primary" id="cardsNextBtn" type="button" disabled data-i18n="cards.next">Ø¨Ø±Ùˆ Ù…Ø±Ø­Ù„Ù‡ Ø¨Ø¹Ø¯!</button>
          </div>
        </div>
      </div>

      <div class="card hidden" id="castCard">
        <div class="hd">
          <h2 data-i18n="cast.title">ÙÙ‡Ø±Ø³Øª Ø´Ø®ØµÛŒØªâ€ŒÙ‡Ø§</h2>
          <span class="chip" id="castStat">â€”</span>
        </div>
        <div class="bd">
          <div class="toolBar" id="godTools">
            <button class="toolBtn" id="toolFlow" type="button">
              <div class="ico">ğŸ§­</div>
              <div class="lbl" data-i18n="tools.flow">Ø¬Ø±ÛŒØ§Ù†</div>
            </button>
            <button class="toolBtn" id="toolTimer" type="button">
              <div class="ico">â±</div>
              <div class="lbl" data-i18n="tools.timer">ØªØ§ÛŒÙ…</div>
            </button>
            <button class="toolBtn" id="toolStatus" type="button">
              <div class="ico">ğŸ”</div>
              <div class="lbl" data-i18n="tools.status">Ø§Ø³ØªØ¹Ù„Ø§Ù…</div>
            </button>
            <button class="toolBtn" id="toolRoleChange" type="button">
              <div class="ico">ğŸ­</div>
              <div class="lbl" data-i18n="tools.roleChange">ØªØºÛŒÛŒØ± Ù†Ù‚Ø´</div>
            </button>
          </div>

          <div class="castBox mafia" id="castMafia"></div>
          <div style="height:12px"></div>
          <div class="castBox city" id="castCity"></div>
          <div style="height:12px"></div>
          <div class="castBox" id="castInd" style="display:none"></div>

          <div class="actions">
            <button class="btn" id="castBackBtn" type="button" data-i18n="cast.back">Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ</button>
            <button class="btn primary" id="castNewBtn" type="button" data-i18n="cast.new">Ù‚Ø±Ø¹Ù‡â€ŒÚ©Ø´ÛŒ Ø¬Ø¯ÛŒØ¯</button>
          </div>
        </div>
      </div>

    </div>

    <div class="modal" id="modal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="sheet">
        <div class="top">
          <div class="who" id="modalWho">â€”</div>
          <button class="close" id="modalCloseBtn" type="button" data-i18n="common.close">Ø¨Ø³ØªÙ†</button>
        </div>
        <div class="content">
          <div class="roleCard roleReveal" id="roleCard">
            <button class="roleHelpBtn" id="roleHelpBtn" type="button" title="Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ù†Ù‚Ø´" data-i18n-title="common.roleHelp">ØŸ</button>
            <div class="ricon" id="roleIcon" aria-hidden="true"></div>
            <div class="rname" id="roleName">â€”</div>
            <div class="rteam" id="roleTeam">â€”</div>
            <div class="rdesc collapsed" id="roleDesc">â€”</div>
          </div>
          <div class="note roleRevealNote" id="modalNote"></div>
        </div>
        <div class="bottom">
          <button class="btn primary" id="markRevealedBtn" type="button" data-i18n="common.seen">Ø¯ÛŒØ¯Ù…</button>
        </div>
      </div>
    </div>

    <div class="modal" id="toolModal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="sheet">
        <div class="top">
          <div class="who" id="toolTitle">â€”</div>
          <button class="close" id="toolCloseBtn" type="button" data-i18n="common.close">Ø¨Ø³ØªÙ†</button>
        </div>
        <div class="content" id="toolBody">
          <!-- injected -->
        </div>
        <div class="bottom" id="toolBottom">
          <button class="btn primary" id="toolOkBtn" type="button" data-i18n="common.close">Ø¨Ø³ØªÙ†</button>
        </div>
      </div>
    </div>

    <script>
      (function () {
        const $ = (id) => document.getElementById(id);

        const STORAGE_KEY = "mafia_v2_simple_web_state_v1";
        const LAST_NAMES_KEY = "mafia_v2_simple_web_last_names_v1";

        const LANG_KEY = "mafia_v2_simple_web_lang_v1";
        let appLang = "fa"; // "fa" | "en"

        const STR = {
          fa: {
            "doc.title": "Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù† Ø¨Ø§Ø²ÛŒ Ù…Ø§ÙÛŒØ§",
            "app.title": "Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù† Ø¨Ø§Ø²ÛŒ Ù…Ø§ÙÛŒØ§",
            "top.help": "Ø±Ø§Ù‡Ù†Ù…Ø§",
            "top.lang.aria": "ØªØºÛŒÛŒØ± Ø²Ø¨Ø§Ù†",
            "top.lang.toFa": "ÙØ§Ø±Ø³ÛŒ",
            "top.lang.toEn": "English",

            "setup.title": "ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ",
            "setup.backToSetup": "Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ",
            "setup.scenario": "Ø³Ù†Ø§Ø±ÛŒÙˆ",
            "setup.playersCount": "ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†â€ŒÙ‡Ø§",
            "setup.mafiaCount": "ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§",
            "setup.defaults": "Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø³Ù†Ø§Ø±ÛŒÙˆ",
            "setup.start": "Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ",
            "setup.savedGame": "ÛŒÚ© Ø¨Ø§Ø²ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª.",
            "setup.resume": "Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø§Ø²ÛŒ",
            "setup.delete": "Ø­Ø°Ù",

            "players.title": "Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†",
            "players.namesModeAria": "Ø­Ø§Ù„Øª Ù†Ø§Ù…â€ŒÙ‡Ø§",
            "players.namesDefault": "Ø§Ø³Ø§Ù…ÛŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶",
            "players.namesLast": "Ø§Ø³Ø§Ù…ÛŒ Ø¨Ø§Ø²ÛŒ Ù‚Ø¨Ù„",
            "players.note": "Ø§Ø³Ø§Ù…ÛŒ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯. Ø§Ú¯Ø± Â«Ø§Ø³Ø§Ù…ÛŒ Ø¨Ø§Ø²ÛŒ Ù‚Ø¨Ù„Â» Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ØŒ Ø§Ø² Ø°Ø®ÛŒØ±Ù‡â€ŒÛŒ Ù…Ø±ÙˆØ±Ú¯Ø± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.",
            "players.deal": "ØªÙ‚Ø³ÛŒÙ… Ù†Ù‚Ø´",
            "players.back": "Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª",

            "cards.title": "ØªÙ‚Ø³ÛŒÙ… Ù†Ù‚Ø´",
            "cards.hint": "Ø¨Ø§Ø²ÛŒÚ©Ù† ÛŒÚ© Ú©Ø§Ø±Øª Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ù†Ù‚Ø´ Ø®ÙˆØ¯Ø´ Ø±Ø§ Ù…ÛŒâ€ŒØ¨ÛŒÙ†Ø¯.",
            "cards.back": "Ø¨Ø§Ø²Ú¯Ø´Øª",
            "cards.autoAssign": "Ø§Ø®ØªØµØ§Øµ Ø§ØªÙˆÙ…Ø§Øª Ù†Ù‚Ø´â€ŒÙ‡Ø§",
            "cards.next": "Ø¨Ø±Ùˆ Ù…Ø±Ø­Ù„Ù‡ Ø¨Ø¹Ø¯!",

            "cast.title": "ÙÙ‡Ø±Ø³Øª Ø´Ø®ØµÛŒØªâ€ŒÙ‡Ø§",
            "cast.back": "Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ",
            "cast.new": "Ù‚Ø±Ø¹Ù‡â€ŒÚ©Ø´ÛŒ Ø¬Ø¯ÛŒØ¯",

            "tools.wake": "Ø¨ÛŒØ¯Ø§Ø±ÛŒ",
            "tools.status": "Ø§Ø³ØªØ¹Ù„Ø§Ù…",
            "tools.lastMove": "Ø­Ø±Ú©Øª Ø¢Ø®Ø±",
            "tools.roleChange": "ØªØºÛŒÛŒØ± Ù†Ù‚Ø´",
            "tools.chance": "Ù‚Ø±Ø¹Ù‡",
            "tools.timer": "ØªØ§ÛŒÙ…",
            "tools.flow": "Ø¬Ø±ÛŒØ§Ù†",

            "common.close": "Ø¨Ø³ØªÙ†",
            "common.seen": "Ø¯ÛŒØ¯Ù…",
            "common.roleHelp": "Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ù†Ù‚Ø´",
            "common.on": "Ø±ÙˆØ´Ù†",
            "common.off": "Ø®Ø§Ù…ÙˆØ´",
            "common.done": "ØªÙ…Ø§Ù… Ø´Ø¯",
            "common.turn": "Ù†ÙˆØ¨Øª",
            "common.playerN": "Ø¨Ø§Ø²ÛŒÚ©Ù† {n}",
            "common.cardN": "Ú©Ø§Ø±Øª {n}",
            "common.taken": "Ø¨Ø±Ø¯Ø§Ø´ØªÙ‡ Ø´Ø¯",

            "saveState.label": "Ø°Ø®ÛŒØ±Ù‡: {state}",
            "error.config": "Ø®Ø·Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ.",
            "error.quick": "Ø®Ø·Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ…Ø§Øª",
            "error.duplicateName": "Ù†Ø§Ù… Â«{name}Â» ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª.",

            "teams.mafia": "Ù…Ø§ÙÛŒØ§",
            "teams.city": "Ø´Ù‡Ø±",
            "teams.independent": "Ù…Ø³ØªÙ‚Ù„",
            "teams.mafiaTeam": "ØªÛŒÙ… Ù…Ø§ÙÛŒØ§",
            "teams.cityTeam": "ØªÛŒÙ… Ø´Ù‡Ø±",

            "toggles.variableCount": "ØªØ¹Ø¯Ø§Ø¯: Ù…ØªØºÛŒØ±",

            "quickStat.withInd": "Ù…Ø§ÙÛŒØ§: {m} â€¢ Ø´Ù‡Ø±: {c} â€¢ Ù…Ø³ØªÙ‚Ù„: {i}",
            "quickStat.noInd": "Ù…Ø§ÙÛŒØ§: {m} â€¢ Ø´Ù‡Ø±: {c}",

            "help.title": "Ø±Ø§Ù‡Ù†Ù…Ø§",
            "help.quick": "Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø³Ø±ÛŒØ¹",
            "help.body": `1) Ø³Ù†Ø§Ø±ÛŒÙˆØŒ ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†â€ŒÙ‡Ø§ Ùˆ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§ Ø±Ø§ ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯.<br />
2) Ù†Ù‚Ø´â€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„ Ø±Ø§ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ) Ø±ÙˆØ´Ù†/Ø®Ø§Ù…ÙˆØ´ Ú©Ù†ÛŒØ¯.<br />
3) Â«Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒÂ» Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯ Ùˆ Ø§Ø³Ø§Ù…ÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.<br />
4) Â«ØªÙ‚Ø³ÛŒÙ… Ù†Ù‚Ø´Â» Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯Ø› Ù‡Ø± Ø¨Ø§Ø²ÛŒÚ©Ù† ÛŒÚ© Ú©Ø§Ø±Øª Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Â«Ø¯ÛŒØ¯Ù…Â» Ø±Ø§ Ù…ÛŒâ€ŒØ²Ù†Ø¯.<br />
5) Ø¯Ø± Â«ÙÙ‡Ø±Ø³Øª Ø´Ø®ØµÛŒØªâ€ŒÙ‡Ø§Â»ØŒ Ø±Ø§ÙˆÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ (ØªØ§ÛŒÙ…Ø±/Ù‚Ø±Ø¹Ù‡/ØªØºÛŒÛŒØ± Ù†Ù‚Ø´/ÙˆØ¶Ø¹ÛŒØª) Ø±Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†Ø¯.`,

            "tool.wake.title": "ØªØ±ØªÛŒØ¨ Ø¨ÛŒØ¯Ø§Ø±ÛŒ",
            "tool.wake.scenario": "Ø³Ù†Ø§Ø±ÛŒÙˆ: {name}",
            "tool.wake.none": "Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³Ù†Ø§Ø±ÛŒÙˆ ØªØ±ØªÛŒØ¨ Ø¨ÛŒØ¯Ø§Ø±ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.",

            "tool.status.title": "Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙˆØ¶Ø¹ÛŒØª",
            "tool.status.alive": "Ø§ÙØ±Ø§Ø¯ Ø²Ù†Ø¯Ù‡",
            "tool.status.dead": "Ø§ÙØ±Ø§Ø¯ Ù…Ø±Ø¯Ù‡",
            "tool.status.mafiaAlive": "Ù…Ø§ÙÛŒØ§ Ø²Ù†Ø¯Ù‡",
            "tool.status.mafiaDead": "Ù…Ø§ÙÛŒØ§ Ù…Ø±Ø¯Ù‡",
            "tool.status.cityAlive": "Ø´Ù‡Ø± Ø²Ù†Ø¯Ù‡",
            "tool.status.cityDead": "Ø´Ù‡Ø± Ù…Ø±Ø¯Ù‡",
            "tool.status.indAlive": "Ù…Ø³ØªÙ‚Ù„ Ø²Ù†Ø¯Ù‡",
            "tool.status.indDead": "Ù…Ø³ØªÙ‚Ù„ Ù…Ø±Ø¯Ù‡",
            "tool.status.hint": "Ø¨Ø±Ø§ÛŒ ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ù‡Ø± Ø¨Ø§Ø²ÛŒÚ©Ù†ØŒ Ø¯Ø± ØµÙØ­Ù‡ Â«ÙÙ‡Ø±Ø³Øª Ø´Ø®ØµÛŒØªâ€ŒÙ‡Ø§Â» Ø±ÙˆÛŒ Ù†Ø§Ù… Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø²Ù†ÛŒØ¯ Ùˆ Â«Ú©Ø´ØªÙ‡ Ø´Ø¯Â» Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.",
            "tool.status.summary": "Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ {out} Ù†ÙØ± Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯. {m} Ù…Ø§ÙÛŒØ§ØŒ {c} Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ùˆ {i} Ù…Ø³ØªÙ‚Ù„.",

            "tool.flow.title": "Ú¯Ø±Ø¯Ø§Ù†Ù†Ø¯Ù‡Ù” Ø¨Ø§Ø²ÛŒ",
            "tool.flow.needDeal": "Ø§Ø¨ØªØ¯Ø§ Ù†Ù‚Ø´â€ŒÙ‡Ø§ Ø±Ø§ ØªÙ‚Ø³ÛŒÙ… Ú©Ù†ÛŒØ¯.",
            "tool.flow.phase.day": "Ø±ÙˆØ² {n}",
            "tool.flow.phase.midday": "Ø®ÙˆØ§Ø¨ Ù†ÛŒÙ…â€ŒØ±ÙˆØ² (Ø±ÙˆØ² {n})",
            "tool.flow.phase.night": "Ø´Ø¨ {n}",
            "tool.flow.step": "Ù…Ø±Ø­Ù„Ù‡ {i} Ø§Ø² {n}",
            "tool.flow.next": "Ø¨Ø¹Ø¯ÛŒ",
            "tool.flow.prev": "Ù‚Ø¨Ù„ÛŒ",
            "tool.flow.reset": "Ø±ÛŒØ³Øª Ø¬Ø±ÛŒØ§Ù†",
            "tool.flow.timeline": "ØªØ§ÛŒÙ…â€ŒÙ„Ø§ÛŒÙ†",
            "tool.flow.log": "Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§",
            "tool.flow.addNote": "Ø«Ø¨Øª ÛŒØ§Ø¯Ø¯Ø§Ø´Øª",
            "tool.flow.notePlayer": "Ø¨Ø§Ø²ÛŒÚ©Ù†",
            "tool.flow.notePlaceholder": "Ú†Ù‡ Ø§ØªÙØ§Ù‚ÛŒ Ø§ÙØªØ§Ø¯ØŸ",
            "tool.flow.saveNote": "Ø«Ø¨Øª",
            "tool.flow.day.talk": "Ù†ÙˆØ¨Øª ØµØ­Ø¨Øª",
            "tool.flow.day.guns": "Ø´Ù„ÛŒÚ© ØªÙÙ†Ú¯",
            "tool.flow.guns.title": "Ù…Ø¯ÛŒØ±ÛŒØª ØªÙÙ†Ú¯â€ŒÙ‡Ø§",
            "tool.flow.guns.hasGun": "Ø¯Ø§Ø±Ù†Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªÙÙ†Ú¯",
            "tool.flow.guns.add": "Ø¯Ø§Ø¯Ù† ØªÙÙ†Ú¯",
            "tool.flow.guns.giveTo": "Ø¯Ø§Ø¯Ù† Ø¨Ù‡",
            "tool.flow.guns.type": "Ù†ÙˆØ¹ ØªÙÙ†Ú¯",
            "tool.flow.guns.type.real": "ÙˆØ§Ù‚Ø¹ÛŒ",
            "tool.flow.guns.type.fake": "Ù…Ø´Ù‚ÛŒ",
            "tool.flow.guns.selfFakeOnly": "ØªÙÙ†Ú¯Ø¯Ø§Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ù‡ Ù‡Ø±Ú©Ø³ÛŒ ØªÙÙ†Ú¯ Ø¨Ø¯Ù‡Ø¯Ø› Ø§Ù…Ø§ Ø¨Ù‡ Ø®ÙˆØ¯Ø´ ÙÙ‚Ø· ØªÙÙ†Ú¯Ù Ù…Ø´Ù‚ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø¯Ù‡Ø¯.",
            "tool.flow.guns.nightQuota": "Ø³Ù‡Ù…ÛŒÙ‡Ù” Ø§ÛŒÙ† Ø´Ø¨: {n}/2 ØªÙÙ†Ú¯ â€¢ ÙˆØ§Ù‚Ø¹ÛŒ: {r}/1",
            "tool.flow.guns.limit2": "Ø¯Ø± Ù‡Ø± Ø´Ø¨ Ø­Ø¯Ø§Ú©Ø«Ø± Û² ØªÙÙ†Ú¯ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø¯Ù‡Ø¯.",
            "tool.flow.guns.limit1Real": "Ø¯Ø± Ù‡Ø± Ø´Ø¨ Ø­Ø¯Ø§Ú©Ø«Ø± Û± ØªÙÙ†Ú¯ ÙˆØ§Ù‚Ø¹ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø¯Ù‡Ø¯.",
            "tool.flow.guns.gunslingerIs": "ØªÙÙ†Ú¯Ø¯Ø§Ø±: {name}",
            "tool.flow.guns.give": "Ø«Ø¨Øª ØªÙÙ†Ú¯",
            "tool.flow.guns.remove": "Ø­Ø°Ù ØªÙÙ†Ú¯",
            "tool.flow.guns.shooter": "Ø´Ù„ÛŒÚ©â€ŒÚ©Ù†Ù†Ø¯Ù‡",
            "tool.flow.guns.target": "Ù‡Ø¯Ù",
            "tool.flow.guns.fire": "Ø«Ø¨Øª Ø´Ù„ÛŒÚ©",
            "tool.flow.guns.noEffect": "ØªÙÙ†Ú¯ Ù…Ø´Ù‚ÛŒ Ø¨ÙˆØ¯ (Ø¨Ø¯ÙˆÙ† Ø§Ø«Ø±).",
            "tool.flow.guns.killedTarget": "ØªÙÙ†Ú¯ ÙˆØ§Ù‚Ø¹ÛŒ Ø¨ÙˆØ¯ (Ù‡Ø¯Ù Ø®Ø§Ø±Ø¬ Ø´Ø¯).",
            "tool.flow.ocean.team": "ØªÛŒÙ… Ø§ÙˆØ´Ù† (Ø§ÛŒÙ† Ø´Ø¨)",
            "tool.flow.ocean.add": "Ø§Ø¶Ø§ÙÙ‡â€ŒÚ©Ø±Ø¯Ù† Ø¨Ù‡ ØªÛŒÙ… Ø§ÙˆØ´Ù†",
            "tool.flow.ocean.pick": "Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ø§Ø²ÛŒÚ©Ù†",
            "tool.flow.ocean.remove": "Ø­Ø°Ù Ø§Ø² ØªÛŒÙ…",
            "tool.flow.day.vote": "Ø±Ø£ÛŒâ€ŒÚ¯ÛŒØ±ÛŒ",
            "tool.flow.vote.hint": "Ø¨Ù‡ Ù‡Ø± Ø¨Ø§Ø²ÛŒÚ©Ù†Ù Ø²Ù†Ø¯Ù‡ØŒ ØªØ¹Ø¯Ø§Ø¯ Ø±Ø£ÛŒ Ø¯Ø±ÛŒØ§ÙØªÛŒ Ø±Ø§ Ø¨Ø¯Ù‡ÛŒØ¯.",
            "tool.flow.vote.votes": "ØªØ¹Ø¯Ø§Ø¯ Ø±Ø£ÛŒ",
            "tool.flow.vote.apply": "Ø«Ø¨Øª Ø±Ø£ÛŒâ€ŒÙ‡Ø§",
            "tool.flow.vote.clear": "Ù¾Ø§Ú© Ú©Ø±Ø¯Ù†",
            "tool.flow.vote.total": "Ù…Ø¬Ù…ÙˆØ¹ Ø±Ø£ÛŒâ€ŒÙ‡Ø§: {n}",
            "tool.flow.vote.leaders": "Ø¨ÛŒØ´ØªØ±ÛŒÙ† Ø±Ø£ÛŒâ€ŒÙ‡Ø§",
            "tool.flow.defense.hint": "Ø¨Ø± Ø§Ø³Ø§Ø³ Ø±Ø£ÛŒâ€ŒÙ‡Ø§ÛŒ Ø«Ø¨Øªâ€ŒØ´Ø¯Ù‡ØŒ Ú©Ø³Ø§Ù†ÛŒ Ú©Ù‡ Ø­Ø¯Ù†ØµØ§Ø¨ Ø§Ú©Ø«Ø±ÛŒØª Ø±Ø§ Ø¯Ø§Ø±Ù†Ø¯ Ø¨Ø§ÛŒØ¯ Ø¯ÙØ§Ø¹ Ú©Ù†Ù†Ø¯.",
            "tool.flow.defense.threshold": "Ø­Ø¯Ù†ØµØ§Ø¨ Ø§Ú©Ø«Ø±ÛŒØª: {n} (Ø¨ÛŒØ´ Ø§Ø² Ù†ØµÙÙ {v} Ø±Ø£ÛŒâ€ŒØ¯Ù‡Ù†Ø¯Ù‡)",
            "tool.flow.defense.none": "Ú©Ø³ÛŒ Ø¨Ù‡ Ø­Ø¯Ù†ØµØ§Ø¨ Ù†Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª.",
            "tool.flow.defense.needVotes": "Ø§Ø¨ØªØ¯Ø§ Ù…Ø±Ø­Ù„Ù‡ Â«Ø±Ø£ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÂ» Ø±Ø§ Ø«Ø¨Øª Ú©Ù†ÛŒØ¯.",
            "tool.flow.defense.list": "Ù„ÛŒØ³Øª Ø¯ÙØ§Ø¹ÛŒÙ‡",
            "tool.flow.elim.hint": "Ø¨Ø¹Ø¯ Ø§Ø² Ø¯ÙØ§Ø¹ÛŒÙ‡ØŒ ØªØ¹Ø¯Ø§Ø¯ Ø±Ø£ÛŒÙ Ø®Ø±ÙˆØ¬ Ø¨Ø±Ø§ÛŒ Ù…Ø¸Ù†ÙˆÙ†â€ŒÙ‡Ø§ Ø±Ø§ Ø«Ø¨Øª Ú©Ù†ÛŒØ¯. Ø¨ÛŒØ´ØªØ±ÛŒÙ† Ø±Ø£ÛŒ = Ø®Ø±ÙˆØ¬. Ø§Ú¯Ø± Ù…Ø³Ø§ÙˆÛŒ Ø´Ø¯ØŒ Ù‚Ø±Ø¹Ù‡ Ø¨Ø²Ù†ÛŒØ¯.",
            "tool.flow.elim.votes": "Ø±Ø£ÛŒ Ø®Ø±ÙˆØ¬",
            "tool.flow.elim.apply": "Ø«Ø¨Øª Ù†ØªÛŒØ¬Ù‡",
            "tool.flow.elim.clear": "Ù¾Ø§Ú© Ú©Ø±Ø¯Ù†",
            "tool.flow.elim.noCandidates": "Ú©Ø³ÛŒ Ø¯Ø± Ù„ÛŒØ³Øª Ø¯ÙØ§Ø¹ÛŒÙ‡ Ù†ÛŒØ³Øª.",
            "tool.flow.elim.result": "Ù†ØªÛŒØ¬Ù‡",
            "tool.flow.elim.out": "Ø®Ø±ÙˆØ¬",
            "tool.flow.elim.draw": "Ù‚Ø±Ø¹Ù‡ Ø¨ÛŒÙ† Ù…Ø³Ø§ÙˆÛŒâ€ŒÙ‡Ø§",
            "tool.flow.elim.tie": "Ù…Ø³Ø§ÙˆÛŒ",
            "tool.flow.elim.notChosenYet": "Ù‡Ù†ÙˆØ² Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡",
            "tool.flow.elim.single.need": "Ø­Ø¯Ù†ØµØ§Ø¨ Ø®Ø±ÙˆØ¬: {n} Ø±Ø£ÛŒ (Ø¨ÛŒØ´ Ø§Ø² Ù†ØµÙÙ {v} Ø±Ø£ÛŒâ€ŒØ¯Ù‡Ù†Ø¯Ù‡)",
            "tool.flow.elim.single.notEnough": "Ø±Ø£ÛŒ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª: {c} Ø§Ø² {n}",
            "tool.flow.day.outcome": "Ù†ØªÛŒØ¬Ù‡ Ø±ÙˆØ²",
            "tool.flow.outcome.none": "Ø§Ù…Ø±ÙˆØ² Ú©Ø³ÛŒ Ø¨Ø§ Ø±Ø£ÛŒ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù†Ø´Ø¯.",
            "tool.flow.outcome.votedOut": "Ø¨Ø§ Ø±Ø£ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯:",
            "tool.flow.outcome.lastMove": "Ú©Ø§Ø±Øª Ø­Ø±Ú©Øª Ø¢Ø®Ø± (ÙÙ‚Ø· ÙˆÙ‚ØªÛŒ Ø¨Ø§ Ø±Ø£ÛŒ Ø®Ø§Ø±Ø¬ Ø´ÙˆØ¯)",
            "tool.flow.endCards.title": "Ú©Ø§Ø±Øª Ù¾Ø§ÛŒØ§Ù†",
            "tool.flow.endCards.for": "Ú©Ø§Ø±Øª Ù¾Ø§ÛŒØ§Ù† Ø¨Ø±Ø§ÛŒ {name}: {card}",
            "tool.flow.day.defense": "Ø¯ÙØ§Ø¹ÛŒÙ‡",
            "tool.flow.day.eliminate": "Ø®Ø±ÙˆØ¬/Ù†ØªÛŒØ¬Ù‡",
            "tool.flow.day.toNight": "Ø±ÙØªÙ† Ø¨Ù‡ Ø´Ø¨",
            "tool.flow.midday.sleepVote": "Ø±Ø£ÛŒÙ Ú†Ø´Ù…â€ŒØ¨Ø³ØªÙ‡",
            "tool.flow.midday.resolve": "Ù†ØªÛŒØ¬Ù‡ Ø®ÙˆØ§Ø¨ Ù†ÛŒÙ…â€ŒØ±ÙˆØ²",
            "tool.flow.night.wake": "ØªØ±ØªÛŒØ¨ Ø¨ÛŒØ¯Ø§Ø±ÛŒ",
            "tool.flow.night.actions": "Ø«Ø¨Øª Ø§Ú©Ø´Ù†â€ŒÙ‡Ø§ÛŒ Ø´Ø¨",
            "tool.flow.night.run": "ØªØ±ØªÛŒØ¨ Ø¨ÛŒØ¯Ø§Ø±ÛŒ Ùˆ Ø§Ú©Ø´Ù†â€ŒÙ‡Ø§ÛŒ Ø´Ø¨",
            "tool.flow.night.resolve": "Ø¬Ù…Ø¹â€ŒØ¨Ù†Ø¯ÛŒ Ø´Ø¨ Ùˆ Ø±ÙØªÙ† Ø¨Ù‡ Ø±ÙˆØ²",
            "tool.flow.action.mafiaShot": "Ø´Ù„ÛŒÚ© Ù…Ø§ÙÛŒØ§ Ø¨Ù‡",
            "tool.flow.action.doctorSave": "Ø³ÛŒÙˆ Ù¾Ø²Ø´Ú© Ø±ÙˆÛŒ",
            "tool.flow.action.detectiveQuery": "Ø§Ø³ØªØ¹Ù„Ø§Ù… Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø§Ø²",
            "tool.flow.action.professionalShot": "Ø´Ù„ÛŒÚ© Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ø¨Ù‡",
            "tool.flow.action.bomber": "Ø¨Ù…Ø¨â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø±ÙˆÛŒ",
            "tool.flow.action.bombCode": "Ú©Ø¯/Ø±Ù…Ø²",
            "tool.flow.action.magicianDisable": "ØºÛŒØ±ÙØ¹Ø§Ù„â€ŒÚ©Ø±Ø¯Ù†Ù Ø´Ø¹Ø¨Ø¯Ù‡â€ŒØ¨Ø§Ø²",
            "tool.flow.action.zodiacShot": "Ø´Ù„ÛŒÚ© Ø²ÙˆØ¯ÛŒØ§Ú© Ø¨Ù‡",
            "tool.flow.action.oceanWake": "Ø§ÙˆØ´Ù† Ø¨ÛŒØ¯Ø§Ø± Ú©Ø±Ø¯",
            "tool.flow.action.kaneMark": "Ù‡Ù…Ø´Ù‡Ø±ÛŒ Ú©ÛŒÙ† Ù†Ø´Ø§Ù† Ú©Ø±Ø¯",
            "tool.flow.action.constantineRevive": "Ú©Ù†Ø³ØªØ§Ù†ØªÛŒÙ† Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯",
            "tool.flow.action.nostPick3": "Ù†ÙˆØ³ØªØ±Ø§Ø¯Ø§Ù…ÙˆØ³ Û³ Ù†ÙØ± Ø±Ø§ Ù†Ø´Ø§Ù† Ø¯Ø§Ø¯",
            "tool.flow.action.heirPick": "ÙˆØ§Ø±Ø« Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯",
            "tool.flow.action.herbalistPoison": "Ø¹Ø·Ø§Ø± Ø²Ù‡Ø± Ø¯Ø§Ø¯ Ø¨Ù‡",
            "tool.flow.action.herbalistAntidote": "Ø¹Ø·Ø§Ø± Ù¾Ø§Ø¯Ø²Ù‡Ø± Ø¯Ø§Ø¯ Ø¨Ù‡",
            "tool.flow.action.armorsmithArmor": "Ø²Ø±Ù‡â€ŒØ³Ø§Ø² Ø²Ø±Ù‡ Ø¯Ø§Ø¯ Ø¨Ù‡",
            "tool.flow.action.heirIntroOnly": "ÙÙ‚Ø· Ø´Ø¨ Ù…Ø¹Ø§Ø±ÙÙ‡",
            "tool.flow.action.armorsmith.selfOnce": "Ø²Ø±Ù‡â€ŒØ³Ø§Ø² Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÙÙ‚Ø· Û± Ø¨Ø§Ø± Ø¯Ø± Ú©Ù„ Ø¨Ø§Ø²ÛŒ Ø¨Ù‡ Ø®ÙˆØ¯Ø´ Ø²Ø±Ù‡ Ø¨Ø¯Ù‡Ø¯.",
            "tool.flow.ocean.result.good": "Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø¨ÙˆØ¯ â†’ Û²Û° Ø«Ø§Ù†ÛŒÙ‡ ÙØ±ØµØª Ú¯ÙØªâ€ŒÙˆÚ¯Ùˆ.",
            "tool.flow.ocean.result.bad": "Ù…Ø§ÙÛŒØ§/Ø²ÙˆØ¯ÛŒØ§Ú© Ø¨ÙˆØ¯ â†’ Ø§ÙˆØ´Ù† Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯.",
            "tool.flow.action.apply": "Ø«Ø¨Øª Ø§Ú©Ø´Ù†â€ŒÙ‡Ø§",
            "tool.flow.bomb.active": "Ø¨Ù…Ø¨ ÙØ¹Ø§Ù„ Ø§Ø³Øª (Ø®ÙˆØ§Ø¨ Ù†ÛŒÙ…â€ŒØ±ÙˆØ²)",
            "tool.flow.bomb.inactive": "Ø¨Ù…Ø¨ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª",

            "tool.lastMove.title": "Ú©Ø§Ø±Øª Ø­Ø±Ú©Øª Ø¢Ø®Ø±",
            "tool.lastMove.none": "Ø§ÛŒÙ† Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ø§Ø±Øª Ø­Ø±Ú©Øª Ø¢Ø®Ø± Ù†Ø¯Ø§Ø±Ø¯!",
            "tool.lastMove.header": "Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø­Ø±Ú©Øª Ø¢Ø®Ø±:",
            "tool.lastMove.draw": "Ù‚Ø±Ø¹Ù‡ Ú©Ø§Ø±Øª",
            "tool.lastMove.result": "Ù†ØªÛŒØ¬Ù‡:",
            "tool.lastMove.allUsed": "Ù‡Ù…Ù‡Ù” Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯.",

            "tool.roleChange.title": "ØªØºÛŒÛŒØ± Ù†Ù‚Ø´",
            "tool.roleChange.needDeal": "Ø§Ø¨ØªØ¯Ø§ Ù†Ù‚Ø´â€ŒÙ‡Ø§ Ø±Ø§ ØªÙ‚Ø³ÛŒÙ… Ú©Ù†ÛŒØ¯.",
            "tool.roleChange.pick": "ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù† ØªØ§ Ù†Ù‚Ø´ÙØ´ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¨Ø¯Ù‡ÛŒ",
            "tool.roleChange.labelPlayer": "Ù†Ù‚Ø´ Ø§ÛŒØ´ÙˆÙ† Ø±Ùˆ",
            "tool.roleChange.labelRole": "ØªØºÛŒÛŒØ± Ø¨Ø¯Ù‡ Ø¨Ù‡",
            "tool.roleChange.apply": "Ø§Ø¹Ù…Ø§Ù„ ØªØºÛŒÛŒØ± Ù†Ù‚Ø´",
            "tool.roleChange.shuffleAll": "Ø¨Ø± Ø²Ø¯Ù† Ù†Ù‚Ø´â€ŒÙ‡Ø§ (Ù‡Ù…Ù‡)",
            "tool.roleChange.shuffleConfirm": "ØªØ£ÛŒÛŒØ¯ Ø¨Ø± Ø²Ø¯Ù† Ù†Ù‚Ø´â€ŒÙ‡Ø§",
            "tool.roleChange.shuffleWarn": "Ù‡Ø´Ø¯Ø§Ø±: Ø§ÛŒÙ† Ú©Ø§Ø± Ù†Ù‚Ø´â€ŒÙ‡Ø§ÛŒ Ù‡Ù…Ù‡Ù” Ø¨Ø§Ø²ÛŒÚ©Ù†â€ŒÙ‡Ø§ Ø±Ø§ Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ù‚Ø§Ø¨Ù„ Ø¨Ø±Ú¯Ø´Øª Ù†ÛŒØ³Øª.",

            "tool.chance.title": "Ù‚Ø±Ø¹Ù‡",
            "tool.chance.ask": "Ú†Ù†Ø¯ Ù†ÙØ± ÙˆØ§Ø±Ø¯ Ù‚Ø±Ø¹Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ØŸ",
            "tool.chance.count": "ØªØ¹Ø¯Ø§Ø¯",
            "tool.chance.spin": "Ù‚Ø±Ø¹Ù‡",
            "tool.chance.result": "Ù†ØªÛŒØ¬Ù‡:",

            "tool.timer.pick.title": "ØªÙ†Ø¸ÛŒÙ… ØªØ§ÛŒÙ…Ø±",
            "tool.timer.pick.ask": "Ù…Ø¯Øª Ø²Ù…Ø§Ù† Â«{label}Â» Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯",
            "tool.timer.pick.seconds": "Ø²Ù…Ø§Ù† (Ø«Ø§Ù†ÛŒÙ‡)",
            "tool.timer.pick.apply": "Ø«Ø¨Øª",
            "tool.timer.pick.back": "Ø¨Ø§Ø²Ú¯Ø´Øª",
            "tool.timer.title": "ØªØ§ÛŒÙ…Ø±",
            "tool.timer.turn": "ØªØ±Ù†",
            "tool.timer.challenge": "Ú†Ø§Ù„Ø´",
            "tool.timer.defense": "Ø¯ÙØ§Ø¹ÛŒÙ‡",
            "tool.timer.reset": "Ø±ÛŒØ³Øª",
            "tool.timer.close": "Ø¨Ø³ØªÙ†",

            "lifeSheet.title": "ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒÚ©Ù†",
            "lifeSheet.role": "Ù†Ù‚Ø´",
            "lifeSheet.team": "ØªÛŒÙ…",
            "lifeSheet.status": "ÙˆØ¶Ø¹ÛŒØª",
            "lifeSheet.alive": "Ø²Ù†Ø¯Ù‡",
            "lifeSheet.dead": "Ù…Ø±Ø¯Ù‡",
            "lifeSheet.deadShot": "Ú©Ø´ØªÙ‡ Ø´Ø¯ (Ø´Ø§Øª)",
            "lifeSheet.deadVote": "Ø®Ø§Ø±Ø¬ Ø´Ø¯ (Ø±Ø§ÛŒ)",
            "lifeSheet.deadShortShot": "Ù…Ø±Ø¯Ù‡",
            "lifeSheet.deadShortVote": "Ù…Ø±Ø¯Ù‡",
            "lifeSheet.actionShot": "Ú©Ø´ØªÙ‡ Ø´Ø¯",
            "lifeSheet.actionVote": "Ú©Ø´ØªÙ‡ Ø´Ø¯",
            "lifeSheet.actionRevive": "Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ (Ø²Ù†Ø¯Ù‡)",

            "cast.noneMafia": "Ø¨Ø¯ÙˆÙ† Ù…Ø§ÙÛŒØ§",
            "cast.noneCity": "Ø¨Ø¯ÙˆÙ† Ø´Ù‡Ø±",
            "cast.stat.withInd": "Ø¨Ø§Ø²ÛŒÚ©Ù†: {p} â€¢ Ù…Ø§ÙÛŒØ§: {m} â€¢ Ø´Ù‡Ø±: {c} â€¢ Ù…Ø³ØªÙ‚Ù„: {i}",
            "cast.stat.noInd": "Ø¨Ø§Ø²ÛŒÚ©Ù†: {p} â€¢ Ù…Ø§ÙÛŒØ§: {m} â€¢ Ø´Ù‡Ø±: {c}",
          },
          en: {
            "doc.title": "Mafia Game Assistant",
            "app.title": "Mafia Game Assistant",
            "top.help": "Help",
            "top.lang.aria": "Change language",
            "top.lang.toFa": "ÙØ§Ø±Ø³ÛŒ",
            "top.lang.toEn": "English",

            "setup.title": "Game setup",
            "setup.backToSetup": "Back to setup",
            "setup.scenario": "Scenario",
            "setup.playersCount": "Players",
            "setup.mafiaCount": "Mafia",
            "setup.defaults": "Scenario defaults",
            "setup.start": "Start game",
            "setup.savedGame": "A saved game is available.",
            "setup.resume": "Resume",
            "setup.delete": "Delete",

            "players.title": "Players",
            "players.namesModeAria": "Names mode",
            "players.namesDefault": "Default names",
            "players.namesLast": "Last game names",
            "players.note": "Enter player names. If you choose â€œLast game namesâ€, the app will use your browserâ€™s saved list.",
            "players.deal": "Deal roles",
            "players.back": "Back to setup",

            "cards.title": "Deal",
            "cards.hint": "Each player picks a card and sees their role.",
            "cards.back": "Back",
            "cards.autoAssign": "Auto-assign roles",
            "cards.next": "Next step",

            "cast.title": "Cast list",
            "cast.back": "Back to setup",
            "cast.new": "New draw",

            "tools.wake": "Wake",
            "tools.status": "Status",
            "tools.lastMove": "Last move",
            "tools.roleChange": "Change role",
            "tools.chance": "Draw",
            "tools.timer": "Timer",
            "tools.flow": "Flow",

            "common.close": "Close",
            "common.seen": "Seen",
            "common.roleHelp": "Role help",
            "common.on": "On",
            "common.off": "Off",
            "common.done": "Done",
            "common.turn": "Turn",
            "common.playerN": "Player {n}",
            "common.cardN": "Card {n}",
            "common.taken": "Taken",

            "saveState.label": "Save: {state}",
            "error.config": "Invalid game setup.",
            "error.quick": "Setup error",
            "error.duplicateName": "Name â€œ{name}â€ is duplicated.",

            "teams.mafia": "Mafia",
            "teams.city": "City",
            "teams.independent": "Independent",
            "teams.mafiaTeam": "Mafia team",
            "teams.cityTeam": "City team",

            "toggles.variableCount": "Count: variable",

            "quickStat.withInd": "Mafia: {m} â€¢ City: {c} â€¢ Ind: {i}",
            "quickStat.noInd": "Mafia: {m} â€¢ City: {c}",

            "help.title": "Help",
            "help.quick": "Quick guide",
            "help.body": `1) Choose scenario, number of players, and mafia count.<br />
2) Enable/disable roles (based on scenario).<br />
3) Tap â€œStart gameâ€ and enter player names.<br />
4) Tap â€œDeal rolesâ€: each player picks a card and taps â€œSeenâ€.<br />
5) In â€œCast listâ€, the narrator can use tools (Timer/Draw/Role change/Status).`,

            "tool.wake.title": "Wake order",
            "tool.wake.scenario": "Scenario: {name}",
            "tool.wake.none": "No wake order recorded for this scenario.",

            "tool.status.title": "Status check",
            "tool.status.alive": "Alive",
            "tool.status.dead": "Dead",
            "tool.status.mafiaAlive": "Mafia alive",
            "tool.status.mafiaDead": "Mafia dead",
            "tool.status.cityAlive": "City alive",
            "tool.status.cityDead": "City dead",
            "tool.status.indAlive": "Ind alive",
            "tool.status.indDead": "Ind dead",
            "tool.status.hint": "To change a playerâ€™s status, go to â€œCast listâ€, tap the player, then choose â€œKilledâ€.",
            "tool.status.summary": "From your game {out} people are out. {m} Mafia, {c} Citizen and {i} independent.",

            "tool.flow.title": "Game Flow Runner",
            "tool.flow.needDeal": "Deal roles first.",
            "tool.flow.phase.day": "Day {n}",
            "tool.flow.phase.midday": "Mid-day sleep (Day {n})",
            "tool.flow.phase.night": "Night {n}",
            "tool.flow.step": "Step {i} of {n}",
            "tool.flow.next": "Next",
            "tool.flow.prev": "Back",
            "tool.flow.reset": "Reset flow",
            "tool.flow.timeline": "Timeline",
            "tool.flow.log": "Events",
            "tool.flow.addNote": "Add note",
            "tool.flow.notePlayer": "Player",
            "tool.flow.notePlaceholder": "What happened?",
            "tool.flow.saveNote": "Save",
            "tool.flow.day.talk": "Talk turns",
            "tool.flow.day.guns": "Gun use",
            "tool.flow.guns.title": "Guns manager",
            "tool.flow.guns.hasGun": "Players with guns",
            "tool.flow.guns.add": "Give a gun",
            "tool.flow.guns.giveTo": "Give to",
            "tool.flow.guns.type": "Gun type",
            "tool.flow.guns.type.real": "Real",
            "tool.flow.guns.type.fake": "Fake",
            "tool.flow.guns.selfFakeOnly": "Gunslinger can give a gun to anyone, but can only give themselves a fake gun.",
            "tool.flow.guns.nightQuota": "Tonight quota: {n}/2 guns â€¢ real: {r}/1",
            "tool.flow.guns.limit2": "At most 2 guns per night.",
            "tool.flow.guns.limit1Real": "At most 1 real gun per night.",
            "tool.flow.guns.gunslingerIs": "Gunslinger: {name}",
            "tool.flow.guns.give": "Add gun",
            "tool.flow.guns.remove": "Remove gun",
            "tool.flow.guns.shooter": "Shooter",
            "tool.flow.guns.target": "Target",
            "tool.flow.guns.fire": "Record shot",
            "tool.flow.guns.noEffect": "Fake gun (no effect).",
            "tool.flow.guns.killedTarget": "Real gun (target is out).",
            "tool.flow.ocean.team": "Ocean team (tonight)",
            "tool.flow.ocean.add": "Add to Ocean team",
            "tool.flow.ocean.pick": "Pick player",
            "tool.flow.ocean.remove": "Remove from team",
            "tool.flow.day.vote": "Voting",
            "tool.flow.vote.hint": "Enter how many votes each alive player received.",
            "tool.flow.vote.votes": "Votes",
            "tool.flow.vote.apply": "Save votes",
            "tool.flow.vote.clear": "Clear",
            "tool.flow.vote.total": "Total votes: {n}",
            "tool.flow.vote.leaders": "Top votes",
            "tool.flow.defense.hint": "Based on recorded votes, players who reached majority should defend.",
            "tool.flow.defense.threshold": "Majority threshold: {n} (more than half of {v} voters)",
            "tool.flow.defense.none": "No one reached the threshold.",
            "tool.flow.defense.needVotes": "Record the Voting step first.",
            "tool.flow.defense.list": "Defense list",
            "tool.flow.elim.hint": "After defense, enter elimination votes for suspects. Highest votes = out. If tied, use Draw.",
            "tool.flow.elim.votes": "Elim votes",
            "tool.flow.elim.apply": "Save result",
            "tool.flow.elim.clear": "Clear",
            "tool.flow.elim.noCandidates": "No one is in the defense list.",
            "tool.flow.elim.result": "Result",
            "tool.flow.elim.out": "Out",
            "tool.flow.elim.draw": "Draw among ties",
            "tool.flow.elim.tie": "Tie",
            "tool.flow.elim.notChosenYet": "Not chosen yet",
            "tool.flow.elim.single.need": "Vote-out threshold: {n} votes (more than half of {v} voters)",
            "tool.flow.elim.single.notEnough": "Not enough votes: {c} of {n}",
            "tool.flow.day.outcome": "Day outcome",
            "tool.flow.outcome.none": "No one was voted out today.",
            "tool.flow.outcome.votedOut": "Voted out:",
            "tool.flow.outcome.lastMove": "Last move card (vote-out only)",
            "tool.flow.endCards.title": "End card",
            "tool.flow.endCards.for": "End card for {name}: {card}",
            "tool.flow.day.defense": "Defense",
            "tool.flow.day.eliminate": "Elimination",
            "tool.flow.day.toNight": "Go to night",
            "tool.flow.midday.sleepVote": "Eyes-closed vote",
            "tool.flow.midday.resolve": "Resolve mid-day",
            "tool.flow.night.wake": "Wake order",
            "tool.flow.night.actions": "Record night actions",
            "tool.flow.night.run": "Night order & actions",
            "tool.flow.night.resolve": "Wrap up night â†’ Day",
            "tool.flow.action.mafiaShot": "Mafia shot",
            "tool.flow.action.doctorSave": "Doctor saved",
            "tool.flow.action.detectiveQuery": "Detective checks",
            "tool.flow.action.professionalShot": "Professional shot",
            "tool.flow.action.bomber": "Bomber placed bomb on",
            "tool.flow.action.bombCode": "Code",
            "tool.flow.action.magicianDisable": "Magician disabled",
            "tool.flow.action.zodiacShot": "Zodiac shot",
            "tool.flow.action.oceanWake": "Ocean woke",
            "tool.flow.action.kaneMark": "Citizen Kane marked",
            "tool.flow.action.constantineRevive": "Constantine revived",
            "tool.flow.action.nostPick3": "Nostradamus picked 3",
            "tool.flow.action.heirPick": "Heir picked",
            "tool.flow.action.herbalistPoison": "Herbalist poisoned",
            "tool.flow.action.herbalistAntidote": "Herbalist antidote",
            "tool.flow.action.armorsmithArmor": "Armorsmith armored",
            "tool.flow.action.heirIntroOnly": "Intro night only",
            "tool.flow.action.armorsmith.selfOnce": "Armorsmith can armor themselves only once per game.",
            "tool.flow.ocean.result.good": "Citizen â†’ 20 seconds chat.",
            "tool.flow.ocean.result.bad": "Mafia/Zodiac â†’ Ocean is out.",
            "tool.flow.action.apply": "Record actions",
            "tool.flow.bomb.active": "Bomb is active (mid-day sleep)",
            "tool.flow.bomb.inactive": "No active bomb",

            "tool.lastMove.title": "Last move card",
            "tool.lastMove.none": "This scenario has no Last Move card.",
            "tool.lastMove.header": "Last move cards:",
            "tool.lastMove.draw": "Draw card",
            "tool.lastMove.result": "Result:",
            "tool.lastMove.allUsed": "All cards have been used.",

            "tool.roleChange.title": "Change role",
            "tool.roleChange.needDeal": "Deal roles first.",
            "tool.roleChange.pick": "Choose a player to change their role",
            "tool.roleChange.labelPlayer": "Change role of",
            "tool.roleChange.labelRole": "Change to",
            "tool.roleChange.apply": "Apply",
            "tool.roleChange.shuffleAll": "Shuffle all roles",
            "tool.roleChange.shuffleConfirm": "Confirm shuffle",
            "tool.roleChange.shuffleWarn": "Warning: this shuffles everyoneâ€™s roles and cannot be undone.",

            "tool.chance.title": "Draw",
            "tool.chance.ask": "How many players are in the draw?",
            "tool.chance.count": "Count",
            "tool.chance.spin": "Draw",
            "tool.chance.result": "Result:",

            "tool.timer.pick.title": "Set timer",
            "tool.timer.pick.ask": "Select duration for â€œ{label}â€",
            "tool.timer.pick.seconds": "Time (seconds)",
            "tool.timer.pick.apply": "Save",
            "tool.timer.pick.back": "Back",
            "tool.timer.title": "Timer",
            "tool.timer.turn": "Turn",
            "tool.timer.challenge": "Challenge",
            "tool.timer.defense": "Defense",
            "tool.timer.reset": "Reset",
            "tool.timer.close": "Close",

            "lifeSheet.title": "Player status",
            "lifeSheet.role": "Role",
            "lifeSheet.team": "Team",
            "lifeSheet.status": "Status",
            "lifeSheet.alive": "Alive",
            "lifeSheet.dead": "Dead",
            "lifeSheet.deadShot": "Killed (shot)",
            "lifeSheet.deadVote": "Out (vote)",
            "lifeSheet.deadShortShot": "Dead",
            "lifeSheet.deadShortVote": "Dead",
            "lifeSheet.actionShot": "Killed",
            "lifeSheet.actionVote": "Killed",
            "lifeSheet.actionRevive": "Revive (alive)",

            "cast.noneMafia": "No mafia",
            "cast.noneCity": "No city",
            "cast.stat.withInd": "Players: {p} â€¢ Mafia: {m} â€¢ City: {c} â€¢ Ind: {i}",
            "cast.stat.noInd": "Players: {p} â€¢ Mafia: {m} â€¢ City: {c}",
          },
        };

        function t(key, vars) {
          const dict = STR[appLang] || STR.fa;
          let s = (dict && dict[key]) || (STR.fa && STR.fa[key]) || key;
          if (vars && typeof vars === "object") {
            for (const k of Object.keys(vars)) {
              s = s.replaceAll("{" + k + "}", String(vars[k]));
            }
          }
          return s;
        }
        function applyStaticI18n() {
          try { document.title = t("doc.title"); } catch {}
          document.querySelectorAll("[data-i18n]").forEach((el) => {
            const key = el.getAttribute("data-i18n");
            if (!key) return;
            el.textContent = t(key);
          });
          document.querySelectorAll("[data-i18n-title]").forEach((el) => {
            const key = el.getAttribute("data-i18n-title");
            if (!key) return;
            el.setAttribute("title", t(key));
          });
          document.querySelectorAll("[data-i18n-aria-label]").forEach((el) => {
            const key = el.getAttribute("data-i18n-aria-label");
            if (!key) return;
            el.setAttribute("aria-label", t(key));
          });
        }
        function applyScenarioOptionLabels() {
          const map = {
            classic: { fa: "Ú©Ù„Ø§Ø³ÛŒÚ©", en: "Classic" },
            bazras: { fa: "Ø¨Ø§Ø²Ù¾Ø±Ø³", en: "Inspector" },
            namayande: { fa: "Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡", en: "Representative" },
            mozaker: { fa: "Ù…Ø°Ø§Ú©Ø±Ù‡", en: "Negotiator" },
            takavar: { fa: "ØªÚ©Ø§ÙˆØ±", en: "Commando" },
            kabo: { fa: "Ú©Ø§Ù¾Ùˆ", en: "Capo" },
            pedarkhande: { fa: "Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡", en: "Godfather" },
            zodiac: { fa: "Ø²ÙˆØ¯ÛŒØ§Ú©", en: "Zodiac" },
            meeting_epic: { fa: "Ù…ÛŒØªÛŒÙ†Ú¯/Ø§Ù¾ÛŒÚ©", en: "Meeting/Epic" },
            pishrafte: { fa: "Ù¾ÛŒØ´Ø±ÙØªÙ‡", en: "Advanced" },
            shab_mafia: { fa: "Ø´Ø¨ Ù…Ø§ÙÛŒØ§", en: "Mafia Nights" },
          };
          const sel = $("scenario");
          if (!sel || !sel.options) return;
          for (const opt of Array.from(sel.options)) {
            const v = opt.value;
            const rec = map[v];
            if (!rec) continue;
            opt.textContent = appLang === "fa" ? rec.fa : rec.en;
          }
        }
        function updateLangChip() {
          const chip = $("langChip");
          const label = $("langLabel");
          if (chip) chip.setAttribute("aria-label", t("top.lang.aria"));
          if (label) label.textContent = (appLang === "fa") ? t("top.lang.toEn") : t("top.lang.toFa");
        }
        function setLanguage(lang) {
          appLang = (lang === "en") ? "en" : "fa";
          try { if (shouldPersist()) localStorage.setItem(LANG_KEY, appLang); } catch {}
          try {
            const root = document.documentElement;
            root.setAttribute("lang", appLang === "fa" ? "fa" : "en");
            root.setAttribute("dir", appLang === "fa" ? "rtl" : "ltr");
          } catch {}
          applyScenarioOptionLabels();
          applyStaticI18n();
          updateLangChip();
          try { if (typeof renderToggles === "function") renderToggles(); } catch {}
          try { if (typeof applyUIFromState === "function") applyUIFromState(); } catch {}
          try { if (typeof updateQuickStat === "function") updateQuickStat(); } catch {}
          try { if (typeof renderCards === "function" && $("cardsCard") && !$("cardsCard").classList.contains("hidden")) renderCards(); } catch {}
          try { if (typeof renderCast === "function" && $("castCard") && !$("castCard").classList.contains("hidden")) renderCast(); } catch {}
          try { if (typeof renderNameGrid === "function" && $("playersCard") && !$("playersCard").classList.contains("hidden")) renderNameGrid(); } catch {}
          try { if (typeof closeToolModal === "function") closeToolModal(); } catch {}
          try { if (typeof closeModal === "function") closeModal(); } catch {}
        }
        function toggleLanguage() {
          setLanguage(appLang === "fa" ? "en" : "fa");
        }

        const roles = {
          // --- base ---
          citizen: { faName: "Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø³Ø§Ø¯Ù‡", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø¨Ø¯ÙˆÙ† Ù‚Ø§Ø¨Ù„ÛŒØª", descFa: "Ù‚Ø§Ø¨Ù„ÛŒØª Ø´Ø¨ Ù†Ø¯Ø§Ø±ÛŒØ¯. Ø±ÙˆØ²Ù‡Ø§ Ø¨Ø§ ØµØ­Ø¨ØªØŒ Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ùˆ Ø±Ø£ÛŒ Ø¯Ø±Ø³Øª Ø¨Ù‡ Ù¾ÛŒØ¯Ø§ Ø´Ø¯Ù† Ù…Ø§ÙÛŒØ§ Ú©Ù…Ú© Ú©Ù†ÛŒØ¯." },
          mafia: { faName: "Ù…Ø§ÙÛŒØ§ Ø³Ø§Ø¯Ù‡", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø¨Ø¯ÙˆÙ† Ù‚Ø§Ø¨Ù„ÛŒØª", descFa: "Ù‚Ø§Ø¨Ù„ÛŒØª Ù…Ø³ØªÙ‚Ù„ Ù†Ø¯Ø§Ø±ÛŒØ¯. Ø´Ø¨â€ŒÙ‡Ø§ Ø¨Ø§ Ù…Ø§ÙÛŒØ§ Ù…Ø´ÙˆØ±Øª Ù…ÛŒâ€ŒÚ©Ù†ÛŒØ¯ Ùˆ Ø±ÙˆØ²Ù‡Ø§ ØªÙ„Ø§Ø´ Ù…ÛŒâ€ŒÚ©Ù†ÛŒØ¯ Ø´Ù‡Ø± Ø±Ø§ Ú¯Ù…Ø±Ø§Ù‡ Ú©Ù†ÛŒØ¯." },

          // --- classic / general ---
          mafiaBoss: { faName: "Ø±Ø¦ÛŒØ³ Ù…Ø§ÙÛŒØ§", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø±Ù‡Ø¨Ø± + Ø´Ù„ÛŒÚ©", descFa: "Ø±Ù‡Ø¨Ø± ØªÛŒÙ… Ù…Ø§ÙÛŒØ§Ø³ØªØ› ØªØµÙ…ÛŒÙ… Ù†Ù‡Ø§ÛŒÛŒÙ Ø´Ù„ÛŒÚ© Ø´Ø¨ Ø¨Ø§ Ø§ÙˆØ³Øª Ùˆ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ùˆ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Â«Ù…Ù†ÙÛŒÂ» Ø§Ø³Øª." },
          godfather: { faName: "Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø±Ù‡Ø¨Ø± + Ø´Ù„ÛŒÚ©", descFa: "Ø¯Ø± Ø¨Ø³ÛŒØ§Ø±ÛŒ Ø§Ø² Ø³Ù†Ø§Ø±ÛŒÙˆÙ‡Ø§ Ù‡Ù…Ø§Ù† Ø±Ù‡Ø¨Ø± Ù…Ø§ÙÛŒØ§Ø³Øª Ùˆ Ø´Ù„ÛŒÚ© Ø´Ø¨ Ø±Ø§ ØªØ¹ÛŒÛŒÙ† Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ø¯Ø± Ù†Ø³Ø®Ù‡Ù” Ø±Ø§ÛŒØ¬ØŒ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ùˆ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Â«Ù…Ù†ÙÛŒÂ» Ø§Ø³Øª." },
          swindler: { faName: "Ø´ÛŒØ§Ø¯", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø¨Ø±Ù‡Ù…â€ŒØ²Ù†Ù Ø§Ø³ØªØ¹Ù„Ø§Ù…", descFa: "Ù†Ù‚Ø´ Ù…Ø§ÙÛŒØ§ÛŒÛŒÙ Ø¨Ø±Ù‡Ù…â€ŒØ²Ù† Ø§Ø³ØªØ¹Ù„Ø§Ù… (Ø¯Ø± Ø¨Ø¹Ø¶ÛŒ Ø³Ù†Ø§Ø±ÛŒÙˆÙ‡Ø§). Ù‡Ø± Ø´Ø¨ Ø±ÙˆÛŒ ÛŒÚ© Ù†ÙØ± Ø§Ø«Ø± Ù…ÛŒâ€ŒÚ¯Ø°Ø§Ø±Ø¯Ø› ØªÙˆØ¶ÛŒØ­ Ø¯Ù‚ÛŒÙ‚ Ø¨Ù‡ Ø³Ù†Ø§Ø±ÛŒÙˆ Ø¨Ø³ØªÚ¯ÛŒ Ø¯Ø§Ø±Ø¯." },
          nato: { faName: "Ù†Ø§ØªÙˆ", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø­Ø¯Ø³Ù Ù†Ù‚Ø´", descFa: "ÛŒÚ© Ø´Ø¨ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ) Ù†Ù‚Ø´ Ø¯Ù‚ÛŒÙ‚Ù ÛŒÚ© Ø¨Ø§Ø²ÛŒÚ©Ù† Ø±Ø§ Ø­Ø¯Ø³ Ù…ÛŒâ€ŒØ²Ù†Ø¯Ø› Ø¯Ø± ØµÙˆØ±Øª Ø­Ø¯Ø³ Ø¯Ø±Ø³ØªØŒ Ø¢Ù† Ø¨Ø§Ø²ÛŒÚ©Ù† Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯." },
          negotiator: { faName: "Ù…Ø°Ø§Ú©Ø±Ù‡â€ŒÚ©Ù†Ù†Ø¯Ù‡", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ù…Ø°Ø§Ú©Ø±Ù‡/ØªØ¨Ø¯ÛŒÙ„", descFa: "Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ) Ø¯Ø± Ø´Ø¨ Ù…Ø°Ø§Ú©Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†Ø¯ ÛŒÚ© Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø±Ø§ Ø¨Ù‡ ØªÛŒÙ… Ù…Ø§ÙÛŒØ§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†Ø¯Ø› Ø¯Ø± Ø´Ø¨ Ù…Ø°Ø§Ú©Ø±Ù‡ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø´Ù„ÛŒÚ© Ø§Ù†Ø¬Ø§Ù… Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯." },
          natasha: { faName: "Ù†Ø§ØªØ§Ø´Ø§", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø³Ø§ÛŒÙ„Ù†ØªÙ Ø´Ø¨", descFa: "Ù†Ù‚Ø´ Ù…Ø§ÙÛŒØ§ÛŒÛŒÙ Ø³Ø§ÛŒÙ„Ù†Øªâ€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø§Ø³Øª: Ø´Ø¨â€ŒÙ‡Ø§ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ ØªØ§ Ø±ÙˆØ² Ø¨Ø¹Ø¯ Ù†ØªÙˆØ§Ù†Ø¯ ØµØ­Ø¨Øª Ú©Ù†Ø¯ (Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ ØªÚ©Ø±Ø§Ø±ÛŒ Ù¾Ø´Øªâ€ŒØ³Ø±Ù‡Ù… Ù†ÛŒØ³Øª)." },
          doctorLecter: { faName: "Ø¯Ú©ØªØ± Ù„Ú©ØªØ±", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø³ÛŒÙˆÙ Ù…Ø§ÙÛŒØ§", descFa: "Ù¾Ø²Ø´Ú©Ù ØªÛŒÙ… Ù…Ø§ÙÛŒØ§Ø³Øª. Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ù‡Ø± Ø´Ø¨ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø§Ø² Ø´Ù„ÛŒÚ© Ù†Ø¬Ø§Øª Ø¯Ù‡Ø¯ Ùˆ ÙÙ‚Ø· ÛŒÚ©â€ŒØ¨Ø§Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®ÙˆØ¯Ø´ Ø±Ø§ Ù†Ø¬Ø§Øª Ø¯Ù‡Ø¯." },
          jokerMafia: { faName: "Ø¬ÙˆÚ©Ø± Ù…Ø§ÙÛŒØ§", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø¨Ø±Ø¹Ú©Ø³â€ŒÚ©Ø±Ø¯Ù† Ø§Ø³ØªØ¹Ù„Ø§Ù…", descFa: "Ø¯Ø± Ù†Ø³Ø®Ù‡Ù” Ø±Ø§ÛŒØ¬Ù Â«Ø´Ø¨â€ŒÙ‡Ø§ÛŒ Ù…Ø§ÙÛŒØ§Â»ØŒ ÙÙ‚Ø· Û² Ø¨Ø§Ø± Ø¯Ø± Ú©Ù„ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†Ø¯ ØªØ§ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ùˆ Ù‡Ù…Ø§Ù† Ø´Ø¨ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø¨Ø±Ø¹Ú©Ø³ Ø´ÙˆØ¯ (Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø§Ù†ØªØ®Ø§Ø¨ ØªÚ©Ø±Ø§Ø±ÛŒ Ù¾Ø´Øªâ€ŒØ³Ø±Ù‡Ù… Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª)." },
          matador: { faName: "Ù…Ø§ØªØ§Ø¯ÙˆØ±", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ú¯Ø±ÙØªÙ†Ù Ù‚Ø§Ø¨Ù„ÛŒØª", descFa: "Ø´Ø¨â€ŒÙ‡Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†Ø¯ ØªØ§ ØªÙˆØ§Ù†Ø§ÛŒÛŒÙ Ø´Ø¨Ù Ø§Ùˆ Ù‡Ù…Ø§Ù† Ø´Ø¨ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´ÙˆØ¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ)." },
          saulGoodman: { faName: "Ø³Ø§ÙˆÙ„ Ú¯ÙˆØ¯Ù…Ù†", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø®Ø±ÛŒØ¯/Ø³ÙˆØ¯Ø§Ú¯Ø±ÛŒ", descFa: "Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ (Ù…Ø«Ù„Ø§Ù‹ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡) ÛŒÚ©â€ŒØ¨Ø§Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÛŒÚ© Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø³Ø§Ø¯Ù‡ Ø±Ø§ Ø¨Ù‡ Ù…Ø§ÙÛŒØ§ ØªØ¨Ø¯ÛŒÙ„ Ú©Ù†Ø¯." },

          detective: { faName: "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø§Ø³ØªØ¹Ù„Ø§Ù…Ù Ø´Ø¨", descFa: "Ù‡Ø± Ø´Ø¨ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ú©Ù†Ø¯ ØªØ§ Ù…Ø§ÙÛŒØ§ÛŒÛŒ/Ø´Ù‡Ø±ÙˆÙ†Ø¯ÛŒ Ø¨ÙˆØ¯Ù† Ø§Ùˆ Ø±Ø§ Ø¨ÙÙ‡Ù…Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ)." },
          investigator: { faName: "Ø¨Ø§Ø²Ù¾Ø±Ø³", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø¨Ø§Ø²Ù¾Ø±Ø³ÛŒ", descFa: "Ø¯Ø± Ø¨Ø±Ø®ÛŒ Ø³Ù†Ø§Ø±ÛŒÙˆÙ‡Ø§ ÛŒÚ©â€ŒØ¨Ø§Ø± Ø¯Ø± Ø·ÙˆÙ„ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø§Ø²Ù¾Ø±Ø³ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡Ø¯ (Ø¬Ø²Ø¦ÛŒØ§Øª Ø¨Ø³ØªÙ‡ Ø¨Ù‡ Ø³Ù†Ø§Ø±ÛŒÙˆ Ø§Ø³Øª)." },
          doctor: { faName: "Ù¾Ø²Ø´Ú©", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø³ÛŒÙˆÙ Ø´Ø¨", descFa: "Ù‡Ø± Ø´Ø¨ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¬Ø§Ù† ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø§Ø² Ø´Ù„ÛŒÚ© Ù†Ø¬Ø§Øª Ø¯Ù‡Ø¯. Ø¯Ø± Ù†Ø³Ø®Ù‡Ù” Ø±Ø§ÛŒØ¬ØŒ ÙˆÙ‚ØªÛŒ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø²ÛŒØ§Ø¯ Ø¨Ø§Ø´Ù†Ø¯ Û² Ø§Ù†ØªØ®Ø§Ø¨ Ø¯Ø§Ø±Ø¯ Ùˆ Ù†Ø¬Ø§ØªÙ Ø®ÙˆØ¯Ø´ Ù…Ø­Ø¯ÙˆØ¯ Ø§Ø³Øª." },
          watson: { faName: "Ø¯Ú©ØªØ± ÙˆØ§ØªØ³ÙˆÙ†", teamFa: "Ø´Ù‡Ø±", hintFa: "Ù†Ø¬Ø§Øª", descFa: "Ø¯Ø± Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡ Ù†Ù‚Ø´ Ù¾Ø²Ø´Ú© Ø´Ù‡Ø± Ø§Ø³Øª (Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ù…ÛŒØ²)." },
          researcher: { faName: "Ù…Ø­Ù‚Ù‚", teamFa: "Ø´Ù‡Ø±", hintFa: "Ú¯Ø±Ù‡/Ù¾ÛŒÙˆÙ†Ø¯", descFa: "Ø¯Ø± Ù†Ø³Ø®Ù‡Ù” Ø±Ø§ÛŒØ¬Ù Â«Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ùˆ Ù…Ø§ÙÛŒØ§Â»ØŒ (Ø¨Ù‡â€ŒØ¬Ø² Ø´Ø¨ Ù…Ø¹Ø§Ø±ÙÙ‡) Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®ÙˆØ¯Ø´ Ø±Ø§ Ø¨Ù‡ ÛŒÚ© Ù†ÙØ± Ú¯Ø±Ù‡ Ø¨Ø²Ù†Ø¯Ø› Ø§Ú¯Ø± Ù…Ø­Ù‚Ù‚ Ø¨Ø§ Ø´Ø§Øª Ø´Ø¨ ÛŒØ§ Ø±Ø£ÛŒ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´ÙˆØ¯ØŒ Ø¢Ù† Ù†ÙØ± Ù‡Ù… Ø¨Ø§ Ø§Ùˆ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø¨Ø§ Ø§Ø³ØªØ«Ù†Ø§Ù‡Ø§ÛŒÛŒ Ù…Ø«Ù„ Ø±Ø¦ÛŒØ³ Ù…Ø§ÙÛŒØ§)." },
          invulnerable: { faName: "Ø±ÙˆÛŒÛŒÙ†â€ŒØªÙ†", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø²Ø±Ù‡Ù Ø´Ø¨", descFa: "Ø¯Ø± Ù†Ø³Ø®Ù‡Ù” Ø±Ø§ÛŒØ¬ØŒ Ø´Ø¨â€ŒÙ‡Ø§ Ø¨Ø§ Ø´Ù„ÛŒÚ© Ù…Ø§ÙÛŒØ§ Ú©Ø´ØªÙ‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ ÙÙ‚Ø· Ø¨Ø§ Ø±Ø£ÛŒ/Ø´Ø±Ø§ÛŒØ· Ø®Ø§Øµ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯." },
          armored: { faName: "Ø²Ø±Ù‡â€ŒÙ¾ÙˆØ´", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø²Ø±Ù‡ + Ø¨Ø§Ø²Ú¯Ø´Øª", descFa: "Ø¯Ø± Ù†Ø³Ø®Ù‡Ù” Ø±Ø§ÛŒØ¬ØŒ Ø´Ø¨ Ø¨Ø§ ØªÛŒØ± Ù…Ø§ÙÛŒØ§ Ú©Ø´ØªÙ‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø§Ú¯Ø± Ø±ÙˆØ² Ø¨Ø§ Ø±Ø£ÛŒ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´ÙˆØ¯ØŒ Ù†Ù‚Ø´Ø´ Ø§ÙØ´Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø¯ (Ùˆ Ø§Ø² Ø¢Ù† Ø¨Ù‡ Ø¨Ø¹Ø¯ Ù‚Ø§Ø¨Ù„ Ù…Ø°Ø§Ú©Ø±Ù‡ Ù†ÛŒØ³Øª)." },
          sniper: { faName: "ØªÚ©â€ŒØªÛŒØ±Ø§Ù†Ø¯Ø§Ø²", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø´Ù„ÛŒÚ©Ù Ù…Ø­Ø¯ÙˆØ¯", descFa: "Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ ÙÙ‚Ø· ÛŒÚ©â€ŒØ¨Ø§Ø± Ø§Ø¬Ø§Ø²Ù‡ Ø´Ù„ÛŒÚ© Ø¯Ø§Ø±Ø¯. Ø§Ú¯Ø± Ø¨Ù‡ Ø§Ø´ØªØ¨Ø§Ù‡ Ø¨Ù‡ Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø´Ù„ÛŒÚ© Ú©Ù†Ø¯ØŒ Ø®ÙˆØ¯Ø´ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø­ØªÛŒ Ø§Ú¯Ø± Ù¾Ø²Ø´Ú© Ø§Ùˆ Ø±Ø§ Ù†Ø¬Ø§Øª Ø¯Ù‡Ø¯)." },
          professional: { faName: "Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø´Ù„ÛŒÚ©", descFa: "Ø´Ø¨â€ŒÙ‡Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ù‡ Ú©Ø³ÛŒ Ú©Ù‡ Ù…Ø§ÙÛŒØ§ÛŒÛŒ Ù…ÛŒâ€ŒØ¯Ø§Ù†Ø¯ Ø´Ù„ÛŒÚ© Ú©Ù†Ø¯Ø› Ø§Ú¯Ø± Ø§Ø´ØªØ¨Ø§Ù‡ Ø¨Ù‡ Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø´Ù„ÛŒÚ© Ú©Ù†Ø¯ØŒ Ø®ÙˆØ¯Ø´ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯." },
          reporter: { faName: "Ø®Ø¨Ø±Ù†Ú¯Ø§Ø±", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø§Ø³ØªØ¹Ù„Ø§Ù…Ù Ù…Ø°Ø§Ú©Ø±Ù‡", descFa: "Ø¯Ø± Ø³Ù†Ø§Ø±ÛŒÙˆ Ù…Ø°Ø§Ú©Ø±Ù‡â€ŒÚ©Ù†Ù†Ø¯Ù‡ØŒ Ø§Ø² Ø´Ø¨ÛŒ Ú©Ù‡ Ù…Ø°Ø§Ú©Ø±Ù‡ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ø§Ø³ØªØ¹Ù„Ø§Ù…Ù ÙØ±Ø¯Ù Ù…Ø°Ø§Ú©Ø±Ù‡â€ŒØ´Ø¯Ù‡ Ø±Ø§ Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯Ø› Ø§Ú¯Ø± Ø¯Ø±Ø³Øª ØªØ´Ø®ÛŒØµ Ø¯Ù‡Ø¯ØŒ Ú¯Ø±Ø¯Ø§Ù†Ù†Ø¯Ù‡ ØªØ£ÛŒÛŒØ¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯." },
          representative: { faName: "Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡", teamFa: "Ø´Ù‡Ø±", hintFa: "Ù‚Ø¯Ø±ØªÙ Ø±ÙˆØ²", descFa: "Ø¯Ø± Ø§ÛŒÙ† Ù†Ø³Ø®Ù‡ ÙÙ‚Ø· Ø¨Ù‡â€ŒØ¹Ù†ÙˆØ§Ù† Ù†Ù‚Ø´ Ø³Ù†Ø§Ø±ÛŒÙˆ Â«Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡Â» ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡ Ø§Ø³Øª (Ù‚ÙˆØ§Ù†ÛŒÙ† Ø¯Ù‚ÛŒÙ‚Ø´ Ø¨Ø³ØªÙ‡ Ø¨Ù‡ Ù†Ø³Ø®Ù‡Ù” Ø³Ù†Ø§Ø±ÛŒÙˆ Ù…ØªÙØ§ÙˆØª Ø§Ø³Øª)." },
          hardJohn: { faName: "Ø¬Ø§Ù†â€ŒØ³Ø®Øª", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø¬Ø§Ù† Ø§Ø¶Ø§ÙÙ‡ + Ø§Ø³ØªØ¹Ù„Ø§Ù…", descFa: "Ø¨Ø§ Ø´Ù„ÛŒÚ© Ø§ÙˆÙ„Ù Ù…Ø§ÙÛŒØ§ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø®ÙˆØ¯Ø´ Ù…ØªÙˆØ¬Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯). Ù‡Ù…Ú†Ù†ÛŒÙ† Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¯ÙˆØ¨Ø§Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÙˆØ¶Ø¹ÛŒØª/Ø³Ø§ÛŒØ¯Ù Ù†ÙØ±Ø§ØªÙ Ø®Ø§Ø±Ø¬â€ŒØ´Ø¯Ù‡ Ø±Ø§ Ø§Ø² Ú¯Ø±Ø¯Ø§Ù†Ù†Ø¯Ù‡ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¨Ú¯ÛŒØ±Ø¯." },
          psychologist: { faName: "Ø±ÙˆØ§Ù†Ù¾Ø²Ø´Ú©", teamFa: "Ø´Ù‡Ø±", hintFa: "Ù‚Ø·Ø¹ Ù…Ú©Ø§Ù„Ù…Ù‡", descFa: "Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¯Ùˆ Ø¨Ø§Ø± Ø¯Ø± Ø·ÙˆÙ„ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ØªÙˆØ§Ù†Ø§ÛŒÛŒ ØµØ­Ø¨Øª/Ù…Ú©Ø§Ù„Ù…Ù‡Ù” ÛŒÚ© Ø¨Ø§Ø²ÛŒÚ©Ù† Ø±Ø§ Ø¨Ú¯ÛŒØ±Ø¯." },
          mayor: { faName: "Ø´Ù‡Ø±Ø¯Ø§Ø±", teamFa: "Ø´Ù‡Ø±", hintFa: "ÙˆØªÙˆ/Ø®Ø±ÙˆØ¬", descFa: "Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ ÙÙ‚Ø· ÛŒÚ©â€ŒØ¨Ø§Ø± (ÙˆÙ‚ØªÛŒ Ø­Ø¯Ø§Ù‚Ù„ Û² Ù†ÙØ± Ø¯Ø± Ø¯ÙØ§Ø¹ÛŒÙ‡ Ø¨Ø§Ø´Ù†Ø¯ Ùˆ Ø®ÙˆØ¯Ø´ Ø¯Ø± Ø¯ÙØ§Ø¹ÛŒÙ‡ Ù†Ø¨Ø§Ø´Ø¯) Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø±Ø£ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ Ø¯ÙˆØ± Ø¯ÙˆÙ… Ø±Ø§ Ù„ØºÙˆ Ú©Ù†Ø¯ ÛŒØ§ Ø­Ú©Ù…Ù Ø®Ø±ÙˆØ¬ Ù…Ø³ØªÙ‚ÛŒÙ… ÛŒÚ©ÛŒ Ø§Ø² Ø§ÙØ±Ø§Ø¯Ù Ø¯ÙØ§Ø¹ÛŒÙ‡ Ø±Ø§ Ø¨Ø¯Ù‡Ø¯." },
          seller: { faName: "ÙØ±ÙˆØ´Ù†Ø¯Ù‡", teamFa: "Ø´Ù‡Ø±", hintFa: "Ú¯Ø±ÙØªÙ† Ù‚Ø§Ø¨Ù„ÛŒØª", descFa: "ÛŒÚ©â€ŒØ¨Ø§Ø± Ø¯Ø± Ø·ÙˆÙ„ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ØªÙˆØ§Ù†Ø§ÛŒÛŒÙ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ù„ Ø¨Ø§Ø²ÛŒ Ø§Ø² Ø§Ùˆ Ø¨Ú¯ÛŒØ±Ø¯Ø› Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ ÙØ±Ø¯Ø§ÛŒ Ù‡Ù…Ø§Ù† Ø±ÙˆØ²ØŒ Ø§Ù†ØªØ®Ø§Ø¨Ù ÙØ±ÙˆØ´Ù†Ø¯Ù‡ ØªÙˆØ³Ø· Ø±Ø§ÙˆÛŒ Ø§Ø¹Ù„Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯." },
          priest: { faName: "Ú©Ø´ÛŒØ´", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø­Ù…Ø§ÛŒØªÙ Ú¯ÙØªâ€ŒÙˆÚ¯Ùˆ", descFa: "Ø·Ø¨Ù‚ Ù†Ø³Ø®Ù‡Ù” Ø±Ø§ÛŒØ¬ØŒ Ø´Ø¨â€ŒÙ‡Ø§ Ú†Ù†Ø¯ Ù†ÙØ± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ ØªØ§ Ø±ÙˆØ² Ø¨Ø¹Ø¯ Ø­Ù‚ ØµØ­Ø¨Øª Ø§Ø¶Ø§ÙÙ‡ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù†Ø¯Ø› Ù‡Ù…Ú†Ù†ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø±Ø®ÛŒ Ø§Ø«Ø±Ù‡Ø§ÛŒ Ø³Ú©ÙˆØª Ø±Ø§ Ø®Ù†Ø«ÛŒ Ú©Ù†Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ)." },
          judge: { faName: "Ù‚Ø§Ø¶ÛŒ", teamFa: "Ø´Ù‡Ø±", hintFa: "ØªØºÛŒÛŒØ± Ø±Ø£ÛŒ", descFa: "ÛŒÚ©â€ŒØ¨Ø§Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù†ØªÛŒØ¬Ù‡Ù” Ø±Ø£ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ Ø±ÙˆØ² Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡Ø¯/Ù…Ù„ØºÛŒ Ú©Ù†Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆØ› Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¯Ø± Ø´Ø¨ Ø§Ø¹Ù…Ø§Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯)." },
          commander: { faName: "ÙØ±Ù…Ø§Ù†Ø¯Ù‡", teamFa: "Ø´Ù‡Ø±", hintFa: "ØªØ£ÛŒÛŒØ¯ Ø´Ù„ÛŒÚ©", descFa: "Ø¨Ø¹Ø¯ Ø§Ø² Ø´Ù„ÛŒÚ©Ù Ø§Ø³Ù†Ø§ÛŒÙ¾Ø± Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø´Ù„ÛŒÚ© Ø±Ø§ ØªØ£ÛŒÛŒØ¯ ÛŒØ§ Ø±Ø¯ Ú©Ù†Ø¯Ø› Ø§Ú¯Ø± Ø±Ø¯ Ú©Ù†Ø¯ØŒ ØªÛŒØ± Ø§ØµØ§Ø¨Øª Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ)." },

          // --- Capo (Ú©Ø§Ù¾Ùˆ/Ø¯Ù†) ---
          danMafia: { faName: "Ø¯Ù† Ù…Ø§ÙÛŒØ§", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø±Ø¦ÛŒØ³ + Ù¾Ø§Ø¯Ø²Ù‡Ø±", descFa: "Ø±Ø¦ÛŒØ³ ØªÛŒÙ… Ù…Ø§ÙÛŒØ§Ø³Øª Ùˆ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ùˆ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Â«Ù…Ù†ÙÛŒÂ» Ø§Ø³Øª. ÛŒÚ© Ù¾Ø§Ø¯Ø²Ù‡Ø± Ø¯Ø§Ø±Ø¯ (Ù…Ø«Ù„Ø§Ù‹ Ø¯Ø± ØµÙˆØ±Øª Ø²Ù‡Ø±Ù Ø¹Ø·Ø§Ø±). Ù‡Ù…Ú†Ù†ÛŒÙ† Ù‚Ø§Ø¨Ù„ÛŒØª Ø³ÙˆØ¯Ø§Ú¯Ø±ÛŒ/Ø®Ø±ÛŒØ¯Ù Ø¨Ø±Ø®ÛŒ Ù†Ù‚Ø´â€ŒÙ‡Ø§ÛŒ Ø´Ù‡Ø± Ø±Ø§ Ø¯Ø§Ø±Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ø§Ù¾Ùˆ)." },
          witch: { faName: "Ø¬Ø§Ø¯ÙˆÚ¯Ø±", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ú©Ù¾ÛŒÙ Ù‚Ø§Ø¨Ù„ÛŒØª", descFa: "Ù‡Ø± Ø´Ø¨ ÛŒÚ© Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯Ø› Ø§Ú¯Ø± Ø¢Ù† Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø§Ø¨Ù„ÛŒØªÛŒâ€ŒØ¯Ø§Ø± Ø¨Ø§Ø´Ø¯ØŒ Ø§Ø¨Ù„ÛŒØªÛŒÙ Ø§Ùˆ Ø±ÙˆÛŒ Ø®ÙˆØ¯Ù Ø¬Ø§Ø¯ÙˆÚ¯Ø± Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ù…Ø«Ù„Ø§Ù‹ Ø§Ø² Ø²Ø±Ù‡â€ŒØ³Ø§Ø² Ø²Ø±Ù‡ Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯ØŒ Ø§Ø² Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯ØŒ Ø§Ø² Ø¹Ø·Ø§Ø± Ø¨Ø±Ø§ÛŒ Ø®ÙˆØ¯Ø´ Ø²Ù‡Ø± Ù…ÛŒâ€ŒØ±ÛŒØ²Ø¯) (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ø§Ù¾Ùˆ)." },
          executioner: { faName: "Ø¬Ù„Ø§Ø¯", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø­Ø¯Ø³Ù Ù†Ù‚Ø´", descFa: "Ù…Ø´Ø§Ø¨Ù‡ Â«Ù†Ø§ØªÙˆÂ»: Ø§Ú¯Ø± Ù†Ù‚Ø´Ù ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø¯Ø±Ø³Øª Ø­Ø¯Ø³ Ø¨Ø²Ù†Ø¯ØŒ Ø¢Ù† Ù†ÙØ± ØªØ­Øª Ù‡Ø± Ø´Ø±Ø§ÛŒØ·ÛŒ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ø§Ù¾Ùˆ)." },
          informant: { faName: "Ø®Ø¨Ø±Ú†ÛŒÙ†", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø¬Ø§Ø³ÙˆØ³", descFa: "Ø¬Ø§Ø³ÙˆØ³ ØªÛŒÙ… Ù…Ø§ÙÛŒØ§Ø³Øª. Ø§Ú¯Ø± Ú©Ø¯Ø®Ø¯Ø§ Ø§Ùˆ Ø±Ø§ Ø¨ÛŒØ¯Ø§Ø± Ú©Ù†Ø¯ØŒ Ù…Ø«Ù„ Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ø§Ù¾Ùˆ)." },
          kadkhoda: { faName: "Ú©Ø¯Ø®Ø¯Ø§", teamFa: "Ø´Ù‡Ø±", hintFa: "Ù„ÛŒÙ†Ú©Ù Ø´Ù‡Ø±", descFa: "Ø¯Ø± Ø·ÙˆÙ„ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Û² Ù†ÙØ± Ø±Ø§ Ø¨Ù‡ Â«Ù„ÛŒÙ†Ú© Ø´Ù‡Ø±ÙˆÙ†Ø¯ÛŒÂ» ÙˆØµÙ„ Ú©Ù†Ø¯. Ø¯Ø± Ø´Ø¨Ù Ù„ÛŒÙ†Ú©â€ŒÚ©Ø±Ø¯Ù†ØŒ Ø§Ú¯Ø± Ø´Ù‡Ø±ÙˆÙ†Ø¯/Ø®Ø¨Ø±Ú†ÛŒÙ† Ø¨Ø§Ø´Ù†Ø¯ Ø¨Ø§ Ø§Ùˆ Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ (Ø¨Ø¯ÙˆÙ† Ú¯ÙØªÙ† Ù†Ù‚Ø´). Ø§Ú¯Ø± Ú©Ø¯Ø®Ø¯Ø§ Ø§Ø´ØªØ¨Ø§Ù‡ ÛŒÚ© Ù…Ø§ÙÛŒØ§ (Ø¬Ø² Ø®Ø¨Ø±Ú†ÛŒÙ†) Ø±Ø§ Ø¨ÛŒØ¯Ø§Ø± Ú©Ù†Ø¯ØŒ Ù…Ø±Ú¯ Ú©Ø¯Ø®Ø¯Ø§ Ø§ØªÙØ§Ù‚ Ù…ÛŒâ€ŒØ§ÙØªØ¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ø§Ù¾Ùˆ)." },
          heir: { faName: "ÙˆØ§Ø±Ø«", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø§Ø±Ø«Ù Ù†Ù‚Ø´", descFa: "Ø´Ø¨ Ù…Ø¹Ø§Ø±ÙÙ‡ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ø§Ú¯Ø± Ø¢Ù† Ù†ÙØ± Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´ÙˆØ¯ØŒ ÙˆØ§Ø±Ø« (ÙÙ‚Ø· Ø¯Ø± Ø¨Ø±Ø®ÛŒ Ù†Ù‚Ø´â€ŒÙ‡Ø§ Ù…Ø«Ù„ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡/Ø²Ø±Ù‡â€ŒØ³Ø§Ø²/Ø¹Ø·Ø§Ø±) ØªÙˆØ§Ù†Ø§ÛŒÛŒÙ Ø§Ùˆ Ø±Ø§ Ø¨Ù‡ Ø§Ø±Ø« Ù…ÛŒâ€ŒØ¨Ø±Ø¯. ØªØ§ Ù‚Ø¨Ù„ Ø§Ø² Ú¯Ø±ÙØªÙ†Ù Ù†Ù‚Ø´ØŒ Ù†Ø§Ù…ÛŒØ±Ø§Ø³Øª (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ø§Ù¾Ùˆ)." },
          herbalist: { faName: "Ø¹Ø·Ø§Ø±", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø²Ù‡Ø± + Ù¾Ø§Ø¯Ø²Ù‡Ø±", descFa: "ÛŒÚ© Ù¾Ø§Ø¯Ø²Ù‡Ø± Ø¯Ø§Ø±Ø¯ Ùˆ ÛŒÚ© Ø²Ù‡Ø±: Ù‡Ø± Ø´Ø¨ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø²Ù‡Ø± Ø¨Ø¯Ù‡Ø¯Ø› ØµØ¨Ø­ Ø§Ø¹Ù„Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ø²Ù‡Ø± ÙˆØ§Ø±Ø¯ Ø¨Ø§Ø²ÛŒ Ø´Ø¯Ù‡ Ùˆ Ø§Ú¯Ø± ØªØ§ Ù¾Ø§ÛŒØ§Ù† Ø±ÙˆØ² ÙØ±Ø¯Ù Ù…Ø³Ù…ÙˆÙ… Ø®Ø§Ø±Ø¬ Ù†Ø´ÙˆØ¯ØŒ Ø¨Ø§ Ø±Ø£ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ Ø´Ø¨ Ù…Ø´Ø®Øµ Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ù¾Ø§Ø¯Ø²Ù‡Ø± Ø¯Ø§Ø¯Ù‡ Ø´ÙˆØ¯ ÛŒØ§ Ù†Ù‡ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ø§Ù¾Ùˆ)." },
          armorsmith: { faName: "Ø²Ø±Ù‡â€ŒØ³Ø§Ø²", teamFa: "Ø´Ù‡Ø±", hintFa: "Ù†Ø¬Ø§ØªÙ ÛŒÚ©â€ŒØ¨Ø§Ø±Ù‡", descFa: "ÛŒÚ©â€ŒØ¨Ø§Ø± Ø¯Ø± Ú©Ù„ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®ÙˆØ¯Ø´ Ø±Ø§ Ù†Ø¬Ø§Øª Ø¯Ù‡Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ø§Ù¾Ùˆ)." },
          suspect: { faName: "Ù…Ø¸Ù†ÙˆÙ†", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø§Ø³ØªØ¹Ù„Ø§Ù…Ù Ù…Ø«Ø¨Øª", descFa: "Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø§Ø³Øª Ø§Ù…Ø§ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ùˆ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Â«Ù…Ø«Ø¨ØªÂ» Ø§Ø³Øª (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ú©Ø§Ù¾Ùˆ)." },

          // --- Zodiac ---
          alcapone: { faName: "Ø¢Ù„Ú©Ø§Ù¾Ù†", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø±Ø¦ÛŒØ³", descFa: "Ø±Ø¦ÛŒØ³ Ù…Ø§ÙÛŒØ§Ø³Øª Ùˆ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ùˆ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ù…Ù†ÙÛŒ Ø§Ø³Øª (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ø²ÙˆØ¯ÛŒØ§Ú©)." },
          zodiac: { faName: "Ø²ÙˆØ¯ÛŒØ§Ú©", teamFa: "Ù…Ø³ØªÙ‚Ù„", hintFa: "Ø´Ù„ÛŒÚ©Ù Ø´Ø¨â€ŒÙ‡Ø§ÛŒ Ø²ÙˆØ¬", descFa: "ØªÛŒÙ… Ù…Ø³ØªÙ‚Ù„ Ø§Ø³Øª. Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¯Ø± Ø´Ø¨â€ŒÙ‡Ø§ÛŒ Ø²ÙˆØ¬ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ù‡ Ø´Ù‡Ø±ÙˆÙ†Ø¯ ÛŒØ§ Ù…Ø§ÙÛŒØ§ Ø´Ù„ÛŒÚ© Ú©Ù†Ø¯ Ùˆ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ú©Ù†Ø¯. Ø¨Ø§ Ø´Ù„ÛŒÚ© Ø´Ø¨ Ú©Ø´ØªÙ‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ ÙÙ‚Ø· Ø¨Ø§ Ø±Ø£ÛŒâ€ŒÚ¯ÛŒØ±ÛŒ ÛŒØ§ Ø¨Ù…Ø¨â€ŒÚ¯Ø°Ø§Ø±ÛŒ (Ùˆ Ø¯Ø± Ø¨Ø±Ø®ÛŒ Ù‚ÙˆØ§Ù†ÛŒÙ† Ø¨Ø§ Ø´Ù„ÛŒÚ©Ù ØªÙÙ†Ú¯ Ø¯Ø± Ø±ÙˆØ²) Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø§Ú¯Ø± Ø¨Ù‡ Â«Ù…Ø­Ø§ÙØ¸Â» Ø´Ù„ÛŒÚ© Ú©Ù†Ø¯ØŒ Ø®ÙˆØ¯Ø´ Ú©Ø´ØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯." },
          magician: { faName: "Ø´Ø¹Ø¨Ø¯Ù‡â€ŒØ¨Ø§Ø²", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ú¯Ø±ÙØªÙ† Ù‚Ø§Ø¨Ù„ÛŒØª", descFa: "Ù‡Ø± Ø´Ø¨ (Ø¨Ø§ Ù‡Ù…Ø§Ù‡Ù†Ú¯ÛŒ ØªÛŒÙ… Ù…Ø§ÙÛŒØ§) ÛŒÚ© Ù†ÙØ± Ø§Ø² Ø´Ù‡Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ ØªÙˆØ§Ù†Ø§ÛŒÛŒÙ Ø§Ùˆ Ø±Ø§ Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯/ØºÛŒØ±ÙØ¹Ø§Ù„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯." },
          bomber: { faName: "Ø¨Ù…Ø¨â€ŒÚ¯Ø°Ø§Ø±", teamFa: "Ù…Ø§ÙÛŒØ§", hintFa: "Ø¨Ù…Ø¨â€ŒÚ¯Ø°Ø§Ø±ÛŒ", descFa: "ÛŒÚ©â€ŒØ¨Ø§Ø± Ø¯Ø± Ø·ÙˆÙ„ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ù…Ø¨â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ú©Ù†Ø¯: ÛŒÚ© Â«Ú©Ø¯ Û± ØªØ§ Û´Â» Ø¨Ù‡ Ú¯Ø±Ø¯Ø§Ù†Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ùˆ Ø¨Ø§Ø²ÛŒÚ©Ù†Ù Ù‡Ø¯Ù ÙÙ‚Ø· Ø§Ú¯Ø± Ú©Ø¯ Ø±Ø§ Ø¯Ø±Ø³Øª Ø­Ø¯Ø³ Ø¨Ø²Ù†Ø¯ Ø¯Ø± Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒÙ…Ø§Ù†Ø¯." },
          guard: { faName: "Ù…Ø­Ø§ÙØ¸", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø¶Ø¯ Ø¨Ù…Ø¨/Ø²ÙˆØ¯ÛŒØ§Ú©", descFa: "Ø¯Ø± Ø²Ù…Ø§Ù† Ø¨Ù…Ø¨â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®ÙˆØ¯Ø´ Ø±Ø§ ÙØ¯Ø§ÛŒ Ù†ÙØ±Ù Ù‡Ø¯Ù Ú©Ù†Ø¯. Ø³Ù¾Ø³ Ú©Ø¯Ù Ø®Ù†Ø«ÛŒâ€ŒØ³Ø§Ø²ÛŒ Ø±Ø§ Ø­Ø¯Ø³ Ù…ÛŒâ€ŒØ²Ù†Ø¯ Ùˆ ÙÙ‚Ø· Ø¯Ø± ØµÙˆØ±Øª Ø­Ø¯Ø³Ù Ø¯Ø±Ø³Øª Ø¯Ø± Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒÙ…Ø§Ù†Ø¯. Ù‡Ù…Ú†Ù†ÛŒÙ† Ø§Ú¯Ø± Ø²ÙˆØ¯ÛŒØ§Ú© Ø¨Ù‡ Ù…Ø­Ø§ÙØ¸ Ø´Ù„ÛŒÚ© Ú©Ù†Ø¯ØŒ Ø²ÙˆØ¯ÛŒØ§Ú© Ú©Ø´ØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯." },
          ocean: { faName: "Ø§ÙˆØ´Ù†", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø¨ÛŒØ¯Ø§Ø±ÛŒ Ø´Ù‡Ø±", descFa: "Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¯Ùˆ Ø¨Ø§Ø± Ø¯Ø± Ø·ÙˆÙ„ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø´Ø¨ Ú†Ù†Ø¯ Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø±Ø§ Ø¨ÛŒØ¯Ø§Ø± Ú©Ù†Ø¯ ØªØ§ Ø¨Ø§ Ú†Ø´Ù… Ø¨Ø§Ø² Ø¨Ø§ Ù‡Ù… Ù…Ø´ÙˆØ±Øª Ú©Ù†Ù†Ø¯. Ø§Ú¯Ø± Ø§Ø´ØªØ¨Ø§Ù‡ ÛŒÚ©ÛŒ Ø§Ø² Ø§Ø¹Ø¶Ø§ÛŒ Ù…Ø§ÙÛŒØ§ ÛŒØ§ Ø²ÙˆØ¯ÛŒØ§Ú© Ø±Ø§ Ø¨ÛŒØ¯Ø§Ø± Ú©Ù†Ø¯ØŒ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯." },
          gunslinger: { faName: "ØªÙÙ†Ú¯Ø¯Ø§Ø±", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø¯Ø§Ø¯Ù† ØªÙÙ†Ú¯", descFa: "Ø³Ù‡ ØªÙÙ†Ú¯ Ø¯Ø§Ø±Ø¯ (Û² ØªÛŒØ± Ù…Ø´Ù‚ÛŒ Ùˆ Û± ØªÛŒØ± Ø¬Ù†Ú¯ÛŒ). Ø®ÙˆØ¯Ø´ Ø´Ù„ÛŒÚ© Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯Ø› Ø´Ø¨ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ØªÙÙ†Ú¯ Ø±Ø§ Ø¨Ù‡ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø¨Ø¯Ù‡Ø¯ Ùˆ Ø¨Ø§Ø²ÛŒÚ©Ù†ÛŒ Ú©Ù‡ ØªÙÙ†Ú¯ Ú¯Ø±ÙØªÙ‡ØŒ Ø±ÙˆØ² Ø¨Ø¹Ø¯ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†Ø¯." },

          // --- Godfather (game) ---
          leon: { faName: "Ù„Ø¦ÙˆÙ†", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ø´Ù‡Ø±", descFa: "Ù†Ù‚Ø´ Ú©Ù„ÛŒØ¯ÛŒ Ø´Ù‡Ø± Ø¯Ø± Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡ (Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ù…ÛŒØ²)." },
          constantine: { faName: "Ú©Ù†Ø³ØªØ§Ù†ØªÛŒÙ†", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†ÛŒ", descFa: "Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ù…ÛŒØ² ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡)." },
          citizenKane: { faName: "Ù‡Ù…Ø´Ù‡Ø±ÛŒ Ú©ÛŒÙ†", teamFa: "Ø´Ù‡Ø±", hintFa: "Ø§ÙØ´Ø§", descFa: "Ø¯Ø± Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ ÛŒÚ©â€ŒØ¨Ø§Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ù†Ø´Ø§Ù† Ú©Ù†Ø¯Ø› Ø§Ú¯Ø± Ø¢Ù† Ù†ÙØ± Ù…Ø§ÙÛŒØ§ Ø¨Ø§Ø´Ø¯ØŒ ØµØ¨Ø­ Ø³Ø§ÛŒØ¯ Ø§Ùˆ ØªÙˆØ³Ø· Ú¯Ø±Ø¯Ø§Ù†Ù†Ø¯Ù‡ Ø§Ø¹Ù„Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ù…ÛŒØ²)." },
          nostradamus: { faName: "Ù†ÙˆØ³ØªØ±Ø§Ø¯Ø§Ù…ÙˆØ³", teamFa: "Ù…Ø³ØªÙ‚Ù„", hintFa: "Ø´Ø¨ Ù…Ø¹Ø§Ø±ÙÙ‡", descFa: "Ø¯Ø± Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡ (Ø±ÙˆØ§ÛŒØª Ø±Ø§ÛŒØ¬)ØŒ ÙÙ‚Ø· Ø´Ø¨ Ù…Ø¹Ø§Ø±ÙÙ‡ Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Û³ Ù†ÙØ± Ø±Ø§ Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯Ø› Ú¯Ø±Ø¯Ø§Ù†Ù†Ø¯Ù‡ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§Ù‡Ø§ÛŒ Ø¯Ø§Ø®Ù„ Ø§ÛŒÙ† Û³ Ù†ÙØ± Ø±Ø§ Ø§Ø¹Ù„Ø§Ù… Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ø§Ùˆ Ø¨Ø±Ø§Ø³Ø§Ø³ Ø¢Ù†ØŒ Ø³Ø§ÛŒØ¯ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯." },
        };

        // English role labels (UI only). If a role isn't present here, it falls back to Persian.
        const ROLE_I18N = {
          citizen: { name: "Citizen", hint: "No ability", desc: "No night ability. Help find mafia through discussion and voting." },
          mafia: { name: "Mafia", hint: "No ability", desc: "No standalone ability. Coordinate at night; mislead during the day." },
          mafiaBoss: { name: "Mafia Boss", hint: "Leader + shot", desc: "Leads the mafia; usually decides the night shot. Often shows as â€˜negativeâ€™ to the Detective." },
          godfather: { name: "Godfather", hint: "Leader + shot", desc: "Often the mafia leader who decides the night shot; typically shows as â€˜negativeâ€™ to the Detective." },
          swindler: { name: "Charlatan", hint: "Disrupts inquiry", desc: "Disrupts inquiries (varies by scenario). Applies an effect to a target each night." },
          nato: { name: "NATO", hint: "Guess a role", desc: "Once (by scenario), guesses a playerâ€™s exact role; if correct, that player is eliminated." },
          negotiator: { name: "Negotiator", hint: "Convert", desc: "May attempt (by scenario) to convert a citizen to mafia; usually replaces the night shot." },
          natasha: { name: "Natasha", hint: "Night silence", desc: "Chooses a player to be silent the next day (rules vary)." },
          doctorLecter: { name: "Dr. Lecter", hint: "Save (mafia)", desc: "Mafia doctor. Can save a target from the night shot; self-save is usually limited." },
          jokerMafia: { name: "Mafia Joker", hint: "Flip inquiry", desc: "Limited times per game can invert a Detective inquiry result (scenario rules apply)." },
          matador: { name: "Matador", hint: "Disable ability", desc: "Chooses a player to disable their night ability for that night (by scenario)." },
          saulGoodman: { name: "Saul Goodman", hint: "Buy/convert", desc: "Once (by scenario) can convert a basic citizen into a mafia member." },

          detective: { name: "Detective", hint: "Night inquiry", desc: "Each night can check a playerâ€™s side (scenario rules apply)." },
          investigator: { name: "Inspector", hint: "Interrogation", desc: "Once per game (in some scenarios) can interrogate (details vary)." },
          doctor: { name: "Doctor", hint: "Night save", desc: "Each night can save a player from the night shot. Self-save is usually limited." },
          watson: { name: "Dr. Watson", hint: "Save", desc: "In Godfather scenario, acts as the city Doctor (table rules apply)." },
          researcher: { name: "Researcher", hint: "Link", desc: "Can link to a player; if the Researcher is eliminated, the linked player may also be eliminated (rules vary)." },
          invulnerable: { name: "Invulnerable", hint: "Night armor", desc: "Typically cannot be killed by the mafiaâ€™s night shot; eliminated via vote/special rules." },
          armored: { name: "Armored", hint: "Armor + return", desc: "Typically survives night shots; if voted out, role reveals and returns (rules vary)." },
          sniper: { name: "Sniper", hint: "Limited shot", desc: "Usually has one shot. If shoots a citizen, the Sniper is eliminated (even if saved)." },
          professional: { name: "Professional", hint: "Shot", desc: "Can shoot at night; if shoots a citizen by mistake, is eliminated." },
          reporter: { name: "Reporter", hint: "Negotiation inquiry", desc: "In negotiator scenario, gets inquiry about negotiated player (rules vary)." },
          representative: { name: "Representative", hint: "Day power", desc: "Scenario-defined role; exact rules depend on the version." },
          hardJohn: { name: "Hard John", hint: "Extra life", desc: "Usually survives the first mafia shot. Often has limited status inquiries (rules vary)." },
          psychologist: { name: "Psychiatrist", hint: "Mute", desc: "Usually can remove a playerâ€™s ability to talk a limited number of times." },
          mayor: { name: "Mayor", hint: "Veto/out", desc: "Once may veto a vote or directly eliminate a defendant (rules vary)." },
          seller: { name: "Seller", hint: "Remove ability", desc: "Once can remove a playerâ€™s ability for the rest of the game (rules vary)." },
          priest: { name: "Priest", hint: "Support talk", desc: "Chooses players to get extra talk time; may neutralize silence effects (rules vary)." },
          judge: { name: "Judge", hint: "Change vote", desc: "Once may change/void a vote result (rules vary)." },
          commander: { name: "Commander", hint: "Confirm shot", desc: "After the Sniper shoots, can confirm or cancel the shot (scenario rules apply)." },

          danMafia: { name: "Mafia Don", hint: "Leader + antidote", desc: "Mafia leader. Often shows negative to Detective; may have an antidote and trading powers (scenario rules apply)." },
          witch: { name: "Witch", hint: "Copy ability", desc: "Chooses a citizen; if they have an ability, it is applied to the Witch (scenario rules apply)." },
          executioner: { name: "Executioner", hint: "Guess a role", desc: "Like NATO: if the exact role guess is correct, the target is eliminated (scenario rules apply)." },
          informant: { name: "Informant", hint: "Spy", desc: "Mafia spy. If awakened by Kadkhoda, can wake like a citizen (scenario rules apply)." },
          kadkhoda: { name: "Kadkhoda", hint: "City link", desc: "Can link two players to a â€˜citizen linkâ€™ (rules vary by scenario)." },
          heir: { name: "Heir", hint: "Inherit role", desc: "Selects a player; may inherit certain abilities if that player is eliminated (scenario rules apply)." },
          herbalist: { name: "Herbalist", hint: "Poison + antidote", desc: "Has one poison and one antidote; poisoning and antidote resolution depends on scenario rules." },
          armorsmith: { name: "Armorsmith", hint: "One-time save", desc: "Once per game can save themselves (scenario rules apply)." },
          suspect: { name: "Suspect", hint: "Positive inquiry", desc: "Citizen, but shows as â€˜mafiaâ€™ to the Detective (scenario rules apply)." },

          alcapone: { name: "Al Capone", hint: "Leader", desc: "Mafia leader; typically shows negative to Detective (Zodiac scenario rules apply)." },
          zodiac: { name: "Zodiac", hint: "Even-night shot", desc: "Independent. Often can shoot on even nights; usually cannot be killed by night shot (rules vary)." },
          magician: { name: "Magician", hint: "Disable ability", desc: "Chooses a city player and disables their ability (rules vary)." },
          bomber: { name: "Bomber", hint: "Bomb", desc: "Once can plant a bomb with a code; target survives only if guessing correctly (rules vary)." },
          guard: { name: "Guard", hint: "Anti-bomb", desc: "Can sacrifice to protect a bomb target and guess the disarm code (rules vary)." },
          ocean: { name: "Ocean", hint: "Wake citizens", desc: "Limited times can wake some citizens to consult; waking mafia/Zodiac incorrectly may eliminate Ocean (rules vary)." },
          gunslinger: { name: "Gunslinger", hint: "Give guns", desc: "Gives guns at night; recipients may use them during the day (rules vary)." },

          leon: { name: "Leon", hint: "City pro", desc: "Key city role in Godfather scenario (table rules apply)." },
          constantine: { name: "Constantine", hint: "Revive", desc: "May revive a player (table rules apply)." },
          citizenKane: { name: "Citizen Kane", hint: "Reveal", desc: "Once can mark a player; if mafia, their side may be announced (rules vary)." },
          nostradamus: { name: "Nostradamus", hint: "Intro night", desc: "Only wakes on the intro night, marks 3 players; host reveals how many mafia among them (rules vary)." },
        };

        function teamKeyFromFa(teamFa) {
          if (teamFa === "Ù…Ø§ÙÛŒØ§") return "mafia";
          if (teamFa === "Ø´Ù‡Ø±") return "city";
          return "independent";
        }
        function teamLabel(teamFa) {
          return t("teams." + teamKeyFromFa(teamFa));
        }
        function roleName(roleId) {
          const r = roles[roleId];
          if (!r) return roleId;
          if (appLang === "fa") return r.faName || roleId;
          return (ROLE_I18N[roleId] && ROLE_I18N[roleId].name) ? ROLE_I18N[roleId].name : (r.faName || roleId);
        }
        function roleHint(roleId) {
          const r = roles[roleId];
          if (!r) return "";
          if (appLang === "fa") return r.hintFa || "";
          return (ROLE_I18N[roleId] && ROLE_I18N[roleId].hint) ? ROLE_I18N[roleId].hint : (r.hintFa || "");
        }
        function roleDesc(roleId, scenario) {
          const rBase = roles[roleId];
          const rOv = (roleScenarioOverrides[roleId] && roleScenarioOverrides[roleId][scenario]) ? roleScenarioOverrides[roleId][scenario] : null;
          const r = rBase ? { ...rBase, ...(rOv || {}) } : null;
          if (!r) return (appLang === "fa") ? "ØªÙˆØ¶ÛŒØ­ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ù†Ù‚Ø´ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª." : "No description is available for this role.";
          if (appLang === "fa") return r.descFa || "ØªÙˆØ¶ÛŒØ­ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ù†Ù‚Ø´ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.";
          if (rOv && rOv.descEn) return rOv.descEn;
          if (ROLE_I18N[roleId] && ROLE_I18N[roleId].desc) return ROLE_I18N[roleId].desc;
          return r.descFa || "No description is available for this role.";
        }

        // Per-scenario overrides for role texts (same role, different rules).
        // This is only UI/help text; actual game rules are still handled by the narrator/table.
        const roleScenarioOverrides = {
          godfather: {
            pedarkhande: {
              descFa: "Ø¯Ø± Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡ ÛŒÚ© Ø¬Ù„ÛŒÙ‚Ù‡ Ø¯Ø§Ø±Ø¯ Ùˆ Â«Ø­Ø³ Ø´Ø´Ù…Â» Ø¯Ø§Ø±Ø¯. ØªÛŒÙ… Ù…Ø§ÙÛŒØ§ Ù‡Ø± Ø´Ø¨ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ ÛŒÚ©ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯: ÛŒØ§ Ø´Ù„ÛŒÚ©ØŒ ÛŒØ§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø­Ø³ Ø´Ø´Ù…ØŒ ÛŒØ§ Ø®Ø±ÛŒØ¯ ØªÙˆØ³Ø· Ø³Ø§ÙˆÙ„ (Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ø³Ù†Ø§Ø±ÛŒÙˆ).",
            },
            shab_mafia: {
              descFa: "Ø¯Ø± Â«Ø´Ø¨â€ŒÙ‡Ø§ÛŒ Ù…Ø§ÙÛŒØ§Â»ØŒ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡/Ø¢Ù„â€ŒÚ©Ø§Ù¾ÙˆÙ† Ø´Ù„ÛŒÚ©Ù Ø´Ø¨ Ø±Ø§ ØªØ¹ÛŒÛŒÙ† Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ùˆ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Â«Ø´Ù‡Ø±ÙˆÙ†Ø¯Â» Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.",
            },
          },
          matador: {
            pedarkhande: {
              descFa: "Ø´Ø¨â€ŒÙ‡Ø§ Ø¨Ø§ ØªÛŒÙ… Ù…Ø§ÙÛŒØ§ Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ù‡Ø± Ø´Ø¨ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ù†Ø´Ø§Ù† Ú©Ù†Ø¯ ØªØ§ ØªÙˆØ§Ù†Ø§ÛŒÛŒ Ø´Ø¨Ù Ø§Ùˆ Ù‡Ù…Ø§Ù† Ø´Ø¨ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´ÙˆØ¯Ø› Ø§Ú¯Ø± Ø¢Ù† ÙØ±Ø¯ Ø¨ÛŒØ¯Ø§Ø± Ø´ÙˆØ¯ Ø¨Ø§ Ø¹Ù„Ø§Ù…Øª Ø¶Ø±Ø¨Ø¯Ø± Ú¯Ø±Ø¯Ø§Ù†Ù†Ø¯Ù‡ Ù…ÙˆØ§Ø¬Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡).",
            },
          },
          saulGoodman: {
            pedarkhande: {
              descFa: "Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ ÙÙ‚Ø· ÛŒÚ©â€ŒØ¨Ø§Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÛŒÚ© Â«Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø³Ø§Ø¯Ù‡Â» Ø±Ø§ Ø¨Ø®Ø±Ø¯ Ùˆ Ø¨Ù‡ Â«Ù…Ø§ÙÛŒØ§ Ø³Ø§Ø¯Ù‡Â» ØªØ¨Ø¯ÛŒÙ„ Ú©Ù†Ø¯Ø› Ø¯Ø± Ø´Ø¨ÛŒ Ú©Ù‡ Ø®Ø±ÛŒØ¯ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŒ Ú¯Ø±Ø¯Ø§Ù†Ù†Ø¯Ù‡ Ø§Ø¹Ù„Ø§Ù… Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ø®Ø±ÛŒØ¯Ø§Ø±ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡).",
            },
          },
          watson: {
            pedarkhande: {
              descFa: "Ù…Ø«Ù„ Ù¾Ø²Ø´Ú© Ø¹Ù…Ù„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯: Ù‡Ø± Ø´Ø¨ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¬Ø§Ù† ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ù†Ø¬Ø§Øª Ø¯Ù‡Ø¯ Ùˆ Ø¬Ø§Ù† Ø®ÙˆØ¯Ø´ Ø±Ø§ ÙÙ‚Ø· ÛŒÚ©â€ŒØ¨Ø§Ø± Ø¯Ø± Ú©Ù„ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù†Ø¬Ø§Øª Ø¯Ù‡Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡).",
            },
          },
          leon: {
            pedarkhande: {
              descFa: "Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ (Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ø³Ù†Ø§Ø±ÛŒÙˆ) Ù…Ø­Ø¯ÙˆØ¯ Ø´Ù„ÛŒÚ© Ú©Ù†Ø¯Ø› Ø§Ú¯Ø± Ø¨Ù‡ Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø´Ù„ÛŒÚ© Ú©Ù†Ø¯ØŒ Ø®ÙˆØ¯Ø´ Ú©Ø´ØªÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¯Ú©ØªØ± Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø§Ùˆ Ø±Ø§ Ù†Ø¬Ø§Øª Ø¯Ù‡Ø¯. ÛŒÚ© Ø¬Ù„ÛŒÙ‚Ù‡ Ù‡Ù… Ø¯Ø§Ø±Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡).",
            },
          },
          citizenKane: {
            pedarkhande: {
              descFa: "Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ ÛŒÚ©â€ŒØ¨Ø§Ø± ÛŒÚ© Ù†ÙØ± Ø±Ø§ Ø¨Ù‡ Ú¯Ø±Ø¯Ø§Ù†Ù†Ø¯Ù‡ Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯Ø› Ø§Ú¯Ø± Ù…Ø§ÙÛŒØ§ Ø¨Ø§Ø´Ø¯ØŒ ØµØ¨Ø­ Ø³Ø§ÛŒØ¯/Ù…Ø§ÙÛŒØ§ Ø¨ÙˆØ¯Ù† Ø§Ùˆ Ø§Ø¹Ù„Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø¨Ø¯ÙˆÙ† Ø®Ø±ÙˆØ¬ ÙÙˆØ±ÛŒ). Ø¯Ø± Ø¨Ø¹Ø¶ÛŒ Ù‚ÙˆØ§Ù†ÛŒÙ† Ø§Ú¯Ø± Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø´ Ø¯Ø±Ø³Øª Ø¨Ø§Ø´Ø¯ØŒ Ø´Ø¨ Ø¨Ø¹Ø¯ Ø®ÙˆØ¯Ù Ú©ÛŒÙ† Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ø³Ù†Ø§Ø±ÛŒÙˆ).",
            },
          },
          constantine: {
            pedarkhande: {
              descFa: "ÛŒÚ©â€ŒØ¨Ø§Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÛŒÚ©ÛŒ Ø§Ø² Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø§Ø®Ø±Ø§Ø¬ÛŒ (Ø¯Ø± ØµÙˆØ±ØªÛŒ Ú©Ù‡ Ù†Ù‚Ø´ Ø§Ùˆ Ø§ÙØ´Ø§ Ù†Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯) Ø±Ø§ Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡).",
            },
          },
          nostradamus: {
            pedarkhande: {
              descFa: "ÙÙ‚Ø· Ø´Ø¨ Ù…Ø¹Ø§Ø±ÙÙ‡ Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯. Û³ Ù†ÙØ± Ø±Ø§ Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ùˆ Ú¯Ø±Ø¯Ø§Ù†Ù†Ø¯Ù‡ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§Ù‡Ø§ÛŒ Ø¯Ø§Ø®Ù„ Ø§ÛŒÙ† Û³ Ù†ÙØ± Ø±Ø§ Ø§Ø¹Ù„Ø§Ù… Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ø³Ù¾Ø³ Ù†ÙˆØ³ØªØ±Ø§Ø¯Ø§Ù…ÙˆØ³ Ø³Ø§ÛŒØ¯ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†Ø¯Ø› Ø§Ú¯Ø± Ø¨ÛŒÙ† Û³ Ù†ÙØ±ØŒ Û² Ù…Ø§ÙÛŒØ§ Ø¨Ø§Ø´Ø¯ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ù…Ø¬Ø¨ÙˆØ± Ø§Ø³Øª Ø¯Ø± Ø³Ø§ÛŒØ¯ Ù…Ø§ÙÛŒØ§ Ø¨Ø§Ø²ÛŒ Ú©Ù†Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡).",
            },
          },
          swindler: {
            // "Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ùˆ Ù…Ø§ÙÛŒØ§" / TV-style: Shayad (Charlatan)
            bazras: {
              descFa: "Ù‡Ø± Ø´Ø¨ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Â«Ù…ÛŒâ€ŒØ²Ù†Ø¯Â». Ø§Ú¯Ø± Ø¨Ù‡ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø¨Ø²Ù†Ø¯ØŒ Ø§Ø³ØªØ¹Ù„Ø§Ù…Ù Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ (ØªØ§ Ù¾Ø§ÛŒØ§Ù† Ø§Ø«Ø±/Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ù…ÛŒØ²) Â«Ù…Ù†ÙÛŒÂ» Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø´ÛŒØ§Ø¯ Ø¨Ø§ ØªÛŒÙ… Ù…Ø§ÙÛŒØ§ Ø¢Ø´Ù†Ø§Ø³Øª Ùˆ Ø´Ø¨â€ŒÙ‡Ø§ Ø¨Ø¹Ø¯ Ø§Ø² Ø¨ÛŒØ¯Ø§Ø±ÛŒ Ù…Ø§ÙÛŒØ§ØŒ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¨Ù‡ ØªÙ†Ù‡Ø§ÛŒÛŒ Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ú©Ø§Ø±Ø´ Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.",
            },
            namayande: {
              descFa: "Ù‡Ø± Ø´Ø¨ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Â«Ù…ÛŒâ€ŒØ²Ù†Ø¯Â». Ø§Ú¯Ø± Ø¨Ù‡ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø¨Ø²Ù†Ø¯ØŒ Ø§Ø³ØªØ¹Ù„Ø§Ù…Ù Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ (ØªØ§ Ù¾Ø§ÛŒØ§Ù† Ø§Ø«Ø±/Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ù…ÛŒØ²) Â«Ù…Ù†ÙÛŒÂ» Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø´ÛŒØ§Ø¯ Ø¨Ø§ ØªÛŒÙ… Ù…Ø§ÙÛŒØ§ Ø¢Ø´Ù†Ø§Ø³Øª Ùˆ Ø´Ø¨â€ŒÙ‡Ø§ Ø¨Ø¹Ø¯ Ø§Ø² Ø¨ÛŒØ¯Ø§Ø±ÛŒ Ù…Ø§ÙÛŒØ§ØŒ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¨Ù‡ ØªÙ†Ù‡Ø§ÛŒÛŒ Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ú©Ø§Ø±Ø´ Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.",
            },
            mozaker: {
              descFa: "Ù‡Ø± Ø´Ø¨ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Â«Ù…ÛŒâ€ŒØ²Ù†Ø¯Â». Ø§Ú¯Ø± Ø¨Ù‡ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø¨Ø²Ù†Ø¯ØŒ Ø§Ø³ØªØ¹Ù„Ø§Ù…Ù Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ (ØªØ§ Ù¾Ø§ÛŒØ§Ù† Ø§Ø«Ø±/Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ù…ÛŒØ²) Â«Ù…Ù†ÙÛŒÂ» Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø´ÛŒØ§Ø¯ Ø¨Ø§ ØªÛŒÙ… Ù…Ø§ÙÛŒØ§ Ø¢Ø´Ù†Ø§Ø³Øª Ùˆ Ø´Ø¨â€ŒÙ‡Ø§ Ø¨Ø¹Ø¯ Ø§Ø² Ø¨ÛŒØ¯Ø§Ø±ÛŒ Ù…Ø§ÙÛŒØ§ØŒ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¨Ù‡ ØªÙ†Ù‡Ø§ÛŒÛŒ Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ú©Ø§Ø±Ø´ Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.",
            },
            takavar: {
              descFa: "Ù‡Ø± Ø´Ø¨ ÛŒÚ© Ù†ÙØ± Ø±Ø§ Â«Ù…ÛŒâ€ŒØ²Ù†Ø¯Â». Ø§Ú¯Ø± Ø¨Ù‡ Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø¨Ø²Ù†Ø¯ØŒ Ø§Ø³ØªØ¹Ù„Ø§Ù…Ù Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ (ØªØ§ Ù¾Ø§ÛŒØ§Ù† Ø§Ø«Ø±/Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ù…ÛŒØ²) Â«Ù…Ù†ÙÛŒÂ» Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø´ÛŒØ§Ø¯ Ø¨Ø§ ØªÛŒÙ… Ù…Ø§ÙÛŒØ§ Ø¢Ø´Ù†Ø§Ø³Øª Ùˆ Ø´Ø¨â€ŒÙ‡Ø§ Ø¨Ø¹Ø¯ Ø§Ø² Ø¨ÛŒØ¯Ø§Ø±ÛŒ Ù…Ø§ÙÛŒØ§ØŒ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¨Ù‡ ØªÙ†Ù‡Ø§ÛŒÛŒ Ø¨ÛŒØ¯Ø§Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ú©Ø§Ø±Ø´ Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.",
            },
          },
          nato: {
            takavar: {
              descFa: "Ù†Ø§ØªÙˆ Ø¯Ø± Ø·ÙˆÙ„ Ø¨Ø§Ø²ÛŒ ÙÙ‚Ø· ÛŒÚ© Ø´Ø¨ (Ø¨Ø§ ØªØ£ÛŒÛŒØ¯ Ø±Ø¦ÛŒØ³ Ù…Ø§ÙÛŒØ§) Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù†Ù‚Ø´ Ø¯Ù‚ÛŒÙ‚Ù ÛŒÚ©ÛŒ Ø§Ø² Ø´Ù‡Ø±ÙˆÙ†Ø¯Ù‡Ø§ Ø±Ø§ Ø­Ø¯Ø³ Ø¨Ø²Ù†Ø¯. Ø§Ú¯Ø± Ø¯Ø±Ø³Øª Ø­Ø¯Ø³ Ø¨Ø²Ù†Ø¯ Ø¢Ù† Ù†Ù‚Ø´ Ø¯Ø± Ù‡Ø± ØµÙˆØ±Øª Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ø§Ú¯Ø± Ø§Ø´ØªØ¨Ø§Ù‡ Ø­Ø¯Ø³ Ø¨Ø²Ù†Ø¯ØŒ Ú©Ø³ÛŒ Ø®Ø§Ø±Ø¬ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø¯Ø± Ø´Ø¨ Ù†Ø§ØªÙˆ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø´Ù„ÛŒÚ© Ø§Ù†Ø¬Ø§Ù… Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ø¨Ø±Ø®ÛŒ Ù†Ù‚Ø´â€ŒÙ‡Ø§ Ø¨ÛŒØ¯Ø§Ø± Ù†Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ (Ø·Ø¨Ù‚ Ø³Ù†Ø§Ø±ÛŒÙˆ).",
            },
          },
          negotiator: {
            mozaker: {
              descFa: "Ø§Ú¯Ø± ÛŒÚ© ÛŒØ§ Ø¯Ùˆ Ù†ÙØ± Ø§Ø² Ø§Ø¹Ø¶Ø§ÛŒ Ù…Ø§ÙÛŒØ§ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ù†Ø¯ØŒ Ù…Ø°Ø§Ú©Ø±Ù‡â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¯Ø± Ø´Ø¨ Ù…Ø°Ø§Ú©Ø±Ù‡ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡Ø¯ Ùˆ ÛŒÚ© Ø´Ù‡Ø±ÙˆÙ†Ø¯ Ø³Ø§Ø¯Ù‡ ÛŒØ§ Ø²Ø±Ù‡â€ŒÙ¾ÙˆØ´Ù Ø²Ø±Ù‡â€ŒØ¯Ø§Ø± Ø±Ø§ Ø¨Ù‡ Ù…Ø§ÙÛŒØ§ÛŒ Ø³Ø§Ø¯Ù‡ ØªØ¨Ø¯ÛŒÙ„ Ú©Ù†Ø¯. Ø§Ú¯Ø± Ù†Ù‚Ø´ Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†Ø¯ Ù…Ø°Ø§Ú©Ø±Ù‡ Ø´Ú©Ø³Øª Ù…ÛŒâ€ŒØ®ÙˆØ±Ø¯. Ø¯Ø± Ø´Ø¨ Ù…Ø°Ø§Ú©Ø±Ù‡ØŒ Ù…Ø§ÙÛŒØ§ Ø­Ù‚ Ø´Ù„ÛŒÚ© Ù†Ø¯Ø§Ø±Ø¯.",
            },
          },
          investigator: {
            bazras: {
              descFa: "Ø¨Ø§Ø²Ù¾Ø±Ø³ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ ÛŒÚ©â€ŒØ¨Ø§Ø± Ø¯Ø± Ø·ÙˆÙ„ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¯Ùˆ Ù†ÙØ± Ø±Ø§ Ø¨Ù‡ Ø¯ÙØ§Ø¹ÛŒÙ‡ Ø¨ÛŒØ§ÙˆØ±Ø¯ (Ø¨Ø§Ø²Ù¾Ø±Ø³ÛŒ). Ø¢Ù† Ø¯Ùˆ Ù†ÙØ± Ù…Ø¯Øª Ú©ÙˆØªØ§Ù‡ÛŒ ØµØ­Ø¨Øª Ù…ÛŒâ€ŒÚ©Ù†Ù†Ø¯ Ùˆ Ø³Ù¾Ø³ (Ø·Ø¨Ù‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ù…ÛŒØ²) Ù…Ø´Ø®Øµ Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ø±Ø£ÛŒâ€ŒÚ¯ÛŒØ±ÛŒ Ù…ÛŒØ§Ù† Ø¢Ù†â€ŒÙ‡Ø§ Ø§Ù†Ø¬Ø§Ù… Ø´ÙˆØ¯ ÛŒØ§ Ù†Ù‡.",
            },
          },
          researcher: {
            bazras: {
              descFa: "Ù…Ø­Ù‚Ù‚ (Ù‡Ø§Ù†ØªØ±): Ø¨Ù‡â€ŒØ¬Ø² Ø´Ø¨ Ù…Ø¹Ø§Ø±ÙÙ‡ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù‡Ø± Ø´Ø¨ Ø®ÙˆØ¯Ø´ Ø±Ø§ Ø¨Ù‡ ÛŒÚ© Ù†ÙØ± Â«Ú¯Ø±Ù‡Â» Ø¨Ø²Ù†Ø¯. Ø§Ú¯Ø± Ø¨Ø§ Ø´Ø§Øª Ø´Ø¨ ÛŒØ§ Ø±ÙˆØ²Ù Ø±Ø£ÛŒâ€ŒÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´ÙˆØ¯ØŒ Ø¢Ù† Ù†ÙØ± Ù‡Ù… Ø¨Ø§ Ø§Ùˆ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ù…ÛŒâ€ŒØ´ÙˆØ¯Ø› Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø§Ú¯Ø± Ø±Ø¦ÛŒØ³ Ù…Ø§ÙÛŒØ§ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ØŒ Ø±Ø¦ÛŒØ³ Ù…Ø§ÙÛŒØ§ Ø¨ÛŒØ±ÙˆÙ† Ù†Ù…ÛŒâ€ŒØ±ÙˆØ¯.",
            },
          },
        };

        const toggleDefs = [
          // mafia
          { key: "mafiaBoss", roleId: "mafiaBoss", group: "mafia" },
          { key: "godfather", roleId: "godfather", group: "mafia" },
          { key: "alcapone", roleId: "alcapone", group: "mafia" },
          { key: "danMafia", roleId: "danMafia", group: "mafia" },
          { key: "doctorLecter", roleId: "doctorLecter", group: "mafia" },
          { key: "jokerMafia", roleId: "jokerMafia", group: "mafia" },
          { key: "swindler", roleId: "swindler", group: "mafia" },
          { key: "nato", roleId: "nato", group: "mafia" },
          { key: "negotiator", roleId: "negotiator", group: "mafia" },
          { key: "natasha", roleId: "natasha", group: "mafia" },
          { key: "matador", roleId: "matador", group: "mafia" },
          { key: "saulGoodman", roleId: "saulGoodman", group: "mafia" },
          { key: "witch", roleId: "witch", group: "mafia" },
          { key: "executioner", roleId: "executioner", group: "mafia" },
          { key: "informant", roleId: "informant", group: "mafia" },
          { key: "magician", roleId: "magician", group: "mafia" },
          { key: "bomber", roleId: "bomber", group: "mafia" },

          // city
          { key: "detective", roleId: "detective", group: "city" },
          { key: "investigator", roleId: "investigator", group: "city" },
          { key: "doctor", roleId: "doctor", group: "city" },
          { key: "watson", roleId: "watson", group: "city" },
          { key: "researcher", roleId: "researcher", group: "city" },
          { key: "invulnerable", roleId: "invulnerable", group: "city" },
          { key: "armored", roleId: "armored", group: "city" },
          { key: "sniper", roleId: "sniper", group: "city" },
          { key: "professional", roleId: "professional", group: "city" },
          { key: "reporter", roleId: "reporter", group: "city" },
          { key: "representative", roleId: "representative", group: "city" },
          { key: "hardJohn", roleId: "hardJohn", group: "city" },
          { key: "psychologist", roleId: "psychologist", group: "city" },
          { key: "mayor", roleId: "mayor", group: "city" },
          { key: "seller", roleId: "seller", group: "city" },
          { key: "priest", roleId: "priest", group: "city" },
          { key: "judge", roleId: "judge", group: "city" },
          { key: "commander", roleId: "commander", group: "city" },
          { key: "kadkhoda", roleId: "kadkhoda", group: "city" },
          { key: "heir", roleId: "heir", group: "city" },
          { key: "herbalist", roleId: "herbalist", group: "city" },
          { key: "armorsmith", roleId: "armorsmith", group: "city" },
          { key: "suspect", roleId: "suspect", group: "city" },
          { key: "guard", roleId: "guard", group: "city" },
          { key: "ocean", roleId: "ocean", group: "city" },
          { key: "gunslinger", roleId: "gunslinger", group: "city" },
          { key: "leon", roleId: "leon", group: "city" },
          { key: "constantine", roleId: "constantine", group: "city" },
          { key: "citizenKane", roleId: "citizenKane", group: "city" },
          
          // independent
          { key: "zodiac", roleId: "zodiac", group: "independent" },
          { key: "nostradamus", roleId: "nostradamus", group: "independent" },
        ];

        // Importance rank for roles (lower = more important).
        // Used to order roles in UI lists (cast + setup roles).
        const ROLE_RANK = {
          // --- mafia ---
          mafiaBoss: 1,
          godfather: 2,
          danMafia: 3,
          alcapone: 4,
          doctorLecter: 5,
          natasha: 6,
          negotiator: 7,
          matador: 8,
          swindler: 9,
          bomber: 10,
          magician: 11,
          nato: 12,
          jokerMafia: 13,
          saulGoodman: 14,
          informant: 15,
          witch: 16,
          executioner: 17,
          mafia: 999,

          // --- city ---
          mayor: 1,
          judge: 2,
          commander: 3,
          representative: 4,
          detective: 5,
          investigator: 6,
          doctor: 7,
          watson: 8,
          constantine: 9,
          citizenKane: 10,
          sniper: 11,
          professional: 12,
          leon: 13,
          guard: 14,
          hardJohn: 15,
          invulnerable: 16,
          armored: 17,
          psychologist: 18,
          reporter: 19,
          kadkhoda: 20,
          heir: 21,
          herbalist: 22,
          armorsmith: 23,
          suspect: 24,
          seller: 25,
          priest: 26,
          ocean: 27,
          gunslinger: 28,
          researcher: 29,
          citizen: 999,

          // --- independent ---
          zodiac: 1,
          nostradamus: 4,
        };

        function roleRank(rid) {
          return (ROLE_RANK[rid] != null) ? ROLE_RANK[rid] : 500;
        }

        // Which special roles are even available per scenario.
        // If a key isn't present, we assume "all roles allowed" (so the UI won't unexpectedly hide roles).
        const scenarioRoleAllowList = {
          // Sources used:
          // - Classic: gorgine.com/scenarios/classic/
          // - Shab Mafia: gorgine.com/scenarios/mafia-nights/
          // - Zodiac: whitesho.com/ZodiacScenario/...
          // - Capo/Den: whitesho.com/MafiaCapo/...
          // - Bazras (Inspector): common "Ø¨Ø§Ø²Ù¾Ø±Ø³/New TV" role set (multiple Persian sources)

          classic: ["mafiaBoss", "detective", "doctor"],

          // Ø¨Ø§Ø²Ù¾Ø±Ø³ (New TV / Inspector)
          bazras: ["mafiaBoss", "nato", "swindler", "detective", "doctor", "investigator", "researcher", "sniper"],

          // Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡ (limited info online; keep a light pack)
          namayande: ["mafiaBoss", "detective", "doctor", "representative"],

          // Ù…Ø°Ø§Ú©Ø±Ù‡ (Negotiation)
          mozaker: ["mafiaBoss", "negotiator", "detective", "doctor", "armored", "reporter", "sniper"],
          "mozakerÙ‡": ["mafiaBoss", "negotiator", "detective", "doctor", "armored", "reporter", "sniper"],

          // ØªÚ©Ø§ÙˆØ± (sniper-heavy classic)
          takavar: ["mafiaBoss", "detective", "doctor", "sniper"],

          // Ú©Ø§Ù¾Ùˆ (Capo/Den)
          kabo: ["danMafia", "witch", "executioner", "informant", "detective", "kadkhoda", "heir", "herbalist", "armorsmith", "suspect"],

          // Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡ (game)
          pedarkhande: ["godfather", "matador", "saulGoodman", "watson", "leon", "citizenKane", "constantine", "nostradamus"],

          // Ø²ÙˆØ¯ÛŒØ§Ú©
          zodiac: ["alcapone", "zodiac", "magician", "bomber", "detective", "doctor", "professional", "guard", "ocean", "gunslinger"],

          // Ù…ÛŒØªÛŒÙ†Ú¯/Ø§Ù¾ÛŒÚ© Ùˆ Ù¾ÛŒØ´Ø±ÙØªÙ‡ (approx. "advanced classic" subset)
          meeting_epic: ["mafiaBoss", "nato", "natasha", "doctorLecter", "detective", "doctor", "sniper", "armored", "judge", "commander", "priest"],
          pishrafte: ["mafiaBoss", "godfather", "doctorLecter", "jokerMafia", "nato", "natasha", "swindler", "detective", "doctor", "sniper", "professional", "armored", "invulnerable", "judge", "commander", "priest", "researcher", "investigator"],

          // Ø´Ø¨ Ù…Ø§ÙÛŒØ§ (ÙÛŒÙ„ÛŒÙ…Ùˆ)
          shab_mafia: ["godfather", "doctorLecter", "jokerMafia", "detective", "doctor", "professional", "hardJohn", "psychologist", "mayor", "seller"],
        };

        function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
        function shuffle(arr) {
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        function computeSuggestedMafia(nPlayers) {
          // classic-ish: ~1/4 (step function, good up to 30 players)
          if (nPlayers <= 6) return 1;
          if (nPlayers <= 9) return 2;
          if (nPlayers <= 12) return 3;
          if (nPlayers <= 16) return 4;
          if (nPlayers <= 20) return 5;
          if (nPlayers <= 24) return 6;
          if (nPlayers <= 28) return 7;
          return 8; // 29-30
        }

        function defaultTogglesForScenario(scenario) {
          // defaults reflect the typical role-set; users can still toggle roles on/off (within scenario allow list)
          const baseOff = Object.fromEntries(toggleDefs.map((d) => [d.key, false]));
          const on = (...keys) => {
            const out = { ...baseOff };
            for (const k of keys) out[k] = true;
            return out;
          };

          switch (scenario) {
            case "classic":
              return on("mafiaBoss", "detective", "doctor");
            case "bazras":
              return on("mafiaBoss", "nato", "swindler", "detective", "doctor", "investigator", "researcher");
            case "namayande":
              return on("mafiaBoss", "detective", "doctor", "representative");
            case "mozaker":
            case "mozakerÙ‡":
              return on("mafiaBoss", "negotiator", "detective", "doctor", "armored", "reporter");
            case "takavar":
              return on("mafiaBoss", "detective", "doctor", "sniper");
            case "kabo":
              return on("danMafia", "witch", "executioner", "detective", "heir", "herbalist", "armorsmith", "suspect");
            case "pedarkhande":
              return on("godfather", "matador", "saulGoodman", "watson", "leon", "citizenKane", "constantine", "nostradamus");
            case "zodiac":
              return on("alcapone", "zodiac", "magician", "bomber", "detective", "doctor", "professional", "guard", "ocean", "gunslinger");
            case "shab_mafia":
              // Common Shab-haye Mafia lineup (12 players). See: fa.wikipedia.org/wiki/Ø´Ø¨â€ŒÙ‡Ø§ÛŒ_Ù…Ø§ÙÛŒØ§
              return on("godfather", "doctorLecter", "jokerMafia", "detective", "doctor", "professional", "hardJohn", "psychologist", "mayor", "seller");
            case "meeting_epic":
              return on("mafiaBoss", "nato", "natasha", "doctorLecter", "detective", "doctor", "sniper", "armored");
            case "pishrafte":
              return on("mafiaBoss", "doctorLecter", "jokerMafia", "nato", "natasha", "detective", "doctor", "sniper", "armored", "professional", "researcher");
            default:
              return on("mafiaBoss", "detective", "doctor");
          }
        }

        function sanitizeScenarioValue(v) {
          const sel = $("scenario");
          if (!sel) return "classic";
          const vv = (v || "").trim();
          const exists = Array.from(sel.options).some((o) => o.value === vv);
          return exists ? vv : "classic";
        }

        function getAllowedToggleKeysForScenario(scenario) {
          const allow = scenarioRoleAllowList[scenario];
          if (!allow) return null; // null means "all allowed"
          return new Set(allow);
        }

        function normalizeTogglesForScenario(toggles, scenario) {
          const allowed = getAllowedToggleKeysForScenario(scenario);
          if (!allowed) return { ...toggles };
          const out = { ...toggles };
          for (const def of toggleDefs) {
            if (!allowed.has(def.key)) out[def.key] = false;
          }
          return out;
        }

        function buildRolePool(nPlayers, mafiaCount, toggles) {
          if (!Number.isFinite(nPlayers) || !Number.isFinite(mafiaCount)) {
            return { ok: false, error: "Ø§Ø¹Ø¯Ø§Ø¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ù‡Ø³ØªÙ†Ø¯." };
          }
          if (nPlayers < 5) return { ok: false, error: "Ø­Ø¯Ø§Ù‚Ù„ Ûµ Ø¨Ø§Ø²ÛŒÚ©Ù† Ù„Ø§Ø²Ù… Ø§Ø³Øª." };
          if (mafiaCount < 1) return { ok: false, error: "ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ Û± Ø¨Ø§Ø´Ø¯." };
          if (mafiaCount >= nPlayers) return { ok: false, error: "ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§ Ø¨Ø§ÛŒØ¯ Ú©Ù…ØªØ± Ø§Ø² ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†â€ŒÙ‡Ø§ Ø¨Ø§Ø´Ø¯." };

          // enforce scenario availability even if state was loaded from storage
          const scenario = $("scenario") ? $("scenario").value : "";
          const safeToggles = normalizeTogglesForScenario(toggles, scenario);

          const mafiaSpecials = [];
          const citySpecials = [];
          const independentSpecials = [];

          for (const def of toggleDefs) {
            if (!safeToggles[def.key]) continue;
            if (def.group === "mafia") mafiaSpecials.push(def.roleId);
            else if (def.group === "city") citySpecials.push(def.roleId);
            else independentSpecials.push(def.roleId);
          }

          if (mafiaSpecials.length > mafiaCount) {
            const exceed = mafiaSpecials.length - mafiaCount;
            const minMafia = mafiaSpecials.length;
            return {
              ok: false,
              error: `Ù†Ù‚Ø´â€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ Ù…Ø§ÙÛŒØ§ Ø²ÛŒØ§Ø¯ Ø§Ø³Øª. ÛŒØ§ ${exceed.toLocaleString("fa-IR")} Ù†Ù‚Ø´ ÙˆÛŒÚ˜Ù‡ Ø±Ø§ Ø®Ø§Ù…ÙˆØ´ Ú©Ù†ÛŒØ¯ØŒ ÛŒØ§ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§ÙÛŒØ§ Ø±Ø§ Ø­Ø¯Ø§Ù‚Ù„ Ø¨Ù‡ ${minMafia.toLocaleString("fa-IR")} Ø¨Ø±Ø³Ø§Ù†ÛŒØ¯.`,
            };
          }

          const pool = [];
          pool.push(...mafiaSpecials);
          pool.push(...Array(Math.max(0, mafiaCount - mafiaSpecials.length)).fill("mafia"));
          pool.push(...citySpecials);
          pool.push(...independentSpecials);

          const remaining = nPlayers - pool.length;
          if (remaining < 0) {
            const minPlayers = pool.length;
            const exceed = minPlayers - nPlayers;
            return {
              ok: false,
              error: `ØªØ¹Ø¯Ø§Ø¯ Ø´Ù‡Ø±ÙˆÙ†Ø¯Ù Ø³Ø§Ø¯Ù‡ Ø¯Ø±Ø³Øª Ù†ÛŒØ³Øª. ÛŒØ§ ${exceed.toLocaleString("fa-IR")} Ù†Ù‚Ø´ ÙˆÛŒÚ˜Ù‡ Ø±Ø§ Ø®Ø§Ù…ÙˆØ´ Ú©Ù†ÛŒØ¯ØŒ ÛŒØ§ ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†â€ŒÙ‡Ø§ Ø±Ø§ Ø­Ø¯Ø§Ù‚Ù„ Ø¨Ù‡ ${minPlayers.toLocaleString("fa-IR")} Ø¨Ø±Ø³Ø§Ù†ÛŒØ¯.`,
            };
          }

          pool.push(...Array(remaining).fill("citizen"));
          shuffle(pool);
          return { ok: true, pool };
        }

        function summarizePool(pool) {
          const c = {};
          for (const r of pool) c[r] = (c[r] || 0) + 1;
          let mafiaTotal = 0;
          let cityTotal = 0;
          let independentTotal = 0;
          for (const rid of pool) {
            const t = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
            if (t === "Ù…Ø§ÙÛŒØ§") mafiaTotal++;
            else if (t === "Ø´Ù‡Ø±") cityTotal++;
            else independentTotal++;
          }
          return { counts: c, mafiaTotal, cityTotal, independentTotal };
        }

        function setError(msg) {
          const boxes = [$("errorBox"), $("errorBoxPlayers")].filter(Boolean);
          for (const box of boxes) {
            if (!msg) {
              box.style.display = "none";
              box.textContent = "";
            } else {
              box.style.display = "block";
              box.textContent = msg;
            }
          }
        }

        function setSaveState(enabled) {
          const el = $("saveState");
          if (!el) return;
          el.textContent = t("saveState.label", { state: enabled ? t("common.on") : t("common.off") });
        }

        function readUIState() {
          const scenario = $("scenario").value;
          const nPlayers = parseInt($("playersCount").value, 10);
          const mafiaCount = parseInt($("mafiaCount").value, 10);
          const toggles = {};
          for (const def of toggleDefs) {
            const wrap = $("tgwrap_" + def.key);
            toggles[def.key] = !!(wrap && wrap.classList.contains("on"));
          }
          return { scenario, nPlayers, mafiaCount, toggles };
        }

        function applyToggles(toggles, { disableMafiaBoss, disableSwindler } = {}) {
          // Enforce constraints by turning off roles when needed.
          if (disableSwindler && toggles) toggles.swindler = false;
          if (disableMafiaBoss && toggles) toggles.mafiaBoss = false;

          for (const def of toggleDefs) {
            const wrap = $("tgwrap_" + def.key);
            if (!wrap) continue;
            const val = !!(toggles && toggles[def.key]);
            wrap.classList.toggle("on", val);
            wrap.setAttribute("aria-pressed", val ? "true" : "false");

            const isDisabled =
              (disableSwindler && def.key === "swindler") ||
              (disableMafiaBoss && def.key === "mafiaBoss");
            wrap.classList.toggle("disabled", !!isDisabled);
            if (isDisabled) wrap.setAttribute("aria-disabled", "true");
            else wrap.removeAttribute("aria-disabled");
          }
        }

        function applyScenarioAvailability(scenario) {
          const allowed = getAllowedToggleKeysForScenario(scenario);
          const visibleCounts = { mafia: 0, city: 0, independent: 0 };
          for (const def of toggleDefs) {
            const wrap = $("tgwrap_" + def.key);
            if (!wrap) continue;
            const isAllowed = !allowed || allowed.has(def.key);
            wrap.style.display = isAllowed ? "flex" : "none";
            if (!isAllowed) {
              // When a role isn't available in this scenario, force it off.
              if (appState && appState.ui && appState.ui.toggles) appState.ui.toggles[def.key] = false;
              wrap.classList.remove("on");
              wrap.setAttribute("aria-pressed", "false");
              wrap.classList.add("disabled");
              wrap.setAttribute("aria-disabled", "true");
            } else {
              // allow interaction; actual constraints are applied via applyToggles()
              wrap.classList.remove("disabled");
              wrap.removeAttribute("aria-disabled");
              if (def.group === "mafia") visibleCounts.mafia++;
              else if (def.group === "city") visibleCounts.city++;
              else visibleCounts.independent++;
            }
          }

          // Team headers: mafia/city always shown (base roles live there). Independent shown only if any role is visible.
          const hdrM = $("teamHdr_mafia");
          const hdrC = $("teamHdr_city");
          const hdrI = $("teamHdr_independent");
          if (hdrM) hdrM.style.display = "flex";
          if (hdrC) hdrC.style.display = "flex";
          if (hdrI) hdrI.style.display = visibleCounts.independent ? "flex" : "none";
        }

        function renderToggles() {
          const host = $("toggles");
          host.innerHTML = "";

          const teamClsForGroup = (g) => (
            g === "mafia" ? "team-mafia" :
            g === "city" ? "team-city" : "team-ind"
          );
          const addHdr = (id, label, teamCls) => {
            const h = document.createElement("div");
            h.className = `teamHdr ${teamCls || ""}`.trim();
            h.id = id;
            h.textContent = label;
            host.appendChild(h);
          };

          const baseCitizen = document.createElement("div");
          baseCitizen.className = "toggle base team-city";
          baseCitizen.id = "base_citizen";
          baseCitizen.innerHTML = `
            <span class="meta">
              <span class="name">${escapeHtml(roleName("citizen"))}</span>
              <span class="hint">${escapeHtml(t("toggles.variableCount"))}</span>
            </span>
            <span class="right">
              <button class="miniHelp" type="button" data-rolehelp="citizen" aria-label="${escapeHtml(t("common.roleHelp"))}">?</button>
              <span class="countpill" id="cnt_citizen">Ã— 0</span>
            </span>
          `;
          const baseMafia = document.createElement("div");
          baseMafia.className = "toggle base team-mafia";
          baseMafia.id = "base_mafia";
          baseMafia.innerHTML = `
            <span class="meta">
              <span class="name">${escapeHtml(roleName("mafia"))}</span>
              <span class="hint">${escapeHtml(t("toggles.variableCount"))}</span>
            </span>
            <span class="right">
              <button class="miniHelp" type="button" data-rolehelp="mafia" aria-label="${escapeHtml(t("common.roleHelp"))}">?</button>
              <span class="countpill" id="cnt_mafia">Ã— 0</span>
            </span>
          `;

          const groupOrder = ["mafia", "city", "independent"];
          const groupLabel = { mafia: t("teams.mafiaTeam"), city: t("teams.cityTeam"), independent: t("teams.independent") };
          const defsByGroup = { mafia: [], city: [], independent: [] };
          for (const def of toggleDefs) {
            if (def.group === "mafia") defsByGroup.mafia.push(def);
            else if (def.group === "city") defsByGroup.city.push(def);
            else defsByGroup.independent.push(def);
          }
          for (const g of groupOrder) {
            addHdr(`teamHdr_${g}`, groupLabel[g] || g, teamClsForGroup(g));
            if (g === "mafia") host.appendChild(baseMafia);
            if (g === "city") host.appendChild(baseCitizen);
            const sorted = defsByGroup[g].slice().sort((a, b) => {
              return (roleRank(a.roleId) - roleRank(b.roleId))
                || String(a.key).localeCompare(String(b.key), "fa");
            });
            for (const def of sorted) {
            const r = roles[def.roleId];
            // If a toggle points to a missing role, skip it (prevents app crash on load)
            if (!r) continue;
            const el = document.createElement("div");
            el.className = `toggle ${teamClsForGroup(g)}`.trim();
            el.id = "tgwrap_" + def.key;
            el.dataset.key = def.key;
            el.setAttribute("role", "button");
            el.setAttribute("tabindex", "0");
            el.setAttribute("aria-pressed", "false");
            el.innerHTML = `
              <span class="meta">
                <span class="name">${escapeHtml(roleName(def.roleId))}</span>
                <span class="hint">${escapeHtml(roleHint(def.roleId))}</span>
              </span>
              <span class="right">
                <button class="miniHelp" type="button" data-rolehelp="${escapeHtml(def.roleId)}" aria-label="${escapeHtml(t("common.roleHelp"))}">?</button>
              </span>
            `;
            host.appendChild(el);
          }
          }
        }

        function fillPlayersSelect() {
          const sel = $("playersCount");
          sel.innerHTML = "";
          for (let n = 5; n <= 30; n++) {
            const opt = document.createElement("option");
            opt.value = String(n);
            opt.textContent = String(n);
            sel.appendChild(opt);
          }
        }

        function fillMafiaSelect(nPlayers, suggested) {
          const sel = $("mafiaCount");
          const current = parseInt(sel.value || String(suggested), 10);
          sel.innerHTML = "";
          const maxMafia = Math.max(1, Math.floor((nPlayers - 1) / 2));
          for (let m = 1; m <= maxMafia; m++) {
            const opt = document.createElement("option");
            opt.value = String(m);
            opt.textContent = String(m);
            sel.appendChild(opt);
          }
          sel.value = String(clamp(current, 1, maxMafia));
        }

        function updateQuickStat() {
          const s = readUIState();
          const res = buildRolePool(s.nPlayers, s.mafiaCount, s.toggles);
          if (!res.ok) {
            const msg = res.error || t("error.config");
            const qs = $("quickStat");
            if (qs) {
              qs.textContent = t("error.quick");
              qs.title = msg;
            }
            // Also show the full error in the setup page error box.
            const box = $("errorBox");
            if (box) {
              box.dataset.src = "config";
              box.style.display = "block";
              box.textContent = msg;
            }
            return;
          }
          const qs = $("quickStat");
          if (qs) qs.title = "";
          // Clear setup error box only if it was set by config validation.
          const box = $("errorBox");
          if (box && box.dataset && box.dataset.src === "config") {
            box.style.display = "none";
            box.textContent = "";
            delete box.dataset.src;
          }
          const sum = summarizePool(res.pool);
          $("quickStat").textContent = sum.independentTotal
            ? t("quickStat.withInd", { m: sum.mafiaTotal, c: sum.cityTotal, i: sum.independentTotal })
            : t("quickStat.noInd", { m: sum.mafiaTotal, c: sum.cityTotal });

          // update base role counters
          const cCitizen = $("cnt_citizen");
          const cMafia = $("cnt_mafia");
          const nCitizen = sum.counts.citizen || 0;
          const nMafia = sum.counts.mafia || 0;
          if (cCitizen) cCitizen.textContent = `Ã— ${nCitizen}`;
          if (cMafia) cMafia.textContent = `Ã— ${nMafia}`;

          // Make base cards look selected when count > 0.
          const baseCitizen = $("base_citizen");
          const baseMafia = $("base_mafia");
          if (baseCitizen) baseCitizen.classList.toggle("on", nCitizen > 0);
          if (baseMafia) baseMafia.classList.toggle("on", nMafia > 0);
        }

        function shouldPersist() {
          try { return !!localStorage; } catch { return false; }
        }

        function loadLastNames() {
          if (!shouldPersist()) return null;
          const raw = localStorage.getItem(LAST_NAMES_KEY);
          if (!raw) return null;
          try {
            const v = JSON.parse(raw);
            return Array.isArray(v) ? v : null;
          } catch {
            return null;
          }
        }

        function saveLastNames(names) {
          if (!shouldPersist()) return;
          localStorage.setItem(LAST_NAMES_KEY, JSON.stringify(names));
        }

        function saveState(state) {
          if (!shouldPersist()) return;
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
          setSaveState(true);
          // Keep the "saved game" bar in sync with state changes.
          try { if (typeof updateResumeUI === "function") updateResumeUI(); } catch {}
        }

        function loadState() {
          if (!shouldPersist()) return null;
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return null;
          try { return JSON.parse(raw); } catch { return null; }
        }

        function clearState() {
          if (!shouldPersist()) return;
          localStorage.removeItem(STORAGE_KEY);
          setSaveState(false);
          try { if (typeof updateResumeUI === "function") updateResumeUI(); } catch {}
        }

        function showSetup() {
          $("playersCard").classList.add("hidden");
          $("setupCard").classList.remove("hidden");
          $("cardsCard").classList.add("hidden");
          $("castCard").classList.add("hidden");
          updateResumeUI();
          window.scrollTo({ top: 0, behavior: "instant" });
        }
        function showPlayers() {
          $("setupCard").classList.add("hidden");
          $("playersCard").classList.remove("hidden");
          $("cardsCard").classList.add("hidden");
          $("castCard").classList.add("hidden");
          window.scrollTo({ top: 0, behavior: "instant" });
        }
        function showCards() {
          $("setupCard").classList.add("hidden");
          $("playersCard").classList.add("hidden");
          $("cardsCard").classList.remove("hidden");
          $("castCard").classList.add("hidden");
          window.scrollTo({ top: 0, behavior: "instant" });
        }
        function showCast() {
          $("setupCard").classList.add("hidden");
          $("playersCard").classList.add("hidden");
          $("cardsCard").classList.add("hidden");
          $("castCard").classList.remove("hidden");
          window.scrollTo({ top: 0, behavior: "instant" });
        }

        function openModal() {
          const m = $("modal");
          m.style.display = "flex";
          m.setAttribute("aria-hidden", "false");
        }
        function closeModal() {
          const m = $("modal");
          m.style.display = "none";
          m.setAttribute("aria-hidden", "true");
        }

        function renderCards() {
          const draw = appState.draw;
          if (!draw || !draw.deck || !draw.players) return;

          const n = draw.players.length;
          const cur = draw.currentIdx || 0;
          const done = cur >= n;

          $("cardsStat").textContent = `${Math.min(cur, n)} / ${n}`;
          $("cardsWho").textContent = done
            ? t("common.done")
            : `${t("common.turn")}: ${((appState.ui.playerNames && appState.ui.playerNames[cur]) ? appState.ui.playerNames[cur] : t("common.playerN", { n: cur + 1 }))}`;

          const nextBtn = $("cardsNextBtn");
          nextBtn.disabled = !done;

          const host = $("cardsGrid");
          host.innerHTML = "";
          for (let i = 0; i < n; i++) {
            const used = !!(draw.usedCards && draw.usedCards[i]);
            const b = document.createElement("button");
            b.type = "button";
            b.className = "cardBtn" + (used ? " used" : "");
            b.textContent = used ? t("common.taken") : t("common.cardN", { n: i + 1 });
            b.disabled = used || done;
            b.addEventListener("click", () => onPickCard(i));
            host.appendChild(b);
          }
        }

        let appState = {
          ui: {
            scenario: "classic",
            nPlayers: 10,
            mafiaCount: 3,
            toggles: defaultTogglesForScenario("classic"),
            playerNames: [],
            customized: false,
            // If user has saved "last names", default to using them.
            namesMode: (function () {
              const last = loadLastNames();
              return (last && last.some((x) => String(x || "").trim())) ? "last" : "default";
            })(), // default | last
          },
          draw: null, // cards mode: { deck, usedCards, players, currentIdx, createdAt, uiAtDraw }
          god: {
            status: null,
            lastMove: null,
            timers: null,
            chance: null,
          },
        };

        function openToolModal(title, bodyHtml, { hideBottom } = {}) {
          $("toolTitle").textContent = title;
          $("toolBody").innerHTML = bodyHtml;
          $("toolBottom").style.display = hideBottom ? "none" : "flex";
          const m = $("toolModal");
          m.style.display = "flex";
          m.setAttribute("aria-hidden", "false");
        }
        function closeToolModal() {
          const m = $("toolModal");
          // If Flow modal is open, auto-save current selections before closing.
          // (This makes closing behave like "Next" in terms of saving.)
          try {
            if (typeof window !== "undefined" && window.__flowOnClose && typeof window.__flowOnClose === "function") {
              window.__flowOnClose();
            }
          } catch {}
          m.style.display = "none";
          m.setAttribute("aria-hidden", "true");
          // After closing any tool (especially Flow), refresh visible UI that depends on flow/player state.
          try { if (typeof renderCast === "function" && $("castCard") && !$("castCard").classList.contains("hidden")) renderCast(); } catch {}
          try { if (typeof renderCast === "function" && $("castCard") && $("castCard").classList.contains("hidden")) renderCast(); } catch {}
          try { if (typeof renderNameGrid === "function" && $("playersCard") && !$("playersCard").classList.contains("hidden")) renderNameGrid(); } catch {}
          try { if (typeof updateQuickStat === "function") updateQuickStat(); } catch {}
          try { if (typeof updateResumeUI === "function") updateResumeUI(); } catch {}
        }

        function getScenario() {
          return (appState.ui && appState.ui.scenario) ? appState.ui.scenario : (($("scenario") && $("scenario").value) || "classic");
        }

        function formatMMSS(sec) {
          const s = Math.max(0, Math.floor(sec));
          const m = Math.floor(s / 60);
          const r = s % 60;
          return String(m).padStart(1, "0") + ":" + String(r).padStart(2, "0");
        }

        function countTeamsFromDraw() {
          const draw = appState.draw;
          if (!draw || !draw.players) {
            return {
              alive: 0, dead: 0, total: 0,
              mafiaAlive: 0, mafiaDead: 0,
              cityAlive: 0, cityDead: 0,
              indAlive: 0, indDead: 0,
            };
          }
          let mafiaAlive = 0, mafiaDead = 0, cityAlive = 0, cityDead = 0, indAlive = 0, indDead = 0;
          for (const p of draw.players) {
            const rid = p.roleId || "citizen";
            const t = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
            const alive = p.alive !== false; // default alive
            if (t === "Ù…Ø§ÙÛŒØ§") {
              if (alive) mafiaAlive++;
              else mafiaDead++;
            } else if (t === "Ø´Ù‡Ø±") {
              if (alive) cityAlive++;
              else cityDead++;
            } else {
              if (alive) indAlive++;
              else indDead++;
            }
          }
          const total = draw.players.length;
          const alive = mafiaAlive + cityAlive + indAlive;
          const dead = mafiaDead + cityDead + indDead;
          return { alive, dead, total, mafiaAlive, mafiaDead, cityAlive, cityDead, indAlive, indDead };
        }

        function syncGodStatusFromPlayers() {
          // `appState.god` can be cleared when starting a new game; ensure it's present before syncing.
          if (!appState.god || typeof appState.god !== "object") appState.god = {};
          appState.god.status = countTeamsFromDraw();
        }

        function getAllowedRoleIdsForScenario() {
          const scenario = getScenario();
          const allowedKeys = scenarioRoleAllowList[scenario] || [];
          const keyToRole = {};
          for (const d of toggleDefs) keyToRole[d.key] = d.roleId;
          const ids = new Set(["citizen", "mafia"]);
          for (const k of allowedKeys) {
            const rid = keyToRole[k] || k; // many lists are keys; some might already be roleIds
            if (roles[rid]) ids.add(rid);
          }
          return Array.from(ids);
        }

        const scenarioWakeOrderFa = {
          classic: ["ØªÛŒÙ… Ù…Ø§ÙÛŒØ§", "Ù¾Ø²Ø´Ú©", "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡"],
          bazras: ["Ù…Ø­Ù‚Ù‚", "Ø´ÛŒØ§Ø¯", "ØªÛŒÙ… Ù…Ø§ÙÛŒØ§", "Ù¾Ø²Ø´Ú©", "ØªÚ©â€ŒØªÛŒØ±Ø§Ù†Ø¯Ø§Ø²", "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡", "Ø¨Ø§Ø²Ù¾Ø±Ø³"],
          namayande: ["ØªÛŒÙ… Ù…Ø§ÙÛŒØ§", "Ù¾Ø²Ø´Ú©", "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡", "Ù†Ù…Ø§ÛŒÙ†Ø¯Ù‡"],
          mozaker: ["ØªÛŒÙ… Ù…Ø§ÙÛŒØ§", "Ù¾Ø²Ø´Ú©", "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡", "Ù…Ø°Ø§Ú©Ø±Ù‡â€ŒÚ©Ù†Ù†Ø¯Ù‡", "Ø®Ø¨Ø±Ù†Ú¯Ø§Ø±"],
          takavar: ["ØªÛŒÙ… Ù…Ø§ÙÛŒØ§", "Ù¾Ø²Ø´Ú©", "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡", "ØªÚ©â€ŒØªÛŒØ±Ø§Ù†Ø¯Ø§Ø²"],
          kabo: ["ÙˆØ§Ø±Ø«", "Ø¹Ø·Ø§Ø±", "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡", "Ø²Ø±Ù‡â€ŒØ³Ø§Ø²", "ØªÛŒÙ… Ù…Ø§ÙÛŒØ§ (Ø¬Ø§Ø¯ÙˆÚ¯Ø±/Ø¯Ù†/Ø¬Ù„Ø§Ø¯)"],
          pedarkhande: ["Ù†ÙˆØ³ØªØ±Ø§Ø¯Ø§Ù…ÙˆØ³ (ÙÙ‚Ø· Ø´Ø¨ Ù…Ø¹Ø§Ø±ÙÙ‡)", "ØªÛŒÙ… Ù…Ø§ÙÛŒØ§ (Ù¾Ø¯Ø±Ø®ÙˆØ§Ù†Ø¯Ù‡/Ù…Ø§ØªØ§Ø¯ÙˆØ±/Ø³Ø§ÙˆÙ„)", "Ø¯Ú©ØªØ± ÙˆØ§ØªØ³ÙˆÙ†", "Ù„Ø¦ÙˆÙ†", "Ù‡Ù…Ø´Ù‡Ø±ÛŒ Ú©ÛŒÙ†", "Ú©Ù†Ø³ØªØ§Ù†ØªÛŒÙ†"],
          // Zodiac: includes Magician (disable) + Bomber (bomb) in addition to core roles.
          zodiac: ["ØªÛŒÙ… Ù…Ø§ÙÛŒØ§", "Ø´Ø¹Ø¨Ø¯Ù‡â€ŒØ¨Ø§Ø²", "Ø¨Ù…Ø¨â€ŒÚ¯Ø°Ø§Ø±", "Ø²ÙˆØ¯ÛŒØ§Ú©", "Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ", "Ù¾Ø²Ø´Ú©", "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡", "ØªÙÙ†Ú¯Ø¯Ø§Ø±", "Ø§ÙˆØ´Ù†"],
          meeting_epic: ["ØªÛŒÙ… Ù…Ø§ÙÛŒØ§", "Ù¾Ø²Ø´Ú©", "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡", "ØªÚ©â€ŒØªÛŒØ±Ø§Ù†Ø¯Ø§Ø²"],
          pishrafte: ["ØªÛŒÙ… Ù…Ø§ÙÛŒØ§", "Ù¾Ø²Ø´Ú©", "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡", "ØªÚ©â€ŒØªÛŒØ±Ø§Ù†Ø¯Ø§Ø²"],
          shab_mafia: ["ØªÛŒÙ… Ù…Ø§ÙÛŒØ§", "Ø¬ÙˆÚ©Ø± Ù…Ø§ÙÛŒØ§", "Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡", "Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ", "Ù¾Ø²Ø´Ú©", "Ø¬Ø§Ù†â€ŒØ³Ø®Øª", "Ø±ÙˆØ§Ù†Ù¾Ø²Ø´Ú©", "Ø´Ù‡Ø±Ø¯Ø§Ø±", "ÙØ±ÙˆØ´Ù†Ø¯Ù‡"],
        };
        const scenarioWakeOrderEn = {
          classic: ["Mafia team", "Doctor", "Detective"],
          bazras: ["Researcher", "Charlatan", "Mafia team", "Doctor", "Sniper", "Detective", "Inspector"],
          namayande: ["Mafia team", "Doctor", "Detective", "Representative"],
          mozaker: ["Mafia team", "Doctor", "Detective", "Negotiator", "Reporter"],
          takavar: ["Mafia team", "Doctor", "Detective", "Sniper"],
          kabo: ["Heir", "Herbalist", "Detective", "Armorsmith", "Mafia team (Witch/Don/Executioner)"],
          pedarkhande: ["Nostradamus (intro night only)", "Mafia team (Godfather/Matador/Saul)", "Dr. Watson", "Leon", "Citizen Kane", "Constantine"],
          zodiac: ["Mafia team", "Magician", "Bomber", "Zodiac", "Professional", "Doctor", "Detective", "Gunslinger", "Ocean"],
          meeting_epic: ["Mafia team", "Doctor", "Detective", "Sniper"],
          pishrafte: ["Mafia team", "Doctor", "Detective", "Sniper"],
          shab_mafia: ["Mafia team", "Mafia Joker", "Detective", "Professional", "Doctor", "Hard John", "Psychiatrist", "Mayor", "Seller"],
        };

        function showWakeTool() {
          const scenario = getScenario();
          const title = t("tool.wake.title");
          const list = (appLang === "en" ? (scenarioWakeOrderEn[scenario] || scenarioWakeOrderFa[scenario] || []) : (scenarioWakeOrderFa[scenario] || []));
          const scenarioName = (($("scenario") && $("scenario").selectedOptions && $("scenario").selectedOptions[0]) ? $("scenario").selectedOptions[0].textContent : scenario);
          const itemsHtml = list.length
            ? `<div class="toolBox"><div style="font-weight:1100;margin-bottom:6px">${escapeHtml(t("tool.wake.scenario", { name: scenarioName }))}</div>${list.map((x, i) => `<div style="padding:6px 0;font-weight:950">${i + 1}. ${escapeHtml(x)}</div>`).join("")}</div>`
            : `<div class="toolBox">${escapeHtml(t("tool.wake.none"))}</div>`;
          openToolModal(title, itemsHtml);
        }

        function showStatusTool() {
          syncGodStatusFromPlayers();
          const s = appState.god.status;
          const out = (s && typeof s.dead === "number") ? s.dead : 0;
          const m = (s && typeof s.mafiaDead === "number") ? s.mafiaDead : 0;
          const c = (s && typeof s.cityDead === "number") ? s.cityDead : 0;
          const i = (s && typeof s.indDead === "number") ? s.indDead : 0;
          const aliveTotal = (s && typeof s.alive === "number") ? s.alive : 0;
          const mA = (s && typeof s.mafiaAlive === "number") ? s.mafiaAlive : 0;
          const cA = (s && typeof s.cityAlive === "number") ? s.cityAlive : 0;
          const iA = (s && typeof s.indAlive === "number") ? s.indAlive : 0;

          const fmtNum = (n) => {
            try {
              const loc = (appLang === "fa") ? "fa-IR" : "en-US";
              return Number(n || 0).toLocaleString(loc);
            } catch {
              return String(n || 0);
            }
          };
          const joinList = (parts) => {
            const xs = (parts || []).filter(Boolean);
            if (xs.length <= 1) return xs[0] || "";
            if (appLang === "fa") {
              if (xs.length === 2) return `${xs[0]} Ùˆ ${xs[1]}`;
              return xs.slice(0, -1).join("ØŒ ") + " Ùˆ " + xs[xs.length - 1];
            }
            if (xs.length === 2) return `${xs[0]} and ${xs[1]}`;
            return xs.slice(0, -1).join(", ") + " and " + xs[xs.length - 1];
          };
          const teamParts = () => {
            if (appLang === "fa") {
              return [
                m ? `${fmtNum(m)} Ù…Ø§ÙÛŒØ§` : "",
                c ? `${fmtNum(c)} Ø´Ù‡Ø±ÙˆÙ†Ø¯` : "",
                i ? `${fmtNum(i)} Ù…Ø³ØªÙ‚Ù„` : "",
              ].filter(Boolean);
            }
            const citizenLabel = (n) => n === 1 ? "Citizen" : "Citizens";
            const indepLabel = (n) => n === 1 ? "Independent" : "Independents";
            return [
              m ? `${fmtNum(m)} Mafia` : "",
              c ? `${fmtNum(c)} ${citizenLabel(c)}` : "",
              i ? `${fmtNum(i)} ${indepLabel(i)}` : "",
            ].filter(Boolean);
          };
          const aliveParts = () => {
            if (appLang === "fa") {
              return [
                mA ? `${fmtNum(mA)} Ù…Ø§ÙÛŒØ§` : "",
                cA ? `${fmtNum(cA)} Ø´Ù‡Ø±ÙˆÙ†Ø¯` : "",
                iA ? `${fmtNum(iA)} Ù…Ø³ØªÙ‚Ù„` : "",
              ].filter(Boolean);
            }
            const citizenLabel = (n) => n === 1 ? "Citizen" : "Citizens";
            const indepLabel = (n) => n === 1 ? "Independent" : "Independents";
            return [
              mA ? `${fmtNum(mA)} Mafia` : "",
              cA ? `${fmtNum(cA)} ${citizenLabel(cA)}` : "",
              iA ? `${fmtNum(iA)} ${indepLabel(iA)}` : "",
            ].filter(Boolean);
          };
          const summaryText = (() => {
            const total = out || 0;
            const parts = teamParts();
            if (total <= 0) {
              return (appLang === "fa")
                ? "Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ Ù‡Ù†ÙˆØ² Ú©Ø³ÛŒ Ø®Ø§Ø±Ø¬ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."
                : "From your game no one is out yet.";
            }
            if (parts.length === 1) {
              // only one team has any out
              if (appLang === "fa") {
                // parts[0] is like "3 Ù…Ø§ÙÛŒØ§" -> strip leading number
                const teamOnly = parts[0].replace(/^\S+\s*/, "");
                if (total === 1) return `Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ ${fmtNum(total)} Ù†ÙØ± Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù‡ Ø§Ø³ØªØ› Ø§Ùˆ ${teamOnly} Ø¨ÙˆØ¯Ù‡ Ø§Ø³Øª.`;
                return `Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ ${fmtNum(total)} Ù†ÙØ± Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯Ø› Ù‡Ù…Ù‡Ù” Ø¢Ù†â€ŒÙ‡Ø§ ${teamOnly} Ø¨ÙˆØ¯Ù‡â€ŒØ§Ù†Ø¯.`;
              }
              // English
              const isOne = total === 1;
              const head = isOne ? `From your game ${fmtNum(total)} person is out` : `From your game ${fmtNum(total)} people are out`;
              // Convert "3 Citizens" -> "Citizens", "2 Mafia" -> "Mafia"
              const teamOnly = parts[0].replace(/^\S+\s*/, "");
              if (isOne) {
                // add article for Citizen/Independent
                const lower = teamOnly.toLowerCase();
                const withArticle =
                  (lower === "citizen") ? "a Citizen" :
                  (lower === "independent") ? "an Independent" :
                  teamOnly;
                return `${head}, they were ${withArticle}.`;
              }
              return `${head}, all of them were ${teamOnly}.`;
            }
            // multiple teams
            if (appLang === "fa") {
              return `Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ ${fmtNum(total)} Ù†ÙØ± Ø®Ø§Ø±Ø¬ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯Ø› ${joinList(parts)}.`;
            }
            const head = (total === 1)
              ? `From your game ${fmtNum(total)} person is out`
              : `From your game ${fmtNum(total)} people are out`;
            return `${head}. ${joinList(parts)}.`;
          })();
          const aliveLine = (() => {
            const total = aliveTotal || 0;
            const parts = aliveParts();
            if (total <= 0) {
              return (appLang === "fa")
                ? "Ø¯Ø± Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ Ú©Ø³ÛŒ Ø²Ù†Ø¯Ù‡ Ù†ÛŒØ³Øª."
                : "No one is alive in your game.";
            }
            if (appLang === "fa") {
              return `Ø¯Ø± Ø¨Ø§Ø²ÛŒ Ø´Ù…Ø§ ${fmtNum(total)} Ù†ÙØ± Ø¯Ø§Ø®Ù„ Ø¨Ø§Ø²ÛŒ Ù‡Ø³ØªÙ†Ø¯Ø› ${joinList(parts)}.`;
            }
            const head = (total === 1)
              ? `In your game ${fmtNum(total)} person is still in`
              : `In your game ${fmtNum(total)} people are still in`;
            return `${head}. ${joinList(parts)}.`;
          })();

          const timelineHtml = (() => {
            try {
              const f = (appState.god && appState.god.flow) ? ensureFlow() : null;
              const evs = (f && Array.isArray(f.events)) ? f.events.slice() : [];
              const draw = appState.draw;
              const names = getPlayerNamesForFlow();
              if (!evs.length) {
                const noneTxt = (appLang === "fa")
                  ? "Ù‡Ù†ÙˆØ² Ú†ÛŒØ²ÛŒ Ø¯Ø± Ø±ÙˆÙ†Ø¯ Ø¨Ø§Ø²ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."
                  : "Nothing has been recorded in the game flow yet.";
                return `<div class="toolBox" style="margin-top:12px"><div style="font-weight:1100; margin-bottom:6px">${escapeHtml(appLang === "fa" ? "Ø±ÙˆÙ†Ø¯ (Ø±ÙˆØ²/Ø´Ø¨)" : "Timeline (Day/Night)")}</div><div class="note">${escapeHtml(noneTxt)}</div></div>`;
              }

              const plainNameOf = (idx) => {
                const i = parseInt(idx, 10);
                if (!Number.isFinite(i) || i < 0 || !draw || !draw.players || i >= draw.players.length) return appLang === "fa" ? "â€”" : "â€”";
                return names[i] || t("common.playerN", { n: i + 1 });
              };
              const nameOf = (idx) => {
                const i = parseInt(idx, 10);
                if (!Number.isFinite(i) || i < 0 || !draw || !draw.players || i >= draw.players.length) return plainNameOf(i);
                const rid = (draw.players[i] && draw.players[i].roleId) ? draw.players[i].roleId : "citizen";
                const rn = (typeof roleName === "function") ? roleName(rid) : String(rid || "");
                return `${plainNameOf(i)} (${rn})`;
              };
              const listNames = (idxs) => {
                const arr = Array.isArray(idxs) ? idxs : [];
                const clean = arr.map((x) => parseInt(x, 10)).filter((x) => Number.isFinite(x));
                if (!clean.length) return appLang === "fa" ? "â€”" : "â€”";
                const parts = clean.map((i) => nameOf(i));
                // use simple join for readability
                return (appLang === "fa") ? parts.join("ØŒ ") : parts.join(", ");
              };
              const idxFrom = (v) => {
                const n = parseInt(String(v ?? "").trim(), 10);
                if (!Number.isFinite(n)) return null;
                if (!draw || !draw.players) return n;
                if (n < 0 || n >= draw.players.length) return null;
                return n;
              };
              const idxArrFrom = (v) => {
                if (v === null || v === undefined) return [];
                const arr = Array.isArray(v) ? v : [v];
                return arr.map((x) => idxFrom(x)).filter((x) => x !== null);
              };
              const hasAnyRole = (roleIds) => {
                try {
                  const ids = Array.isArray(roleIds) ? roleIds : [roleIds];
                  for (const p of (draw.players || [])) {
                    if (!p) continue;
                    if (ids.includes(p.roleId)) return true;
                  }
                  return false;
                } catch {
                  return false;
                }
              };
              const findIdxByRole = (roleIds) => {
                try {
                  const ids = Array.isArray(roleIds) ? roleIds : [roleIds];
                  for (let i = 0; i < (draw.players || []).length; i++) {
                    const p = draw.players[i];
                    if (!p) continue;
                    if (ids.includes(p.roleId)) return i;
                  }
                  return null;
                } catch {
                  return null;
                }
              };
              const phaseTitle = (day, phase) => {
                const d = fmtNum(day);
                if (phase === "night") return (appLang === "fa") ? `Ø´Ø¨ ${d}` : `Night ${d}`;
                if (phase === "midday") return (appLang === "fa") ? `Ù†ÛŒÙ…â€ŒØ±ÙˆØ² ${d}` : `Mid-day ${d}`;
                return (appLang === "fa") ? `Ø±ÙˆØ² ${d}` : `Day ${d}`;
              };
              const phaseOrder = { day: 0, midday: 1, night: 2 };
              const groups = new Map(); // key -> { day, phase, items: [] }
              for (const e of evs) {
                if (!e || !e.phase || e.day === undefined || e.day === null) continue;
                const day = parseInt(e.day, 10);
                const phase = String(e.phase);
                if (!Number.isFinite(day) || !["day", "midday", "night"].includes(phase)) continue;
                const key = `${day}:${phase}`;
                if (!groups.has(key)) groups.set(key, { day, phase, items: [] });
                groups.get(key).items.push(e);
              }
              const keys = Array.from(groups.values())
                .sort((a, b) => (a.day - b.day) || ((phaseOrder[a.phase] ?? 99) - (phaseOrder[b.phase] ?? 99)));

              const describeNightActions = (payload) => {
                const out = [];
                if (!payload || typeof payload !== "object") return out;
                const mafiaShot = idxFrom(payload.mafiaShot);
                const doctorSave = idxFrom(payload.doctorSave);
                const mafiaIdx = findIdxByRole(["mafiaBoss", "godfather", "mafia", "danMafia", "alcapone", "matador", "saulGoodman", "doctorLecter", "jokerMafia"]);
                if (mafiaShot !== null && mafiaIdx !== null) {
                  const targetRole = (draw.players[mafiaShot] && draw.players[mafiaShot].roleId) ? draw.players[mafiaShot].roleId : "citizen";
                  const alwaysImmuneToMafiaShot = (targetRole === "zodiac" || targetRole === "invulnerable" || targetRole === "armored");
                  if (doctorSave !== null && doctorSave === mafiaShot) {
                    out.push((appLang === "fa")
                      ? `${nameOf(mafiaIdx)} Ø¨Ù‡ ${nameOf(mafiaShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ØŒ Ø§Ù…Ø§ Ù¾Ø²Ø´Ú© Ù†Ø¬Ø§ØªØ´ Ø¯Ø§Ø¯.`
                      : `${nameOf(mafiaIdx)} shot ${nameOf(mafiaShot)}, but Doctor saved them.`);
                  } else if (alwaysImmuneToMafiaShot) {
                    out.push((appLang === "fa")
                      ? `${nameOf(mafiaIdx)} Ø¨Ù‡ ${nameOf(mafiaShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ (Ø¨Ø¯ÙˆÙ† Ø§Ø«Ø±).`
                      : `${nameOf(mafiaIdx)} shot ${nameOf(mafiaShot)} (no effect).`);
                  } else {
                    out.push((appLang === "fa")
                      ? `${nameOf(mafiaIdx)} Ø¨Ù‡ ${nameOf(mafiaShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯.`
                      : `${nameOf(mafiaIdx)} shot ${nameOf(mafiaShot)}.`);
                  }
                }
                const doctorIdx = findIdxByRole(["doctor", "watson", "doctorLecter"]);
                if (doctorSave !== null && (mafiaShot === null || doctorSave !== mafiaShot) && doctorIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(doctorIdx)} ${nameOf(doctorSave)} Ø±Ø§ Ù†Ø¬Ø§Øª Ø¯Ø§Ø¯.`
                    : `${nameOf(doctorIdx)} saved ${nameOf(doctorSave)}.`);
                }
                const oceanIdx = findIdxByRole(["ocean"]);
                const oceanWake = idxArrFrom(payload.oceanWake);
                if (oceanWake.length && oceanIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(oceanIdx)} Ø¨ÛŒØ¯Ø§Ø± Ú©Ø±Ø¯: ${listNames(oceanWake)}.`
                    : `${nameOf(oceanIdx)} woke: ${listNames(oceanWake)}.`);
                  // If Ocean wakes Mafia or Zodiac => Ocean is out (rule used in the app).
                  try {
                    const isBad = oceanWake.some((x) => {
                      const i = idxFrom(x);
                      if (i === null || !draw || !draw.players || !draw.players[i]) return false;
                      const rid = (draw.players[i] && draw.players[i].roleId) ? draw.players[i].roleId : "citizen";
                      const teamFa = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
                      return teamFa === "Ù…Ø§ÙÛŒØ§" || rid === "zodiac";
                    });
                    if (isBad) {
                      out.push((appLang === "fa")
                        ? "Ø§ÙˆØ´Ù† Ø¨Ù‡ Ù…Ø§ÙÛŒØ§/Ø²ÙˆØ¯ÛŒØ§Ú© Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú©Ø±Ø¯ Ùˆ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯."
                        : "Ocean woke Mafia/Zodiac and got eliminated.");
                    }
                  } catch {}
                }
                const proIdx = findIdxByRole(["professional"]);
                const proShot = idxFrom(payload.professionalShot);
                if (proShot !== null && proIdx !== null) {
                  try {
                    const tr = (draw && draw.players && draw.players[proShot] && draw.players[proShot].roleId) ? draw.players[proShot].roleId : "citizen";
                    const teamFa = (roles[tr] && roles[tr].teamFa) ? roles[tr].teamFa : "Ø´Ù‡Ø±";
                    if (tr === "zodiac") {
                      out.push((appLang === "fa")
                        ? `${nameOf(proIdx)} Ø¨Ù‡ ${nameOf(proShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ (Ø¨ÛŒâ€ŒØ§Ø«Ø± Ø±ÙˆÛŒ Ø²ÙˆØ¯ÛŒØ§Ú©).`
                        : `${nameOf(proIdx)} shot ${nameOf(proShot)} (no effect on Zodiac).`);
                    } else if (teamFa === "Ù…Ø§ÙÛŒØ§") {
                      out.push((appLang === "fa")
                        ? `${nameOf(proIdx)} Ø¨Ù‡ ${nameOf(proShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ Ùˆ Ø§Ùˆ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                        : `${nameOf(proIdx)} shot ${nameOf(proShot)} and they were eliminated.`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${nameOf(proIdx)} Ø¨Ù‡ Ø§Ø´ØªØ¨Ø§Ù‡ Ø¨Ù‡ ${nameOf(proShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ Ùˆ Ø®ÙˆØ¯Ø´ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯.`
                        : `${nameOf(proIdx)} shot ${nameOf(proShot)} by mistake and got eliminated.`);
                    }
                  } catch {
                    out.push((appLang === "fa")
                      ? `${nameOf(proIdx)} Ø¨Ù‡ ${nameOf(proShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯.`
                      : `${nameOf(proIdx)} shot ${nameOf(proShot)}.`);
                  }
                }
                const zodiacIdx = findIdxByRole(["zodiac"]);
                const zodiacShot = idxFrom(payload.zodiacShot);
                if (zodiacShot !== null && zodiacIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(zodiacIdx)} Ø¨Ù‡ ${nameOf(zodiacShot)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯.`
                    : `${nameOf(zodiacIdx)} shot ${nameOf(zodiacShot)}.`);
                }
                const magicianIdx = findIdxByRole(["magician"]);
                const magicianDisable = idxFrom(payload.magicianDisable);
                if (magicianDisable !== null && magicianIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(magicianIdx)} ${nameOf(magicianDisable)} Ø±Ø§ ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ø±Ø¯.`
                    : `${nameOf(magicianIdx)} disabled ${nameOf(magicianDisable)}.`);
                }
                const bomberIdx = findIdxByRole(["bomber"]);
                const bombTarget = idxFrom(payload.bombTarget);
                if (bombTarget !== null && bomberIdx !== null) {
                  const code = (payload.bombCode != null && String(payload.bombCode).trim()) ? String(payload.bombCode).trim() : null;
                  out.push((appLang === "fa")
                    ? `${nameOf(bomberIdx)} Ø¨Ù…Ø¨ Ø¬Ù„ÙˆÛŒ ${nameOf(bombTarget)} Ú¯Ø°Ø§Ø´Øª${code ? ` (Ø±Ù…Ø²: ${code})` : ""}.`
                    : `${nameOf(bomberIdx)} placed bomb in front of ${nameOf(bombTarget)}${code ? ` (code: ${code})` : ""}.`);
                }
                const kaneIdx = findIdxByRole(["citizenKane"]);
                const kaneMark = idxFrom(payload.kaneMark);
                if (kaneMark !== null && kaneIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(kaneIdx)} Ù†Ø´Ø§Ù† Ú©Ø±Ø¯: ${nameOf(kaneMark)}.`
                    : `${nameOf(kaneIdx)} marked: ${nameOf(kaneMark)}.`);
                }
                const constantineIdx = findIdxByRole(["constantine"]);
                const constantineRevive = idxFrom(payload.constantineRevive);
                if (constantineRevive !== null && constantineIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(constantineIdx)} Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯: ${nameOf(constantineRevive)}.`
                    : `${nameOf(constantineIdx)} revived: ${nameOf(constantineRevive)}.`);
                }
                const heirIdx = findIdxByRole(["heir"]);
                const heirPick = idxFrom(payload.heirPick);
                if (heirPick !== null && heirIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(heirIdx)} Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯: ${nameOf(heirPick)}.`
                    : `${nameOf(heirIdx)} picked: ${nameOf(heirPick)}.`);
                }
                const herbalistIdx = findIdxByRole(["herbalist"]);
                const herbalistPoison = idxFrom(payload.herbalistPoison);
                if (herbalistPoison !== null && herbalistIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(herbalistIdx)} Ø²Ù‡Ø± Ø¯Ø§Ø¯ Ø¨Ù‡: ${nameOf(herbalistPoison)}.`
                    : `${nameOf(herbalistIdx)} poisoned: ${nameOf(herbalistPoison)}.`);
                }
                const herbalistAntidote = idxFrom(payload.herbalistAntidote);
                if (herbalistAntidote !== null && herbalistIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(herbalistIdx)} Ù¾Ø§Ø¯Ø²Ù‡Ø± Ø¯Ø§Ø¯ Ø¨Ù‡: ${nameOf(herbalistAntidote)}.`
                    : `${nameOf(herbalistIdx)} antidote to: ${nameOf(herbalistAntidote)}.`);
                }
                const armorsmithIdx = findIdxByRole(["armorsmith"]);
                const armor = idxFrom(payload.armorsmithArmor);
                if (armor !== null && armorsmithIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(armorsmithIdx)} Ø¨Ù‡ ${nameOf(armor)} Ø²Ø±Ù‡ Ø¯Ø§Ø¯.`
                    : `${nameOf(armorsmithIdx)} armored ${nameOf(armor)}.`);
                }
                const nostIdx = findIdxByRole(["nostradamus"]);
                const nost = idxArrFrom(payload.nostPick3);
                if (nost.length && nostIdx !== null) {
                  out.push((appLang === "fa")
                    ? `${nameOf(nostIdx)} Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯: ${listNames(nost)}.`
                    : `${nameOf(nostIdx)} picked: ${listNames(nost)}.`);
                }
                return out;
              };

              const describe = (e) => {
                const k = String(e.kind || "");
                const d0 = e.data || null;
                const out = [];
                if (k === "day_elim_out") {
                  const outIdx = d0 && d0.out !== null && d0.out !== undefined && Number.isFinite(Number(d0.out)) ? parseInt(d0.out, 10) : null;
                  if (outIdx !== null && !(d0 && d0.preview)) {
                    out.push((appLang === "fa")
                      ? `${nameOf(outIdx)} Ø¨Ø§ Ø±Ø£ÛŒ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®Ø§Ø±Ø¬ Ø´Ø¯${d0 && d0.draw ? " (Ù‚Ø±Ø¹Ù‡)" : ""}.`
                      : `${nameOf(outIdx)} was eliminated by voting${d0 && d0.draw ? " (draw)" : ""}.`);
                  }
                } else if (k === "gun_shot") {
                  const sh = d0 && Number.isFinite(Number(d0.shooter)) ? parseInt(d0.shooter, 10) : null;
                  const tg = d0 && Number.isFinite(Number(d0.target)) ? parseInt(d0.target, 10) : null;
                  const tp = d0 && d0.type ? String(d0.type) : "real";
                  if (sh !== null && tg !== null) {
                    if (tp === "fake") {
                      out.push((appLang === "fa")
                        ? `${nameOf(sh)} Ø¨Ø§ ØªÙÙ†Ú¯Ù Ù…Ø´Ù‚ÛŒ Ø¨Ù‡ ${nameOf(tg)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯ (Ø¨Ø¯ÙˆÙ† Ø§Ø«Ø±).`
                        : `${nameOf(sh)} used a fake gun and shot ${nameOf(tg)} (no effect).`);
                    } else {
                      out.push((appLang === "fa")
                        ? `${nameOf(sh)} Ø¨Ø§ ØªÙÙ†Ú¯Ù ÙˆØ§Ù‚Ø¹ÛŒ Ø¨Ù‡ ${nameOf(tg)} Ø´Ù„ÛŒÚ© Ú©Ø±Ø¯.`
                        : `${nameOf(sh)} used a real gun and shot ${nameOf(tg)}.`);
                    }
                  }
                } else if (k === "gun_give") {
                  const to = d0 && Number.isFinite(Number(d0.to)) ? parseInt(d0.to, 10) : null;
                  const tp = d0 && d0.type ? String(d0.type) : "real";
                  if (to !== null) {
                    out.push((appLang === "fa")
                      ? `ØªÙÙ†Ú¯ (${tp === "fake" ? "Ù…Ø´Ù‚ÛŒ" : "ÙˆØ§Ù‚Ø¹ÛŒ"}) Ø¨Ù‡ ${nameOf(to)} Ø¯Ø§Ø¯Ù‡ Ø´Ø¯.`
                      : `A ${tp === "fake" ? "fake" : "real"} gun was given to ${nameOf(to)}.`);
                  }
                } else if (k === "gun_remove") {
                  const to = d0 && Number.isFinite(Number(d0.to)) ? parseInt(d0.to, 10) : null;
                  if (to !== null) {
                    out.push((appLang === "fa")
                      ? `ØªÙÙ†Ú¯Ù ${nameOf(to)} Ø­Ø°Ù Ø´Ø¯.`
                      : `Removed gun from ${nameOf(to)}.`);
                  }
                } else if (k === "detective_query") {
                  const target = d0 ? idxFrom(d0.target) : null;
                  const isMafia = d0 && typeof d0.isMafia === "boolean" ? d0.isMafia : null;
                  const detIdx = findIdxByRole(["detective"]);
                  if (target !== null && isMafia !== null && detIdx !== null) {
                    const thumb = isMafia ? "ğŸ‘" : "ğŸ‘";
                    out.push((appLang === "fa")
                      ? `Ø§Ø³ØªØ¹Ù„Ø§Ù… ${nameOf(detIdx)} Ø§Ø² ${nameOf(target)}: ${thumb} ${isMafia ? "Ù…Ø§ÙÛŒØ§" : "Ø´Ù‡Ø±ÙˆÙ†Ø¯"}.`
                      : `${nameOf(detIdx)} inquiry on ${nameOf(target)}: ${thumb} ${isMafia ? "Mafia" : "Citizen"}.`);
                  }
                } else if (k === "night_actions") {
                  out.push(...describeNightActions(d0));
                } else if (k === "bomb_resolve") {
                  try {
                    if (!d0 || typeof d0 !== "object") return out;
                    const target = idxFrom(d0.target);
                    const killed = idxFrom(d0.killed);
                    const ok = (d0.ok === true);
                    const sac = (d0.guardSacrifice === true);
                    const guess = (d0.guess != null) ? String(d0.guess).trim() : "";
                    const code = (d0.code != null) ? String(d0.code).trim() : "";
                    if (target === null) return out;
                    if (sac) {
                      out.push((appLang === "fa")
                        ? `Ø¨Ù…Ø¨Ù Ø¬Ù„ÙˆÛŒ ${nameOf(target)} Ø¨Ø§ ÙØ¯Ø§Ú©Ø§Ø±ÛŒÙ Ù…Ø­Ø§ÙØ¸ Ø­Ù„ Ø´Ø¯ (Ø­Ø¯Ø³: ${guess || "â€”"} / Ú©Ø¯: ${code || "â€”"}).`
                        : `Bomb in front of ${nameOf(target)} was resolved by Guard sacrifice (guess: ${guess || "â€”"} / code: ${code || "â€”"}).`);
                      if (!ok && killed !== null) {
                        out.push((appLang === "fa")
                          ? `${nameOf(killed)} Ø¨Ù‡â€ŒØ®Ø§Ø·Ø± Ø­Ø¯Ø³Ù ØºÙ„Ø·Ù Ú©Ø¯Ù Ø¨Ù…Ø¨ Ú©Ø´ØªÙ‡ Ø´Ø¯.`
                          : `${nameOf(killed)} died due to wrong bomb code guess.`);
                      }
                    } else {
                      if (ok) {
                        out.push((appLang === "fa")
                          ? `${nameOf(target)} Ú©Ø¯Ù Ø¨Ù…Ø¨ Ø±Ø§ Ø¯Ø±Ø³Øª Ø­Ø¯Ø³ Ø²Ø¯ Ùˆ Ø¨Ù…Ø¨ Ø®Ù†Ø«ÛŒ Ø´Ø¯.`
                          : `${nameOf(target)} guessed the bomb code and it was neutralized.`);
                      } else {
                        out.push((appLang === "fa")
                          ? `${nameOf(target)} Ú©Ø¯Ù Ø¨Ù…Ø¨ Ø±Ø§ ØºÙ„Ø· Ø­Ø¯Ø³ Ø²Ø¯ Ùˆ Ú©Ø´ØªÙ‡ Ø´Ø¯.`
                          : `${nameOf(target)} guessed the bomb code wrong and died.`);
                      }
                    }
                  } catch {}
                }
                return out;
              };

              const blocks = keys.map((g) => {
                const items = (g.items || []).slice().sort((a, b) => (Number(a.at || 0) - Number(b.at || 0)));
                const lines = [];
                for (const e of items) {
                  const xs = describe(e);
                  for (const s of xs) if (s) lines.push(s);
                }
                // de-dupe identical adjacent lines for cleanliness
                const clean = [];
                for (const s of lines) {
                  if (!s) continue;
                  if (!clean.length || clean[clean.length - 1] !== s) clean.push(s);
                }
                if (!clean.length) return "";
                return `
                  <div class="toolBox" style="margin-top:12px">
                    <div style="font-weight:1100; margin-bottom:6px">${escapeHtml(phaseTitle(g.day, g.phase))}</div>
                    <ul style="margin:0; padding-${appLang === "fa" ? "right" : "left"}:18px; line-height:1.9">
                      ${clean.map((s) => `<li>${escapeHtml(s)}</li>`).join("")}
                    </ul>
                  </div>
                `;
              }).filter(Boolean).join("");

              const title = escapeHtml(appLang === "fa" ? "Ø±ÙˆÙ†Ø¯ (Ø±ÙˆØ²/Ø´Ø¨)" : "Timeline (Day/Night)");
              return `
                <div style="margin-top:12px">
                  <div style="font-weight:1200; margin-bottom:6px">${title}</div>
                  ${blocks || `<div class="note">${escapeHtml(appLang === "fa" ? "Ú†ÛŒØ²ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ù†ÛŒØ³Øª." : "Nothing to show.")}</div>`}
                </div>
              `;
            } catch {
              return "";
            }
          })();

          openToolModal(t("tool.status.title"), `
            <div class="toolBox" style="font-weight:950; line-height:1.9">
              <div>${escapeHtml(summaryText)}</div>
              <div class="note" style="margin-top:10px">${escapeHtml(aliveLine)}</div>
            </div>
            ${timelineHtml}
          `);
        }

        function showLastMoveTool() {
          const scenario = getScenario();
          const supports = scenario === "shab_mafia";
          if (!supports) {
            openToolModal(t("tool.lastMove.title"), `<div class="toolBox">${escapeHtml(t("tool.lastMove.none"))}</div>`);
            return;
          }
          const lastMoveCards = [
            { id: "insomnia", fa: "Ø¨ÛŒâ€ŒØ®ÙˆØ§Ø¨ÛŒ", en: "Insomnia" },
            { id: "final_shot", fa: "Ø´Ù„ÛŒÚ© Ù†Ù‡Ø§ÛŒÛŒ", en: "Final Shot" },
            { id: "beautiful_mind", fa: "Ø°Ù‡Ù† Ø²ÛŒØ¨Ø§", en: "Beautiful Mind" },
            { id: "thirteen_lies", fa: "Ø¯Ø±ÙˆØº Ø³ÛŒØ²Ø¯Ù‡", en: "Thirteen Lies" },
            { id: "green_mile", fa: "Ù…Ø³ÛŒØ± Ø³Ø¨Ø²", en: "Green Mile" },
            { id: "red_carpet", fa: "ÙØ±Ø´ Ù‚Ø±Ù…Ø²", en: "Red Carpet" },
          ];
          const labelFor = (id) => {
            const c = lastMoveCards.find((x) => x.id === id);
            if (!c) return String(id || "");
            return appLang === "fa" ? c.fa : c.en;
          };
          if (!appState.god.lastMove || typeof appState.god.lastMove !== "object") {
            appState.god.lastMove = { last: null, at: null, used: [] };
          } else {
            if (!Array.isArray(appState.god.lastMove.used)) appState.god.lastMove.used = [];
          }
          const used = new Set(appState.god.lastMove.used || []);
          const remaining = lastMoveCards.filter((c) => !used.has(c.id));
          const lastId = appState.god.lastMove && appState.god.lastMove.last ? appState.god.lastMove.last : null;
          const last = lastId ? labelFor(lastId) : null;

          const listHtml = lastMoveCards.map((c) => {
            const isUsed = used.has(c.id);
            const txt = labelFor(c.id);
            const st = isUsed
              ? 'opacity:.45; filter:saturate(.2); text-decoration:line-through;'
              : '';
            return `<div style="padding:6px 0;font-weight:950;${st}">${escapeHtml(txt)}</div>`;
          }).join("");
          openToolModal(t("tool.lastMove.title"), `
            <div class="toolBox">
              <div style="font-weight:1100;margin-bottom:8px">${escapeHtml(t("tool.lastMove.header"))}</div>
              ${listHtml}
              <div style="height:10px"></div>
              <button class="btn primary" id="lm_draw" type="button">${escapeHtml(t("tool.lastMove.draw"))}</button>
              <div class="note" id="lm_note" style="display:none; margin-top:10px"></div>
              <div style="height:10px"></div>
              <div style="font-weight:1100">${escapeHtml(t("tool.lastMove.result"))} <span id="lm_res">${last ? escapeHtml(last) : "â€”"}</span></div>
            </div>
          `);
          $("lm_draw").onclick = () => {
            const note = $("lm_note");
            if (!remaining.length) {
              if (note) {
                note.style.display = "block";
                note.textContent = t("tool.lastMove.allUsed");
              }
              return;
            }
            const picked = remaining[Math.floor(Math.random() * remaining.length)];
            appState.god.lastMove.last = picked.id;
            appState.god.lastMove.at = Date.now();
            if (!Array.isArray(appState.god.lastMove.used)) appState.god.lastMove.used = [];
            appState.god.lastMove.used.push(picked.id);
            saveState(appState);
            // re-render to grey out used + update remaining list
            showLastMoveTool();
          };
          // disable button if no remaining
          if (!remaining.length) {
            const btn = $("lm_draw");
            if (btn) btn.disabled = true;
            const note = $("lm_note");
            if (note) {
              note.style.display = "block";
              note.textContent = t("tool.lastMove.allUsed");
            }
          }
        }

        let bombApplyJustHappened = false;
        function ensureFlow() {
          if (!appState.god) appState.god = {};
          if (!appState.god.flow || typeof appState.god.flow !== "object") {
            appState.god.flow = {
              day: 1,
              phase: "day", // day | night
              step: 0,
              bombActive: false,
              guns: {}, // idx -> { type: "real"|"fake", used: boolean, givenAt }
              events: [], // { at, phase, day, kind, data }
              draft: {}, // ui-only scratch (not required but persisted ok)
            };
          }
          if (!Array.isArray(appState.god.flow.events)) appState.god.flow.events = [];
          if (!appState.god.flow.guns || typeof appState.god.flow.guns !== "object") appState.god.flow.guns = {};
          if (typeof appState.god.flow.day !== "number" || appState.god.flow.day < 1) appState.god.flow.day = 1;
          // Mid-day step was removed; migrate older saves.
          if (appState.god.flow.phase === "midday") {
            appState.god.flow.phase = "day";
            appState.god.flow.step = 0;
          }
          if (!["day", "night"].includes(appState.god.flow.phase)) appState.god.flow.phase = "day";
          if (typeof appState.god.flow.step !== "number" || appState.god.flow.step < 0) appState.god.flow.step = 0;
          if (typeof appState.god.flow.bombActive !== "boolean") appState.god.flow.bombActive = false;
          if (!appState.god.flow.draft || typeof appState.god.flow.draft !== "object") appState.god.flow.draft = {};
          return appState.god.flow;
        }

        function getDrawScenarioForFlow() {
          return (appState.draw && appState.draw.uiAtDraw && appState.draw.uiAtDraw.scenario)
            ? appState.draw.uiAtDraw.scenario
            : getScenario();
        }

        function getPlayerNamesForFlow() {
          const draw = appState.draw;
          const n = (draw && draw.players) ? draw.players.length : (appState.ui && appState.ui.nPlayers) ? appState.ui.nPlayers : 0;
          const names = [];
          for (let i = 0; i < n; i++) {
            const nm = (appState.ui.playerNames && appState.ui.playerNames[i]) ? appState.ui.playerNames[i] : t("common.playerN", { n: i + 1 });
            names.push(nm);
          }
          return names;
        }

        function addFlowEvent(kind, data) {
          const f = ensureFlow();
          const SNAPSHOT_KINDS = new Set(["day_vote", "day_elim", "night_actions", "bomb_toggle", "detective_query", "bomb_resolve"]);
          // For snapshot-like events, keep only the latest per (kind, phase, day).
          if (SNAPSHOT_KINDS.has(kind)) {
            try {
              if (Array.isArray(f.events) && f.events.length) {
                for (let i = f.events.length - 1; i >= 0; i--) {
                  const e = f.events[i];
                  if (!e) continue;
                  if (e.kind === kind && e.phase === f.phase && e.day === f.day) {
                    e.at = Date.now();
                    e.data = data || null;
                    saveState(appState);
                    return;
                  }
                }
              }
            } catch {}
          }
          // For idempotent-ish events, upsert by a stable key to avoid duplicates.
          // - gun_give: one record per recipient per night
          // - gun_shot: one record per shooter per day
          // - day_elim_draw: one record per day
          // - day_elim_out: one record per day (out can change when correcting)
          const canUpsert =
            kind === "gun_give" ||
            kind === "gun_shot" ||
            kind === "day_elim_draw" ||
            kind === "day_elim_out";
          if (canUpsert) {
            try {
              const match = (e) => {
                if (!e || e.kind !== kind || e.phase !== f.phase || e.day !== f.day) return false;
                const a = e.data || null;
                const b = data || null;
                if (kind === "gun_give") return a && b && a.to === b.to;
                if (kind === "gun_shot") return a && b && a.shooter === b.shooter;
                if (kind === "day_elim_draw") return true;
                if (kind === "day_elim_out") return true;
                return false;
              };
              for (let i = (f.events || []).length - 1; i >= 0; i--) {
                const e = f.events[i];
                if (!match(e)) continue;
                e.at = Date.now();
                e.data = data || null;
                saveState(appState);
                return;
              }
            } catch {}
          }
          // Dedupe: avoid saving identical consecutive events (common during re-renders / repeated clicks).
          try {
            const now = Date.now();
            const last = (f.events && f.events.length) ? f.events[f.events.length - 1] : null;
            const a = (last && last.data !== undefined) ? last.data : null;
            const b = (data !== undefined) ? data : null;
            if (
              last &&
              last.kind === kind &&
              last.phase === f.phase &&
              last.day === f.day &&
              (now - (last.at || 0)) < 800 &&
              JSON.stringify(a) === JSON.stringify(b)
            ) {
              return;
            }
          } catch {}
          f.events.push({
            at: Date.now(),
            phase: f.phase,
            day: f.day,
            kind,
            data: data || null,
          });
          // keep event log bounded
          try {
            const MAX_EVENTS = 300;
            if (Array.isArray(f.events) && f.events.length > MAX_EVENTS) {
              f.events.splice(0, f.events.length - MAX_EVENTS);
            }
          } catch {}
          saveState(appState);
        }

        // Apply Mafia shot resolution immediately (with reversible preview).
        // Rule: if MafiaShot is set and DoctorSave is NOT the same target => target is out (shot).
        // If DoctorSave matches MafiaShot, the target stays alive.
        // Role immunities (from scenario/role descriptions): Zodiac, Invulnerable, Armored cannot be killed by mafia night shot.
        // Hard John survives the first mafia shot only.
        function applyNightMafiaFromPayload(f, payload) {
          try {
            if (!f || !payload) return false;
            const draw = appState.draw;
            if (!draw || !draw.players) return false;
            const dayKey = String(f.day || 1);
            if (!f.draft || typeof f.draft !== "object") f.draft = {};
            if (!f.draft.nightMafiaAppliedByDay || typeof f.draft.nightMafiaAppliedByDay !== "object") f.draft.nightMafiaAppliedByDay = {};
            const rec = (f.draft.nightMafiaAppliedByDay[dayKey] && typeof f.draft.nightMafiaAppliedByDay[dayKey] === "object")
              ? f.draft.nightMafiaAppliedByDay[dayKey]
              : { killed: null, prevAlive: null };

            const ms = (payload.mafiaShot === null || payload.mafiaShot === undefined) ? null : parseInt(payload.mafiaShot, 10);
            const ds = (payload.doctorSave === null || payload.doctorSave === undefined) ? null : parseInt(payload.doctorSave, 10);
            let desiredKill = (Number.isFinite(ms) && ms >= 0 && ms < draw.players.length && ms !== ds) ? ms : null;
            if (desiredKill !== null) {
              const targetRole = (draw.players[desiredKill] && draw.players[desiredKill].roleId) ? draw.players[desiredKill].roleId : "citizen";
              if (targetRole === "zodiac" || targetRole === "invulnerable" || targetRole === "armored") {
                desiredKill = null;
              } else if (targetRole === "hardJohn") {
                if (!f.draft.hardJohnSurvivedMafiaShotOnce) {
                  f.draft.hardJohnSurvivedMafiaShotOnce = true;
                  desiredKill = null;
                }
              }
            }

            // no change
            if ((rec.killed === null || rec.killed === undefined) && desiredKill === null) return false;
            if (Number.isFinite(Number(rec.killed)) && desiredKill !== null && parseInt(rec.killed, 10) === desiredKill) return false;

            // revert previous applied kill (only if we killed someone who was alive before)
            if (Number.isFinite(Number(rec.killed))) {
              const prevIdx = parseInt(rec.killed, 10);
              if (rec.prevAlive === true) {
                try { setPlayerLife(prevIdx, { alive: true }); } catch {}
              }
            }

            // apply new kill
            if (desiredKill !== null) {
              const p = draw.players[desiredKill];
              const wasAlive = p ? (p.alive !== false) : null;
              if (wasAlive) {
                try { setPlayerLife(desiredKill, { alive: false, reason: "shot" }); } catch {}
              }
              rec.killed = desiredKill;
              rec.prevAlive = wasAlive === true;
            } else {
              rec.killed = null;
              rec.prevAlive = null;
            }

            f.draft.nightMafiaAppliedByDay[dayKey] = rec;
            saveState(appState);
            return true;
          } catch {
            return false;
          }
        }

        // Apply Zodiac shot resolution immediately (with reversible preview).
        // Rule: if Zodiac shot is set, the target dies (including Mafia).
        // Exception: when Zodiac shoots the Guard, the Zodiac dies instead (Guard survives).
        function applyNightZodiacFromPayload(f, payload) {
          try {
            if (!f || !payload) return false;
            const draw = appState.draw;
            if (!draw || !draw.players) return false;
            const dayKey = String(f.day || 1);
            if (!f.draft || typeof f.draft !== "object") f.draft = {};
            if (!f.draft.nightZodiacAppliedByDay || typeof f.draft.nightZodiacAppliedByDay !== "object") f.draft.nightZodiacAppliedByDay = {};
            const rec = (f.draft.nightZodiacAppliedByDay[dayKey] && typeof f.draft.nightZodiacAppliedByDay[dayKey] === "object")
              ? f.draft.nightZodiacAppliedByDay[dayKey]
              : { killed: null, prevAlive: null };

            const zs = (payload.zodiacShot === null || payload.zodiacShot === undefined) ? null : parseInt(payload.zodiacShot, 10);
            const targetIdx = (Number.isFinite(zs) && zs >= 0 && zs < draw.players.length) ? zs : null;
            let desiredKill = null;
            if (targetIdx !== null) {
              const targetRole = (draw.players[targetIdx] && draw.players[targetIdx].roleId) ? draw.players[targetIdx].roleId : "citizen";
              if (targetRole === "guard") {
                const zodiacIdx = (() => {
                  for (let i = 0; i < draw.players.length; i++) {
                    if (draw.players[i] && draw.players[i].roleId === "zodiac") return i;
                  }
                  return null;
                })();
                desiredKill = zodiacIdx;
              } else {
                desiredKill = targetIdx;
              }
            }

            if ((rec.killed === null || rec.killed === undefined) && desiredKill === null) return false;
            if (Number.isFinite(Number(rec.killed)) && desiredKill !== null && parseInt(rec.killed, 10) === desiredKill) return false;

            if (Number.isFinite(Number(rec.killed))) {
              const prevIdx = parseInt(rec.killed, 10);
              if (rec.prevAlive === true) {
                try { setPlayerLife(prevIdx, { alive: true }); } catch {}
              }
            }

            if (desiredKill !== null) {
              const p = draw.players[desiredKill];
              const wasAlive = p ? (p.alive !== false) : null;
              if (wasAlive) {
                try { setPlayerLife(desiredKill, { alive: false, reason: "shot" }); } catch {}
              }
              rec.killed = desiredKill;
              rec.prevAlive = wasAlive === true;
            } else {
              rec.killed = null;
              rec.prevAlive = null;
            }

            f.draft.nightZodiacAppliedByDay[dayKey] = rec;
            saveState(appState);
            return true;
          } catch {
            return false;
          }
        }

        // Apply Ocean wake resolution immediately (with reversible preview).
        // Rule (as requested): if Ocean wakes Mafia or Zodiac => Ocean is out.
        // If Ocean wakes a Citizen => no one dies (and they can chat for ~20s).
        function applyNightOceanFromPayload(f, payload) {
          try {
            if (!f || !payload) return false;
            const draw = appState.draw;
            if (!draw || !draw.players) return false;
            const dayKey = String(f.day || 1);
            if (!f.draft || typeof f.draft !== "object") f.draft = {};
            if (!f.draft.nightOceanAppliedByDay || typeof f.draft.nightOceanAppliedByDay !== "object") f.draft.nightOceanAppliedByDay = {};
            const rec = (f.draft.nightOceanAppliedByDay[dayKey] && typeof f.draft.nightOceanAppliedByDay[dayKey] === "object")
              ? f.draft.nightOceanAppliedByDay[dayKey]
              : { oceanIdx: null, targets: [], killedOcean: false, prevAlive: null };

            const oceanIdx = (() => {
              try {
                for (let i = 0; i < draw.players.length; i++) {
                  const p = draw.players[i];
                  if (p && p.roleId === "ocean") return i;
                }
              } catch {}
              return null;
            })();

            const targets = (() => {
              try {
                const v = payload.oceanWake;
                const arr = Array.isArray(v) ? v : (v === null || v === undefined ? [] : [v]);
                const out = arr
                  .map((x) => parseInt(x, 10))
                  .filter((x) => Number.isFinite(x) && x >= 0 && x < draw.players.length);
                // unique + stable order
                return Array.from(new Set(out)).sort((a, b) => a - b);
              } catch {
                return [];
              }
            })();

            const isBadPick = (() => {
              try {
                for (const target of targets) {
                  const targetRole = (draw.players[target] && draw.players[target].roleId) ? draw.players[target].roleId : "citizen";
                  const teamFa = (roles[targetRole] && roles[targetRole].teamFa) ? roles[targetRole].teamFa : "Ø´Ù‡Ø±";
                  if (teamFa === "Ù…Ø§ÙÛŒØ§" || targetRole === "zodiac") return true;
                }
                return false;
              } catch {
                return false;
              }
            })();
            const desiredKillOcean = !!(oceanIdx !== null && isBadPick);

            // no change
            const sameTargets = (() => {
              try {
                const a = Array.isArray(rec.targets) ? rec.targets.slice().sort((x, y) => x - y) : [];
                if (a.length !== targets.length) return false;
                for (let i = 0; i < a.length; i++) if (a[i] !== targets[i]) return false;
                return true;
              } catch {
                return false;
              }
            })();
            if ((rec.killedOcean === false || rec.killedOcean === null || rec.killedOcean === undefined) && desiredKillOcean === false && sameTargets) return false;
            if (rec.killedOcean === true && desiredKillOcean === true && sameTargets) return false;

            // revert previous applied ocean death (only if ocean was alive before)
            if (rec.killedOcean === true && Number.isFinite(Number(rec.oceanIdx))) {
              const prevOceanIdx = parseInt(rec.oceanIdx, 10);
              if (rec.prevAlive === true) {
                try { setPlayerLife(prevOceanIdx, { alive: true }); } catch {}
              }
            }

            // apply new ocean death if needed
            if (desiredKillOcean === true && Number.isFinite(Number(oceanIdx))) {
              const oi = parseInt(oceanIdx, 10);
              const op = draw.players[oi];
              const wasAlive = op ? (op.alive !== false) : null;
              if (wasAlive) {
                try { setPlayerLife(oi, { alive: false, reason: "ocean" }); } catch {}
              }
              rec.oceanIdx = oi;
              rec.targets = targets;
              rec.killedOcean = true;
              rec.prevAlive = wasAlive === true;
            } else {
              rec.oceanIdx = oceanIdx;
              rec.targets = targets;
              rec.killedOcean = false;
              rec.prevAlive = null;
            }

            f.draft.nightOceanAppliedByDay[dayKey] = rec;
            saveState(appState);
            return true;
          } catch {
            return false;
          }
        }

        // Apply Professional shot resolution immediately (with reversible preview).
        // Rule: if Professional shoots Mafia => target is out.
        // If shoots Zodiac => no effect.
        // If shoots a non-mafia (citizen/independent) => Professional is out.
        function applyNightProfessionalFromPayload(f, payload) {
          try {
            if (!f || !payload) return false;
            const draw = appState.draw;
            if (!draw || !draw.players) return false;
            const dayKey = String(f.day || 1);
            if (!f.draft || typeof f.draft !== "object") f.draft = {};
            if (!f.draft.nightProAppliedByDay || typeof f.draft.nightProAppliedByDay !== "object") f.draft.nightProAppliedByDay = {};
            const rec = (f.draft.nightProAppliedByDay[dayKey] && typeof f.draft.nightProAppliedByDay[dayKey] === "object")
              ? f.draft.nightProAppliedByDay[dayKey]
              : { killed: null, prevAlive: null, result: null, shooter: null, target: null };

            const proIdx = (function () {
              try {
                for (let i = 0; i < draw.players.length; i++) {
                  const p = draw.players[i];
                  if (p && p.roleId === "professional" && p.alive !== false) return i;
                }
              } catch {}
              return null;
            })();

            const tIdxRaw = (payload.professionalShot === null || payload.professionalShot === undefined) ? null : parseInt(payload.professionalShot, 10);
            const tIdx = (Number.isFinite(tIdxRaw) && tIdxRaw >= 0 && tIdxRaw < draw.players.length) ? tIdxRaw : null;

            const desired = (() => {
              try {
                if (proIdx === null || tIdx === null) return { killIdx: null, result: null, shooter: proIdx, target: tIdx };
                const tr = (draw.players[tIdx] && draw.players[tIdx].roleId) ? draw.players[tIdx].roleId : "citizen";
                const teamFa = (roles[tr] && roles[tr].teamFa) ? roles[tr].teamFa : "Ø´Ù‡Ø±";
                if (tr === "zodiac") return { killIdx: null, result: "no_effect", shooter: proIdx, target: tIdx };
                if (teamFa === "Ù…Ø§ÙÛŒØ§") return { killIdx: tIdx, result: "killed_mafia", shooter: proIdx, target: tIdx };
                return { killIdx: proIdx, result: "killed_self", shooter: proIdx, target: tIdx };
              } catch {
                return { killIdx: null, result: null, shooter: proIdx, target: tIdx };
              }
            })();

            const desiredKill = desired.killIdx;
            const desiredResult = desired.result;

            // no change
            if ((rec.killed === null || rec.killed === undefined) && desiredKill === null && rec.result === desiredResult && rec.target === desired.target) return false;
            if (Number.isFinite(Number(rec.killed)) && desiredKill !== null && parseInt(rec.killed, 10) === desiredKill && rec.result === desiredResult && rec.target === desired.target) return false;

            // revert previous applied kill (only if that player was alive before)
            if (Number.isFinite(Number(rec.killed))) {
              const prevIdx = parseInt(rec.killed, 10);
              if (rec.prevAlive === true) {
                try { setPlayerLife(prevIdx, { alive: true }); } catch {}
              }
            }

            // apply new kill
            if (desiredKill !== null && Number.isFinite(Number(desiredKill))) {
              const p = draw.players[desiredKill];
              const wasAlive = p ? (p.alive !== false) : null;
              if (wasAlive) {
                try { setPlayerLife(desiredKill, { alive: false, reason: "shot" }); } catch {}
              }
              rec.killed = desiredKill;
              rec.prevAlive = wasAlive === true;
            } else {
              rec.killed = null;
              rec.prevAlive = null;
            }
            rec.result = desiredResult;
            rec.shooter = desired.shooter;
            rec.target = desired.target;

            f.draft.nightProAppliedByDay[dayKey] = rec;

            // log (upsert via snapshot night_actions already; this is a dedicated event)
            try {
              if (desiredResult === "killed_mafia" || desiredResult === "killed_self") {
                addFlowEvent("pro_shot", { shooter: desired.shooter, target: desired.target, result: desiredResult });
              }
            } catch {}

            saveState(appState);
            return true;
          } catch {
            return false;
          }
        }

        // Apply day elimination (vote-out) immediately (with reversible preview).
        function applyDayElimFromPayload(f, payload) {
          try {
            if (!f || !payload) return false;
            const draw = appState.draw;
            if (!draw || !draw.players) return false;
            const dayKey = String(f.day || 1);
            if (!f.draft || typeof f.draft !== "object") f.draft = {};
            if (!f.draft.dayElimAppliedByDay || typeof f.draft.dayElimAppliedByDay !== "object") f.draft.dayElimAppliedByDay = {};
            const rec = (f.draft.dayElimAppliedByDay[dayKey] && typeof f.draft.dayElimAppliedByDay[dayKey] === "object")
              ? f.draft.dayElimAppliedByDay[dayKey]
              : { out: null, prevAlive: null };

            const desiredOutRaw = (payload.out === null || payload.out === undefined) ? null : parseInt(payload.out, 10);
            const desiredOut = (Number.isFinite(desiredOutRaw) && desiredOutRaw >= 0 && desiredOutRaw < draw.players.length) ? desiredOutRaw : null;

            // no change
            if ((rec.out === null || rec.out === undefined) && desiredOut === null) return false;
            if (Number.isFinite(Number(rec.out)) && desiredOut !== null && parseInt(rec.out, 10) === desiredOut) return false;

            // revert previous applied out (only if they were alive before)
            if (Number.isFinite(Number(rec.out))) {
              const prevIdx = parseInt(rec.out, 10);
              if (rec.prevAlive === true) {
                try { setPlayerLife(prevIdx, { alive: true }); } catch {}
              }
            }

            // apply new out
            if (desiredOut !== null) {
              const p = draw.players[desiredOut];
              const wasAlive = p ? (p.alive !== false) : null;
              if (wasAlive) {
                try { setPlayerLife(desiredOut, { alive: false, reason: "vote" }); } catch {}
              }
              rec.out = desiredOut;
              rec.prevAlive = wasAlive === true;
            } else {
              rec.out = null;
              rec.prevAlive = null;
            }

            f.draft.dayElimAppliedByDay[dayKey] = rec;
            saveState(appState);
            return true;
          } catch {
            return false;
          }
        }

        function flowPhaseTitle(f) {
          if (f.phase === "day") return t("tool.flow.phase.day", { n: f.day });
          if (f.phase === "midday") return t("tool.flow.phase.midday", { n: f.day });
          return t("tool.flow.phase.night", { n: f.day });
        }

        function hasUsableDayGuns() {
          try {
            const draw = appState.draw;
            if (!draw || !draw.players || !draw.players.length) return false;
            const f = (appState.god && appState.god.flow) ? appState.god.flow : null;
            const guns = (f && f.guns) ? f.guns : null;
            if (!guns || typeof guns !== "object") return false;
            for (const k of Object.keys(guns)) {
              const idx = parseInt(k, 10);
              if (!Number.isFinite(idx)) continue;
              const p = draw.players[idx];
              if (!p || p.alive === false) continue;
              const g = guns[idx];
              if (g && !g.used) return true;
            }
            return false;
          } catch {
            return false;
          }
        }

        function getFlowSteps(f) {
          if (f.phase === "day") {
            const steps = [];
            // If a bomb exists for today, keep the Bomb step FIRST (before any day actions/voting),
            // even after it's resolved, so Back/edits remain possible.
            try {
              const d = f.draft || {};
              const rec = (d.bombByDay && d.bombByDay[String(f.day)]) ? d.bombByDay[String(f.day)] : null;
              const hasBombToday = !!(f.bombActive || (rec && rec.target !== null && rec.target !== undefined));
              if (hasBombToday) steps.push({ id: "day_bomb", title: t("tool.flow.bomb.active") });
            } catch {
              if (f.bombActive) steps.push({ id: "day_bomb", title: t("tool.flow.bomb.active") });
            }
            // Only show "Gun use" when at least one alive player has an unused gun.
            if (hasUsableDayGuns()) steps.push({ id: "day_guns", title: t("tool.flow.day.guns") });
            steps.push({ id: "day_vote", title: t("tool.flow.day.vote") });
            steps.push({ id: "day_elim", title: t("tool.flow.day.eliminate") });
            return steps;
          }
          return [
            { id: "night_run", title: t("tool.flow.night.run") },
          ];
        }

        function nextFlowStep() {
          const f = ensureFlow();
          const steps = getFlowSteps(f);
          if (f.step < steps.length - 1) {
            f.step++;
            saveState(appState);
            showFlowTool();
            return;
          }
          // phase transition
          if (f.phase === "day") {
            // Bomb resolution is handled as the FIRST step of the day (day_bomb),
            // so end-of-day always goes to night.
            f.phase = "night";
            f.step = 0;
          } else {
            // Apply night resolution BEFORE moving to next day.
            // Note: Night actions are considered simultaneous; being shot does NOT prevent acting that same night.
            // Disables (e.g., Magician) can still block actions that night.
            try {
              const draw = appState.draw;
              const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "night_actions" && e.phase === "night" && e.day === f.day && e.data);
              const payload0 = ev && ev.data ? { ...ev.data } : null;
              if (payload0 && draw && draw.players) {
                // Determine who is disabled tonight (Magician).
                const disabledIdx = (payload0.magicianDisable !== null && payload0.magicianDisable !== undefined && Number.isFinite(Number(payload0.magicianDisable)))
                  ? parseInt(payload0.magicianDisable, 10)
                  : null;
                const findIdxByRole = (roleIds) => {
                  const ids = Array.isArray(roleIds) ? roleIds : [roleIds];
                  for (let i = 0; i < (draw.players || []).length; i++) {
                    const p = draw.players[i];
                    if (!p) continue;
                    if (ids.includes(p.roleId)) return i;
                  }
                  return null;
                };
                const doctorIdx = findIdxByRole(["doctor", "watson", "doctorLecter"]);
                const detIdx = findIdxByRole(["detective"]);
                const proIdx = findIdxByRole(["professional"]);
                const bomberIdx = findIdxByRole(["bomber"]);
                const oceanIdx = findIdxByRole(["ocean"]);
                const zodiacIdx = findIdxByRole(["zodiac"]);
                // If a role is disabled, its action is ignored for resolution.
                if (disabledIdx !== null) {
                  if (doctorIdx !== null && disabledIdx === doctorIdx) payload0.doctorSave = null;
                  if (detIdx !== null && disabledIdx === detIdx) payload0.detectiveQuery = null;
                  if (proIdx !== null && disabledIdx === proIdx) payload0.professionalShot = null;
                  if (bomberIdx !== null && disabledIdx === bomberIdx) { payload0.bombTarget = null; payload0.bombCode = null; }
                  if (oceanIdx !== null && disabledIdx === oceanIdx) payload0.oceanWake = null;
                  if (zodiacIdx !== null && disabledIdx === zodiacIdx) payload0.zodiacShot = null;
                }

                // Apply professional/ocean first so they still act even if mafia shot them.
                try { applyNightProfessionalFromPayload(f, payload0); } catch {}
                try { applyNightOceanFromPayload(f, payload0); } catch {}
                try { applyNightZodiacFromPayload(f, payload0); } catch {}
                // Apply mafia last (uses doctorSave, possibly cleared by disable).
                try { applyNightMafiaFromPayload(f, payload0); } catch {}
                try { renderCast(); } catch {}
                try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
                try { saveState(appState); } catch {}
              }
            } catch {}
            // Bomb is planted at night and becomes active on the NEXT day.
            try {
              const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "night_actions" && e.phase === "night" && e.day === f.day && e.data);
              const payload = ev && ev.data ? ev.data : null;
              const planted = !!(payload && payload.bombTarget !== null && payload.bombTarget !== undefined && Number.isFinite(Number(payload.bombTarget)));
              f.bombActive = planted;
              if (planted) {
                if (!f.draft || typeof f.draft !== "object") f.draft = {};
                if (!f.draft.bombByDay || typeof f.draft.bombByDay !== "object") f.draft.bombByDay = {};
                const nextDay = Math.max(1, (f.day || 1) + 1);
                const target = parseInt(payload.bombTarget, 10);
                const code = (payload.bombCode != null) ? String(payload.bombCode).trim() : "";
                f.draft.bombByDay[String(nextDay)] = {
                  target: Number.isFinite(target) ? target : null,
                  code: code || null,
                  plantedNight: Number(f.day || 1),
                  at: Date.now(),
                };
              }
            } catch {}
            // night -> next day
            f.phase = "day";
            f.day = Math.max(1, (f.day || 1) + 1);
            f.step = 0;
          }
          saveState(appState);
          showFlowTool();
        }

        function prevFlowStep() {
          const f = ensureFlow();
          if (f.step > 0) {
            f.step--;
            saveState(appState);
            showFlowTool();
            return;
          }
          // go back to previous phase end (simple)
          if (f.phase === "night") {
            f.phase = "day";
            f.step = Math.max(0, getFlowSteps({ ...f, phase: "day" }).length - 1);
          } else {
            // day -> previous night (if day>1)
            if ((f.day || 1) > 1) {
              f.day = Math.max(1, f.day - 1);
              f.phase = "night";
              f.step = Math.max(0, getFlowSteps({ ...f, phase: "night" }).length - 1);
            }
          }
          saveState(appState);
          showFlowTool();
        }

        function resetFlow() {
          if (!appState.god) appState.god = {};
          appState.god.flow = null;
          saveState(appState);
          showFlowTool();
        }

        function applyBombResultFromForm() {
          try {
            const f = ensureFlow();
            const draw = appState.draw;
            if (!draw || !draw.players) return false;
            const d = f.draft || {};
            if (!d.bombByDay || typeof d.bombByDay !== "object") d.bombByDay = {};
            if (!d.bombResolveByDay || typeof d.bombResolveByDay !== "object") d.bombResolveByDay = {};
            const rec = d.bombByDay[String(f.day)] || null;
            const targetIdx = (rec && rec.target !== null && rec.target !== undefined && Number.isFinite(Number(rec.target))) ? parseInt(rec.target, 10) : null;
            const code = (rec && rec.code != null) ? String(rec.code).trim() : "";
            const guardIdx = (() => {
              try {
                for (let i = 0; i < (draw.players || []).length; i++) {
                  const p = draw.players[i];
                  if (p && p.roleId === "guard" && p.alive !== false) return i;
                }
              } catch {}
              return null;
            })();
            const guardSac = !!(document.getElementById("fl_bomb_guard") && document.getElementById("fl_bomb_guard").checked && guardIdx !== null);
            const guardGuess = String(((document.getElementById("fl_bomb_guard_guess") || {}).value) || "").trim();
            const targetGuess = String(((document.getElementById("fl_bomb_target_guess") || {}).value) || "").trim();
            const guess = guardSac ? guardGuess : targetGuess;
            if (!code || targetIdx === null || guess === "") return false;
            const ok = (guess === code);
            let outcome = null;
            let killed = null;
            if (guardSac) {
              outcome = ok ? "neutralized_guard" : "guard_died";
              killed = ok ? null : guardIdx;
            } else {
              outcome = ok ? "neutralized_target" : "target_died";
              killed = ok ? null : targetIdx;
            }
            try {
              if (!d.bombAppliedByDay || typeof d.bombAppliedByDay !== "object") d.bombAppliedByDay = {};
              const key = String(f.day || 1);
              const prev = (d.bombAppliedByDay[key] && typeof d.bombAppliedByDay[key] === "object")
                ? d.bombAppliedByDay[key]
                : { killed: null, prevAlive: null };
              const desired = (killed !== null && Number.isFinite(Number(killed))) ? parseInt(killed, 10) : null;
              if (prev.killed !== null && Number.isFinite(Number(prev.killed))) {
                const pi = parseInt(prev.killed, 10);
                if (prev.prevAlive === true) {
                  try { setPlayerLife(pi, { alive: true }); } catch {}
                }
              }
              if (desired !== null) {
                const p = draw.players[desired];
                const wasAlive = p ? (p.alive !== false) : null;
                if (wasAlive) {
                  try { setPlayerLife(desired, { alive: false, reason: "bomb" }); } catch {}
                }
                prev.killed = desired;
                prev.prevAlive = wasAlive === true;
              } else {
                prev.killed = null;
                prev.prevAlive = null;
              }
              d.bombAppliedByDay[key] = prev;
            } catch {}
            d.bombResolveByDay[String(f.day)] = { guardSacrifice: guardSac, guardGuess, targetGuess, resolved: true, outcome, ok, killed, at: Date.now() };
            f.draft = d;
            f.bombActive = false;
            addFlowEvent("bomb_resolve", { day: f.day, target: targetIdx, code, guardSacrifice: guardSac, guess, ok, killed, outcome });
            saveState(appState);
            try { renderCast(); } catch {}
            try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
            return true;
          } catch {
            return false;
          }
        }

        function showFlowTool() {
          const draw = appState.draw;
          if (!draw || !draw.players || !draw.players.length) {
            openToolModal(t("tool.flow.title"), `<div class="toolBox">${escapeHtml(t("tool.flow.needDeal"))}</div>`);
            return;
          }
          const f = ensureFlow();
          const steps = getFlowSteps(f);
          const cur = steps[Math.min(steps.length - 1, Math.max(0, f.step || 0))];

          const scenario = getDrawScenarioForFlow();
          const names = getPlayerNamesForFlow();
          const aliveIdxs = (draw.players || []).map((p, idx) => (p && p.alive === false) ? null : idx).filter((x) => x !== null);
          const opts = [`<option value="">â€”</option>`].concat(
            names.map((nm, idx) => `<option value="${idx}">${escapeHtml(nm)}</option>`)
          ).join("");
          const optsAlive = [`<option value="">â€”</option>`].concat(
            aliveIdxs.map((idx) => `<option value="${idx}">${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</option>`)
          ).join("");

          // Detective inquiry rules:
          // - Many Iranian Mafia scenarios: Mafia leaders (Godfather/Don/Al Capone/Mafia Boss) show as "negative" (NOT mafia) to Detective.
          // - Some citizen roles (e.g., "Suspect") may show as "positive" (mafia) to Detective.
          // Sources used: scenario docs + common rules (e.g. tgmafia Godfather article).
          const detectiveInquiryIsMafia = (roleId) => {
            const rid = String(roleId || "citizen");
            // citizen-but-positive roles
            if (rid === "suspect") return true;
            // mafia-leader-but-negative roles
            if (rid === "godfather" || rid === "mafiaBoss" || rid === "danMafia" || rid === "alcapone") return false;
            const teamFa = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
            return teamFa === "Ù…Ø§ÙÛŒØ§";
          };

          // wake order list (re-use existing maps)
          const wake = (appLang === "en"
            ? (scenarioWakeOrderEn[scenario] || scenarioWakeOrderFa[scenario] || [])
            : (scenarioWakeOrderFa[scenario] || []));

          const stepCount = steps.length;
          const stepLine = t("tool.flow.step", { i: (Math.min(stepCount, (f.step || 0) + 1)), n: stepCount });
          // Only show bomb status when it is ACTIVE (hide "inactive" noise).
          const bombLine = (() => {
            if (!f.bombActive) return "";
            try {
              const d = f.draft || {};
              const rec = (d.bombByDay && d.bombByDay[String(f.day)]) ? d.bombByDay[String(f.day)] : null;
              if (!rec || rec.target === null || rec.target === undefined) return t("tool.flow.bomb.active");
              const nm = names[rec.target] || t("common.playerN", { n: rec.target + 1 });
              const code = (rec.code != null && String(rec.code).trim()) ? String(rec.code).trim() : "â€”";
              if (appLang === "fa") return `Ø¨Ù…Ø¨ Ø¬Ù„ÙˆÛŒ Â«${nm}Â» Ú©Ø§Ø´ØªÙ‡ Ø´Ø¯Ù‡ Ø§Ø³Øª (Ú©Ø¯: ${code}).`;
              return `Bomb is planted in front of â€œ${nm}â€ (code: ${code}).`;
            } catch {
              return t("tool.flow.bomb.active");
            }
          })();

          // step-specific body
          let body = "";
          if (cur.id === "day_bomb") {
            const d = f.draft || {};
            if (!d.bombByDay || typeof d.bombByDay !== "object") d.bombByDay = {};
            if (!d.bombResolveByDay || typeof d.bombResolveByDay !== "object") d.bombResolveByDay = {};
            // If we are BACK on the Bomb step, revert so editing is intuitive. Skip if we just applied from change handler.
            if (!bombApplyJustHappened) {
              try {
                const key = String(f.day || 1);
                if (!d.bombAppliedByDay || typeof d.bombAppliedByDay !== "object") d.bombAppliedByDay = {};
                const prev = (d.bombAppliedByDay[key] && typeof d.bombAppliedByDay[key] === "object") ? d.bombAppliedByDay[key] : null;
                if (prev && prev.killed !== null && prev.killed !== undefined && Number.isFinite(Number(prev.killed))) {
                  const pi = parseInt(prev.killed, 10);
                  if (prev.prevAlive === true) {
                    try { setPlayerLife(pi, { alive: true }); } catch {}
                  }
                  prev.killed = null;
                  prev.prevAlive = null;
                  d.bombAppliedByDay[key] = prev;
                }
                if (d.bombResolveByDay[key] && typeof d.bombResolveByDay[key] === "object") {
                  d.bombResolveByDay[key].resolved = false;
                  d.bombResolveByDay[key].outcome = null;
                }
                f.draft = d;
                saveState(appState);
              } catch {}
            }
            const rec = d.bombByDay[String(f.day)] || null;
            const targetIdx = (rec && rec.target !== null && rec.target !== undefined && Number.isFinite(Number(rec.target))) ? parseInt(rec.target, 10) : null;
            const targetName = (targetIdx !== null) ? (names[targetIdx] || t("common.playerN", { n: targetIdx + 1 })) : (appLang === "fa" ? "â€”" : "â€”");
            const plantedCode = (rec && rec.code != null && String(rec.code).trim()) ? String(rec.code).trim() : "";
            const guardIdx = (() => {
              try {
                for (let i = 0; i < (draw.players || []).length; i++) {
                  const p = draw.players[i];
                  if (p && p.roleId === "guard") return i;
                }
              } catch {}
              return null;
            })();
            const hasGuard = guardIdx !== null;
            const guardAlive = (guardIdx !== null && draw.players && draw.players[guardIdx]) ? (draw.players[guardIdx].alive !== false) : false;
            const guardName = (guardIdx !== null)
              ? (names[guardIdx] || t("common.playerN", { n: guardIdx + 1 }))
              : (appLang === "fa" ? "â€”" : "â€”");

            const r0 = (d.bombResolveByDay[String(f.day)] && typeof d.bombResolveByDay[String(f.day)] === "object")
              ? d.bombResolveByDay[String(f.day)]
              : { guardSacrifice: false, guardGuess: "", targetGuess: "", resolved: false, outcome: null };
            const mkCodeOpts = (sel) => {
              const s = String(sel ?? "").trim();
              const opts = [`<option value="" ${s === "" ? "selected" : ""}>â€”</option>`];
              for (let i = 1; i <= 4; i++) {
                const v = String(i);
                opts.push(`<option value="${v}" ${s === v ? "selected" : ""}>${v}</option>`);
              }
              return opts.join("");
            };
            const headline = (appLang === "fa")
              ? `Ø¨Ù…Ø¨ Ø¬Ù„ÙˆÛŒ Â«${targetName}Â» Ú©Ø§Ø´ØªÙ‡ Ø´Ø¯Ù‡ Ø§Ø³Øª${plantedCode ? ` (Ú©Ø¯: ${plantedCode})` : ""}.`
              : `Bomb is planted in front of â€œ${targetName}â€${plantedCode ? ` (code: ${plantedCode})` : ""}.`;
            // Keep bomb UI concise; detailed rules belong in Help.
            const guardLine = hasGuard
              ? (guardAlive ? "" : (appLang === "fa" ? `Ù…Ø­Ø§ÙØ¸ (${guardName}) Ù…Ø±Ø¯Ù‡ Ø§Ø³Øª.` : `Guard (${guardName}) is dead.`))
              : (appLang === "fa" ? "Ù…Ø­Ø§ÙØ¸ Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø§Ø²ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯." : "No Guard in this game.");

            const outcomeLine = (() => {
              // Live preview: updates as options change. If already applied, mark it as applied.
              if (!plantedCode) return "";
              const applied = !!(r0 && r0.resolved);
              const sac = !!(hasGuard && guardAlive && r0 && r0.guardSacrifice);
              const guardGuess = String((r0 && r0.guardGuess) || "").trim();
              const targetGuess = String((r0 && r0.targetGuess) || "").trim();
              const guess = sac ? guardGuess : targetGuess;
              const prefix = (appLang === "fa")
                ? (applied ? "Ù†ØªÛŒØ¬Ù‡ (Ø§Ø¹Ù…Ø§Ù„â€ŒØ´Ø¯Ù‡): " : "Ù†ØªÛŒØ¬Ù‡: ")
                : (applied ? "Result (applied): " : "Result: ");
              if (!guess) {
                return prefix + (appLang === "fa"
                  ? (sac ? "Ú©Ø¯Ù Ù…Ø­Ø§ÙØ¸ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯." : "Ø­Ø¯Ø³Ù Ù‡Ø¯Ù Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.")
                  : (sac ? "Pick Guard guess." : "Pick target guess."));
              }
              const ok = String(guess) === String(plantedCode);
              const o =
                sac
                  ? (ok ? "neutralized_guard" : "guard_died")
                  : (ok ? "neutralized_target" : "target_died");
              if (o === "neutralized_guard") return prefix + (appLang === "fa" ? "Ù…Ø­Ø§ÙØ¸ Ø¨Ù…Ø¨ Ø±Ø§ Ø®Ù†Ø«ÛŒ Ú©Ø±Ø¯." : "Guard neutralized the bomb.");
              if (o === "guard_died") return prefix + (appLang === "fa" ? "Ù…Ø­Ø§ÙØ¸ Ø§Ø´ØªØ¨Ø§Ù‡ Ø­Ø¯Ø³ Ø²Ø¯ Ùˆ Ù…Ø±Ø¯." : "Guard guessed wrong and died.");
              if (o === "neutralized_target") return prefix + (appLang === "fa" ? "Ù‡Ø¯Ù Ø¯Ø±Ø³Øª Ø­Ø¯Ø³ Ø²Ø¯ Ùˆ Ø¨Ù…Ø¨ Ø®Ù†Ø«ÛŒ Ø´Ø¯." : "Target guessed right; bomb neutralized.");
              if (o === "target_died") return prefix + (appLang === "fa" ? "Ù‡Ø¯Ù Ø§Ø´ØªØ¨Ø§Ù‡ Ø­Ø¯Ø³ Ø²Ø¯ Ùˆ Ù…Ø±Ø¯." : "Target guessed wrong and died.");
              return "";
            })();

            body = `
              <div class="note" style="margin-top:6px">${escapeHtml(headline)}</div>
              <div style="height:10px"></div>
              ${guardLine ? `<div class="note">${escapeHtml(guardLine)}</div><div style="height:10px"></div>` : ``}
              <div style="height:14px"></div>
              ${hasGuard ? `
                <label for="fl_bomb_guard" style="display:flex; flex-direction:row; align-items:center; justify-content:space-between; gap:14px; font-weight:950; cursor:pointer; user-select:none; -webkit-user-select:none">
                  <span>${escapeHtml(appLang === "fa" ? "Ù…Ø­Ø§ÙØ¸ ÙØ¯Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŸ" : "Does Guard sacrifice?")}</span>
                  <input id="fl_bomb_guard" type="checkbox" ${r0.guardSacrifice ? "checked" : ""} ${guardAlive ? "" : "disabled"} style="width:24px; height:24px; margin:0; accent-color: var(--primary)" />
                </label>
                <div style="height:10px"></div>
              ` : ``}
              ${hasGuard && r0.guardSacrifice ? `
                <label>${escapeHtml(appLang === "fa" ? `Ø­Ø¯Ø³Ù Ù…Ø­Ø§ÙØ¸ (${guardName})` : `Guard (${guardName}) guess`)}
                  <select id="fl_bomb_guard_guess">${mkCodeOpts(r0.guardGuess)}</select>
                </label>
              ` : `
                <label>${escapeHtml(appLang === "fa" ? `Ø­Ø¯Ø³Ù ${targetName}` : `${targetName} guess`)}
                  <select id="fl_bomb_target_guess">${mkCodeOpts(r0.targetGuess)}</select>
                </label>
              `}
              ${outcomeLine ? `<div class="note" style="margin-top:10px; font-weight:950">${escapeHtml(outcomeLine)}</div>` : ``}
              <div class="note" style="margin-top:10px">${escapeHtml(appLang === "fa" ? "Ø¨Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ø­Ø¯Ø³ØŒ Ù†ØªÛŒØ¬Ù‡ Ø¨Ù„Ø§ÙØ§ØµÙ„Ù‡ Ø§Ø¹Ù…Ø§Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯Ø› Â«Ø¨Ø¹Ø¯ÛŒÂ» Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ø§Ù…Ù‡." : "Your choice applies immediately. Press \"Next\" to continue.")}</div>
            `;
          } else if (cur.id === "day_vote") {
            const d = f.draft || {};
            if (!d.voteCountsByDay || typeof d.voteCountsByDay !== "object") d.voteCountsByDay = {};
            const saved = (d.voteCountsByDay && d.voteCountsByDay[f.day]) ? d.voteCountsByDay[f.day] : null;
            const todayOutIdx = (() => {
              try {
                const ev = (f.events || []).slice().reverse().find((e) =>
                  e && e.kind === "day_elim_out" && e.phase === "day" && e.day === f.day && e.data && e.data.out !== null && e.data.out !== undefined && Number.isFinite(Number(e.data.out))
                );
                if (ev && ev.data && ev.data.out !== null && ev.data.out !== undefined && Number.isFinite(Number(ev.data.out))) return parseInt(ev.data.out, 10);
              } catch {}
              return null;
            })();
            const includeOutForVoteMax = !!(todayOutIdx !== null && draw.players && draw.players[todayOutIdx] && draw.players[todayOutIdx].alive === false);
            const votersAtVote = aliveIdxs.length + (includeOutForVoteMax ? 1 : 0);
            const maxVotes = Math.max(0, votersAtVote - 1);
            const mkVoteOpts = (sel) => {
              const s = Math.max(0, Math.min(maxVotes, Math.floor(Number(sel || 0))));
              const out = [];
              for (let i = 0; i <= maxVotes; i++) {
                out.push(`<option value="${i}" ${i === s ? "selected" : ""}>${i}</option>`);
              }
              return out.join("");
            };

            // Show alive players. Also show the player voted out TODAY (so votes can be corrected),
            // but do not show people eliminated on previous days.
            const listIdxs = aliveIdxs.concat(
              (todayOutIdx !== null && !aliveIdxs.includes(todayOutIdx)) ? [todayOutIdx] : []
            );
            const rows = listIdxs.map((idx) => {
              const val = saved && typeof saved[idx] === "number" ? saved[idx] : (saved && typeof saved[String(idx)] === "number" ? saved[String(idx)] : 0);
              const isDead = (draw.players && draw.players[idx]) ? (draw.players[idx].alive === false) : false;
              const isTodayOut = (todayOutIdx !== null && idx === todayOutIdx);
              const st = isDead ? "opacity:.55; filter:saturate(.2);" : "";
              const outTxt = isDead ? ` <span style="color:var(--muted); font-weight:900">(${escapeHtml(appLang === "fa" ? "Ø®Ø§Ø±Ø¬ Ø´Ø¯" : "out")})</span>` : "";
              return `
                <div style="display:grid; grid-template-columns: 1fr 120px; gap:10px; align-items:center; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.06); ${st}">
                  <div style="font-weight:1100">${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}${outTxt}</div>
                  <select id="fl_vote_${idx}" ${(isDead && !isTodayOut) ? "disabled" : ""}>${mkVoteOpts(val)}</select>
                </div>
              `;
            }).join("");

            const showBombWarn = !!(f.day >= 2 && f.bombActive && !(f.draft && f.draft.bombTriggeredOnce));
            body = `
              <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.vote.hint"))}</div>
              ${showBombWarn ? `<div class="note" style="margin-top:10px; font-weight:950">${escapeHtml(t("tool.flow.bomb.active"))}</div>` : ``}
              <div style="height:10px"></div>
              <div style="display:flex; align-items:baseline; justify-content:space-between; gap:10px">
                <div style="font-weight:1100">${escapeHtml(t("tool.flow.day.vote"))}</div>
                <div style="color:var(--muted); font-weight:900; font-size:12px">${escapeHtml(t("tool.flow.vote.votes"))}</div>
              </div>
              <div style="height:6px"></div>
              <div style="border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px; background: rgba(17,24,36,.25); max-height: 46vh; overflow:auto; -webkit-overflow-scrolling: touch;">
                ${rows || `<div style="color:var(--muted); font-weight:900">${escapeHtml(appLang === "fa" ? "Ø¨Ø§Ø²ÛŒÚ©Ù† Ø²Ù†Ø¯Ù‡â€ŒØ§ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯." : "No alive players.")}</div>`}
              </div>
              <div style="height:10px"></div>
              <div class="actions" style="justify-content:flex-start; gap:10px">
                <div class="note" style="margin-top:2px">${escapeHtml(appLang === "fa" ? "Ø¨Ø§ Ø²Ø¯Ù† Â«Ø¨Ø¹Ø¯ÛŒÂ»ØŒ Ø±Ø£ÛŒâ€ŒÙ‡Ø§ Ø«Ø¨Øª Ù…ÛŒâ€ŒØ´ÙˆØ¯." : "Press â€œNextâ€ to record votes.")}</div>
              </div>
            `;
          } else if (cur.id === "day_defense") {
            const d = f.draft || {};
            const voters = aliveIdxs.length;
            const eligibleVoters = Math.max(0, voters - 1); // candidate cannot vote for self
            const threshold = Math.floor(eligibleVoters / 2) + 1; // bigger than half of eligible voters
            const counts = (d.voteCountsByDay && d.voteCountsByDay[f.day] && typeof d.voteCountsByDay[f.day] === "object")
              ? d.voteCountsByDay[f.day]
              : null;

            if (!counts) {
              body = `
                <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.defense.needVotes"))}</div>
              `;
            } else {
              const defenders = aliveIdxs
                .map((idx) => {
                  const v = (typeof counts[idx] === "number") ? counts[idx] : (typeof counts[String(idx)] === "number" ? counts[String(idx)] : 0);
                  return { idx, v: Math.max(0, Math.floor(Number(v || 0))) };
                })
                .filter((x) => x.v >= threshold)
                .sort((a, b) => (b.v - a.v) || (a.idx - b.idx));

              const listHtml = defenders.length
                ? defenders.map((x) => `
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px 0; border-bottom:1px solid rgba(255,255,255,.06)">
                      <div style="font-weight:1100">${escapeHtml(names[x.idx] || t("common.playerN", { n: x.idx + 1 }))}</div>
                      <div style="color:var(--muted); font-weight:950">${escapeHtml(String(x.v))}</div>
                    </div>
                  `).join("")
                : `<div style="color:var(--muted); font-weight:900">${escapeHtml(t("tool.flow.defense.none"))}</div>`;

              body = `
                <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.defense.hint"))}</div>
                <div style="height:10px"></div>
                <div class="note">${escapeHtml(t("tool.flow.defense.threshold", { n: threshold, v: eligibleVoters }))}</div>
                <div style="height:10px"></div>
                <div style="display:flex; align-items:baseline; justify-content:space-between; gap:10px">
                  <div style="font-weight:1100">${escapeHtml(t("tool.flow.defense.list"))}</div>
                  <div style="color:var(--muted); font-weight:900; font-size:12px">${escapeHtml(appLang === "fa" ? "Ø±Ø£ÛŒ" : "Votes")}</div>
                </div>
                <div style="height:6px"></div>
                <div style="border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px; background: rgba(17,24,36,.25); max-height: 46vh; overflow:auto; -webkit-overflow-scrolling: touch;">
                  ${listHtml}
                </div>
              `;
            }
          } else if (cur.id === "day_elim") {
            const d = f.draft || {};
            const votersAtVote = (d.voteVotersByDay && typeof d.voteVotersByDay[f.day] === "number")
              ? Math.max(0, Math.floor(Number(d.voteVotersByDay[f.day] || 0)))
              : aliveIdxs.length;
            const eligibleVoters = Math.max(0, votersAtVote - 1); // candidate cannot vote for self
            const defThreshold = Math.floor(eligibleVoters / 2) + 1; // majority to enter defense list
            // Load votes: prefer latest day_vote event (source of truth), fallback to draft.
            let dayCounts = null;
            try {
              const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "day_vote" && e.phase === "day" && e.day === f.day && e.data && e.data.counts);
              if (ev && ev.data && ev.data.counts && typeof ev.data.counts === "object") dayCounts = ev.data.counts;
            } catch {}
            if (!dayCounts) {
              dayCounts = (d.voteCountsByDay && d.voteCountsByDay[f.day] && typeof d.voteCountsByDay[f.day] === "object")
                ? d.voteCountsByDay[f.day]
                : null;
            }
            // Keep draft in sync so the UI stays consistent even if we came from older saves.
            if (dayCounts && typeof dayCounts === "object") {
              try {
                if (!d.voteCountsByDay || typeof d.voteCountsByDay !== "object") d.voteCountsByDay = {};
                d.voteCountsByDay[f.day] = dayCounts;
                f.draft = d;
                saveState(appState);
              } catch {}
            }
            const roster = (() => {
              try {
                const r = (d.voteRosterByDay && Array.isArray(d.voteRosterByDay[f.day])) ? d.voteRosterByDay[f.day] : null;
                if (r && r.length) return r.slice();
              } catch {}
              // fallback: consider keys in dayCounts
              try {
                if (dayCounts && typeof dayCounts === "object") {
                  return Object.keys(dayCounts).map((k) => parseInt(k, 10)).filter((x) => Number.isFinite(x));
                }
              } catch {}
              return aliveIdxs.slice();
            })();
            const candidatesBase = dayCounts
              ? roster
                  .map((idx) => {
                    const v = (typeof dayCounts[idx] === "number") ? dayCounts[idx] : (typeof dayCounts[String(idx)] === "number" ? dayCounts[String(idx)] : 0);
                    return { idx, v: Math.max(0, Math.floor(Number(v || 0))) };
                  })
                  .filter((x) => x.v >= defThreshold)
                  .sort((a, b) => (b.v - a.v) || (a.idx - b.idx))
              : [];
            if (!d.elimCandidatesByDay || typeof d.elimCandidatesByDay !== "object") d.elimCandidatesByDay = {};
            // Keep defense list LIVE (derived from latest voting).
            const defenseList = candidatesBase.map((x) => x.idx);
            const prevList = Array.isArray(d.elimCandidatesByDay[f.day]) ? d.elimCandidatesByDay[f.day] : [];
            const changed = JSON.stringify(prevList || []) !== JSON.stringify(defenseList || []);
            d.elimCandidatesByDay[f.day] = defenseList;

            // If the defense list changed (due to editing Voting), reset elimination votes/picks and clear any previous out.
            if (changed) {
              if (!d.elimVotesByDay || typeof d.elimVotesByDay !== "object") d.elimVotesByDay = {};
              d.elimVotesByDay[f.day] = {};
              d.elimLeadersByDay = (d.elimLeadersByDay && typeof d.elimLeadersByDay === "object") ? d.elimLeadersByDay : {};
              d.elimLeadersByDay[f.day] = [];
              d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
              d.elimPickedByDay[f.day] = null;
              try { addFlowEvent("day_elim_out", { out: null, reset: true }); } catch {}
              try { applyDayElimFromPayload(f, { out: null }); } catch {}
              try { renderCast(); } catch {}
              try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
            }
            f.draft = d;
            try { saveState(appState); } catch {}

            const candIdxs = Array.isArray(d.elimCandidatesByDay[f.day]) ? d.elimCandidatesByDay[f.day] : defenseList;
            const elimThreshold = defThreshold; // single-defendant: need majority to be out
            const isSingleDef = candIdxs.length === 1;

            if (!d.elimVotesByDay || typeof d.elimVotesByDay !== "object") d.elimVotesByDay = {};
            const saved = (d.elimVotesByDay && d.elimVotesByDay[f.day]) ? d.elimVotesByDay[f.day] : null;
            const maxVotes = Math.max(0, aliveIdxs.length - 1);
            const mkVoteOpts = (sel) => {
              const s = Math.max(0, Math.min(maxVotes, Math.floor(Number(sel || 0))));
              const out = [];
              for (let i = 0; i <= maxVotes; i++) out.push(`<option value="${i}" ${i === s ? "selected" : ""}>${i}</option>`);
              return out.join("");
            };

            const rows = candIdxs.map((idx) => {
              const val = saved && typeof saved[idx] === "number" ? saved[idx] : (saved && typeof saved[String(idx)] === "number" ? saved[String(idx)] : 0);
              const alive = (draw.players && draw.players[idx]) ? (draw.players[idx].alive !== false) : true;
              const st = alive ? "" : "opacity:.55; filter:saturate(.2);";
              const outTxt = alive ? "" : ` <span style="color:var(--muted); font-weight:900">(${escapeHtml(appLang === "fa" ? "Ø®Ø§Ø±Ø¬ Ø´Ø¯" : "out")})</span>`;
              return `
                <div style="display:grid; grid-template-columns: 1fr 120px; gap:10px; align-items:center; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.06); ${st}">
                  <div style="font-weight:1100">${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}${outTxt}</div>
                  <select id="fl_elim_${idx}">${mkVoteOpts(val)}</select>
                </div>
              `;
            }).join("");

            // compute current result from saved elimination votes (if any)
            const savedCounts = (saved && typeof saved === "object") ? saved : null;
            const leaders = savedCounts
              ? Object.keys(savedCounts)
                  .map((k) => ({ idx: parseInt(k, 10), v: Math.max(0, Math.floor(Number(savedCounts[k] || 0))) }))
                  .filter((x) => Number.isFinite(x.idx))
                  .sort((a, b) => (b.v - a.v) || (a.idx - b.idx))
              : [];
            const best = leaders.length ? leaders[0].v : 0;
            const top = (best > 0) ? leaders.filter((x) => x.v === best) : [];
            const picked = (d.elimPickedByDay && d.elimPickedByDay[f.day] !== undefined) ? d.elimPickedByDay[f.day] : null;
            const pickedIdx = (() => {
              const n = parseInt(String(picked ?? ""), 10);
              return Number.isFinite(n) ? n : null;
            })();
            // Fallback: if we have a saved draw event for today, use it (prevents losing the picked tie-winner).
            const pickedIdxFromEvent = (() => {
              try {
                const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "day_elim_draw" && Number(e.day) === Number(f.day));
                const p = ev && ev.data ? ev.data.picked : null;
                const n = parseInt(String(p ?? ""), 10);
                return Number.isFinite(n) ? n : null;
              } catch {
                return null;
              }
            })();
            const pickedIdxFinal = (pickedIdx !== null && Number.isFinite(pickedIdx))
              ? pickedIdx
              : (pickedIdxFromEvent !== null && top.some((x) => x.idx === pickedIdxFromEvent))
                ? pickedIdxFromEvent
                : null;
            // If we recovered from events, persist it.
            if ((pickedIdxFinal !== null) && (pickedIdx === null || !Number.isFinite(pickedIdx))) {
              try {
                d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
                d.elimPickedByDay[f.day] = pickedIdxFinal;
                f.draft = d;
                saveState(appState);
              } catch {}
            }
            const showActions = !!(top.length && best > 0);
            const showDraw = top.length > 1;
            const canOut = (top.length === 1) || (pickedIdxFinal !== null && Number.isFinite(pickedIdxFinal));

            // Inline "who was voted out" + Last Move (shown only when a single person is picked).
            const pickedOutIdx = (() => {
              try {
                if (isSingleDef) {
                  const only = candIdxs[0];
                  const v = savedCounts && (typeof savedCounts[only] === "number" || typeof savedCounts[String(only)] === "number")
                    ? (typeof savedCounts[only] === "number" ? savedCounts[only] : savedCounts[String(only)])
                    : 0;
                  const vv = Math.max(0, Math.floor(Number(v || 0)));
                  return (vv >= elimThreshold) ? only : null;
                }
                if (!showActions) return null;
                if (top.length === 1) return top[0].idx;
                if (pickedIdxFinal !== null && Number.isFinite(pickedIdxFinal)) return pickedIdxFinal;
                return null;
              } catch {
                return null;
              }
            })();
            const supportsLastMove = (getScenario() === "shab_mafia");
            const showLastMove = !!(pickedOutIdx !== null && supportsLastMove);
            const supportsEndCards = (getScenario() === "pedarkhande");
            const endCardLine = (() => {
              try {
                if (!supportsEndCards) return "";
                if (pickedOutIdx === null || !Number.isFinite(Number(pickedOutIdx))) return "";

                // End cards deck (Godfather scenario): draw one random card for the voted-out player.
                // Godfather End Cards (per Whitesho): 6 cards, can repeat day-to-day.
                const endCards = [
                  { id: "silence_lambs", fa: "Ø³Ú©ÙˆØª Ø¨Ø±Ù‡â€ŒÙ‡Ø§", en: "Silence of the Lambs" },
                  { id: "identity_reveal", fa: "Ø§ÙØ´Ø§ÛŒ Ù‡ÙˆÛŒØª", en: "Identity reveal" },
                  { id: "beautiful_mind", fa: "Ø°Ù‡Ù† Ø²ÛŒØ¨Ø§", en: "Beautiful Mind" },
                  { id: "handcuffs", fa: "Ø¯Ø³ØªØ¨Ù†Ø¯", en: "Handcuffs" },
                  { id: "face_change", fa: "ØªØºÛŒÛŒØ± Ú†Ù‡Ø±Ù‡", en: "Face change" },
                  { id: "duel", fa: "Ø¯ÙˆØ¦Ù„", en: "Duel" },
                ];
                const labelFor = (id) => {
                  const c = endCards.find((x) => x.id === id);
                  if (!c) return String(id || "");
                  return appLang === "fa" ? c.fa : c.en;
                };
                if (!appState.god) appState.god = {};
                if (!appState.god.endCards || typeof appState.god.endCards !== "object") {
                  appState.god.endCards = { byDay: {} };
                }
                if (!appState.god.endCards.byDay || typeof appState.god.endCards.byDay !== "object") appState.god.endCards.byDay = {};
                const byDay = appState.god.endCards.byDay;
                const dayKey = String(f.day || 1);
                const existing = byDay[dayKey] && typeof byDay[dayKey] === "object" ? byDay[dayKey] : null;
                // If day assignment exists but for a different player, reset it.
                if (existing && Number.isFinite(Number(existing.out)) && parseInt(existing.out, 10) !== parseInt(pickedOutIdx, 10)) {
                  delete byDay[dayKey];
                }
                let rec = byDay[dayKey] && typeof byDay[dayKey] === "object" ? byDay[dayKey] : null;
                if (!rec || !rec.cardId) {
                  const picked = endCards[Math.floor(Math.random() * endCards.length)];
                  rec = { out: parseInt(pickedOutIdx, 10), cardId: picked.id, at: Date.now() };
                  byDay[dayKey] = rec;
                  saveState(appState);
                }
                const nm = names[pickedOutIdx] || t("common.playerN", { n: pickedOutIdx + 1 });
                const cardLabel = labelFor(rec.cardId);
                return `<div class="note" style="margin-top:10px; font-weight:950">${escapeHtml(t("tool.flow.endCards.for", { name: nm, card: cardLabel }))}</div>`;
              } catch {
                return "";
              }
            })();
            const tieLine = (() => {
              try {
                if (!showActions) return "";
                if (top.length <= 1) return "";
                if (pickedOutIdx !== null) return "";
                const tieNames = top.map((x) => `${names[x.idx] || t("common.playerN", { n: x.idx + 1 })} (${x.v})`);
                return `${t("tool.flow.elim.tie")}: ${t("tool.flow.elim.notChosenYet")} â€¢ ${tieNames.join(appLang === "fa" ? "ØŒ " : ", ")}`;
              } catch {
                return "";
              }
            })();

            const singleLine = (() => {
              try {
                if (!isSingleDef) return "";
                const only = candIdxs[0];
                const v = savedCounts && (typeof savedCounts[only] === "number" || typeof savedCounts[String(only)] === "number")
                  ? (typeof savedCounts[only] === "number" ? savedCounts[only] : savedCounts[String(only)])
                  : 0;
                const vv = Math.max(0, Math.floor(Number(v || 0)));
                if (vv >= elimThreshold) return "";
                return t("tool.flow.elim.single.notEnough", { c: vv, n: elimThreshold });
              } catch {
                return "";
              }
            })();
            const lastMoveUi = (() => {
              if (!showLastMove) return "";
              try {
                const lastMoveCards = [
                  { id: "insomnia", fa: "Ø¨ÛŒâ€ŒØ®ÙˆØ§Ø¨ÛŒ", en: "Insomnia" },
                  { id: "final_shot", fa: "Ø´Ù„ÛŒÚ© Ù†Ù‡Ø§ÛŒÛŒ", en: "Final Shot" },
                  { id: "beautiful_mind", fa: "Ø°Ù‡Ù† Ø²ÛŒØ¨Ø§", en: "Beautiful Mind" },
                  { id: "thirteen_lies", fa: "Ø¯Ø±ÙˆØº Ø³ÛŒØ²Ø¯Ù‡", en: "Thirteen Lies" },
                  { id: "green_mile", fa: "Ù…Ø³ÛŒØ± Ø³Ø¨Ø²", en: "Green Mile" },
                  { id: "red_carpet", fa: "ÙØ±Ø´ Ù‚Ø±Ù…Ø²", en: "Red Carpet" },
                ];
                const labelFor = (id) => {
                  const c = lastMoveCards.find((x) => x.id === id);
                  if (!c) return String(id || "");
                  return appLang === "fa" ? c.fa : c.en;
                };
                if (!appState.god.lastMove || typeof appState.god.lastMove !== "object") {
                  appState.god.lastMove = { last: null, at: null, used: [] };
                } else {
                  if (!Array.isArray(appState.god.lastMove.used)) appState.god.lastMove.used = [];
                }
                const used = new Set(appState.god.lastMove.used || []);
                const remaining = lastMoveCards.filter((c) => !used.has(c.id));
                const lastId = appState.god.lastMove && appState.god.lastMove.last ? appState.god.lastMove.last : null;
                const last = lastId ? labelFor(lastId) : null;
                const listHtml = lastMoveCards.map((c) => {
                  const isUsed = used.has(c.id);
                  const txt = labelFor(c.id);
                  const st = isUsed ? 'opacity:.45; filter:saturate(.2); text-decoration:line-through;' : '';
                  return `<div style="padding:6px 0;font-weight:950;${st}">${escapeHtml(txt)}</div>`;
                }).join("");
                return `
                  <div style="height:12px"></div>
                  <div style="font-weight:1100">${escapeHtml(t("tool.flow.outcome.lastMove"))}</div>
                  <div style="height:8px"></div>
                  <div style="border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px; background: rgba(17,24,36,.25); max-height: 34vh; overflow:auto; -webkit-overflow-scrolling: touch;">
                    <div style="font-weight:1100;margin-bottom:8px">${escapeHtml(t("tool.lastMove.header"))}</div>
                    ${listHtml}
                  </div>
                  <div style="height:10px"></div>
                  <button class="btn primary" id="lm_draw_elim" type="button" ${remaining.length ? "" : "disabled"}>${escapeHtml(t("tool.lastMove.draw"))}</button>
                  <div class="note" id="lm_note_elim" style="${remaining.length ? "display:none" : "display:block"}; margin-top:10px">${escapeHtml(remaining.length ? "" : t("tool.lastMove.allUsed"))}</div>
                  <div style="height:10px"></div>
                  <div style="font-weight:1100">${escapeHtml(t("tool.lastMove.result"))} <span id="lm_res_elim">${last ? escapeHtml(last) : "â€”"}</span></div>
                `;
              } catch {
                return "";
              }
            })();

            body = `
              <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.elim.hint"))}</div>
              <div style="height:8px"></div>
              <div class="note">${escapeHtml(t("tool.flow.defense.threshold", { n: defThreshold, v: eligibleVoters }))}</div>
              ${isSingleDef ? `<div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.elim.single.need", { n: elimThreshold, v: eligibleVoters }))}</div>` : ``}
              <div style="height:10px"></div>
              <div style="display:flex; align-items:baseline; justify-content:space-between; gap:10px">
                <div style="font-weight:1100">${escapeHtml(t("tool.flow.day.eliminate"))}</div>
                <div style="color:var(--muted); font-weight:900; font-size:12px">${escapeHtml(t("tool.flow.elim.votes"))}</div>
              </div>
              <div style="height:6px"></div>
              <div style="border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px; background: rgba(17,24,36,.25); max-height: 46vh; overflow:auto; -webkit-overflow-scrolling: touch;">
                ${dayCounts ? (rows || `<div style="color:var(--muted); font-weight:900">${escapeHtml(t("tool.flow.elim.noCandidates"))}</div>`) : `<div style="color:var(--muted); font-weight:900">${escapeHtml(t("tool.flow.defense.needVotes"))}</div>`}
              </div>
              <div style="height:10px"></div>
              <div class="actions" style="justify-content:flex-start; gap:10px">
                <div class="note" style="margin-top:2px">${escapeHtml(appLang === "fa" ? "Ø¨Ø§ Ø²Ø¯Ù† Â«Ø¨Ø¹Ø¯ÛŒÂ»ØŒ Ù†ØªÛŒØ¬Ù‡ Ø«Ø¨Øª Ù…ÛŒâ€ŒØ´ÙˆØ¯." : "Press â€œNextâ€ to record the result.")}</div>
              </div>
              <div class="actions" id="fl_elim_actions" style="margin-top:10px; ${showActions ? "display:flex" : "display:none"}; justify-content:flex-start; gap:10px">
                <button class="btn" id="fl_elim_draw" type="button" style="${showDraw ? "" : "display:none"}">${escapeHtml(t("tool.flow.elim.draw"))}</button>
              </div>
              <div style="margin-top:14px; padding-top:12px; border-top:1px solid rgba(255,255,255,.08)">
                ${pickedOutIdx !== null
                  ? `<div class="note" style="font-weight:950">${escapeHtml(t("tool.flow.outcome.votedOut"))} <b>${escapeHtml(names[pickedOutIdx] || t("common.playerN", { n: pickedOutIdx + 1 }))}</b></div>`
                  : (tieLine
                      ? `<div class="note" style="font-weight:950">${escapeHtml(tieLine)}</div>`
                      : (singleLine
                          ? `<div class="note" style="font-weight:950">${escapeHtml(singleLine)}</div>`
                          : `<div class="note" style="font-weight:950">${escapeHtml(t("tool.flow.outcome.none"))}</div>`))}
                ${endCardLine}
                ${lastMoveUi}
              </div>
            `;
          } else if (cur.id === "night_run") {
            const d = f.draft || {};
            const evenNight = ((f.day || 1) % 2 === 0);
            const nightKey = String(f.day || 1);
            // Load saved actions for this night: prefer per-night draft, fallback to latest event.
            if (!d.nightActionsByNight || typeof d.nightActionsByNight !== "object") d.nightActionsByNight = {};
            const savedNight = (() => {
              try {
                const byNight = (d.nightActionsByNight && d.nightActionsByNight[nightKey]) ? d.nightActionsByNight[nightKey] : null;
                if (byNight && typeof byNight === "object") return byNight;
              } catch {}
              try {
                const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "night_actions" && e.phase === "night" && e.day === f.day && e.data);
                if (ev && ev.data && typeof ev.data === "object") return ev.data;
              } catch {}
              return {};
            })();
            // Options for targeting alive players, but keep the selected value visible even if they died
            // due to an immediately-applied action (e.g., Mafia shot).
            const mkAliveOptsSel = (sel) => {
              const sIdx = (sel === null || sel === undefined || sel === "") ? null : parseInt(sel, 10);
              const s = (sIdx === null || !Number.isFinite(sIdx)) ? "" : String(sIdx);
              const base = [`<option value="" ${s === "" ? "selected" : ""}>â€”</option>`];
              for (const idx of aliveIdxs) {
                const v = String(idx);
                base.push(`<option value="${v}" ${v === s ? "selected" : ""}>${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</option>`);
              }
              // If selected is not currently alive, still show it (muted/out) so UI retains the choice.
              if (s !== "" && !aliveIdxs.includes(sIdx) && draw.players && draw.players[sIdx]) {
                const nm = names[sIdx] || t("common.playerN", { n: sIdx + 1 });
                const outTxt = appLang === "fa" ? " (Ø®Ø§Ø±Ø¬ Ø´Ø¯)" : " (out)";
                base.push(`<option value="${s}" selected>${escapeHtml(nm + outTxt)}</option>`);
              }
              return base.join("");
            };

            const normWake = (s) => {
              const x = String(s || "").toLowerCase();
              if (x.includes("mafia") || x.includes("Ù…Ø§ÙÛŒØ§")) return "mafia";
              if (x.includes("professional") || x.includes("Ø­Ø±ÙÙ‡")) return "professional";
              if (x.includes("detective") || x.includes("Ú©Ø§Ø±Ø¢Ú¯Ø§Ù‡")) return "detective";
              if (x.includes("doctor") || x.includes("Ù¾Ø²Ø´Ú©") || x.includes("Ø¯Ú©ØªØ±")) return "doctor";
              if (x.includes("watson")) return "doctor";
              if (x.includes("bomber") || x.includes("Ø¨Ù…Ø¨")) return "bomber";
              if (x.includes("magician") || x.includes("Ø´Ø¹Ø¨Ø¯Ù‡") || x.includes("Ø´ÙˆÙˆÙ…Ù†") || x.includes("Ø´ÙˆÙ…Ù†")) return "magician";
              if (x.includes("zodiac") || x.includes("Ø²ÙˆØ¯ÛŒØ§Ú©")) return "zodiac";
              if (x.includes("gunslinger") || x.includes("gunner") || x.includes("ØªÙÙ†Ú¯Ø¯Ø§Ø±")) return "gunslinger";
              if (x.includes("ocean") || x.includes("Ø§ÙˆØ´Ù†")) return "ocean";
              if (x.includes("leon") || x.includes("Ù„Ø¦ÙˆÙ†")) return "professional";
              if (x.includes("citizen kane") || x.includes("kane") || x.includes("Ú©ÛŒÙ†")) return "kane";
              if (x.includes("constantine") || x.includes("Ú©Ù†Ø³ØªØ§Ù†ØªÛŒÙ†")) return "constantine";
              if (x.includes("nostradamus") || x.includes("Ù†ÙˆØ³ØªØ±Ø§Ø¯Ø§Ù…ÙˆØ³")) return "nostradamus";
              if (x.includes("heir") || x.includes("ÙˆØ§Ø±Ø«")) return "heir";
              if (x.includes("herbalist") || x.includes("attar") || x.includes("Ø¹Ø·Ø§Ø±")) return "herbalist";
              if (x.includes("armorsmith") || x.includes("Ø²Ø±Ù‡")) return "armorsmith";
              return "other";
            };

            // Gunslinger support (give guns)
            const gunnerIdxs = (draw.players || [])
              .map((p, idx) => (p && p.roleId === "gunslinger" && p.alive !== false) ? idx : null)
              .filter((x) => x !== null);
            const showGunner = !!gunnerIdxs.length;
            const gunnerIdx = showGunner ? gunnerIdxs[0] : null;
            const gunnerName = (gunnerIdx !== null && Number.isFinite(gunnerIdx))
              ? (names[gunnerIdx] || t("common.playerN", { n: gunnerIdx + 1 }))
              : "â€”";
            const guns = f.guns || {};
            const givenCount = Object.keys(guns || {}).length;
            if (!d.nightGunGivesByNight || typeof d.nightGunGivesByNight !== "object") d.nightGunGivesByNight = {};
            const nightGives = Array.isArray(d.nightGunGivesByNight[nightKey]) ? d.nightGunGivesByNight[nightKey] : [];
            const nightGiveCount = nightGives.length;
            const nightRealCount = nightGives.filter((x) => x && x.type === "real").length;

            const noActionTxt = (appLang === "fa")
              ? "Ø§Ú©Ø´Ù†ÛŒ Ø¨Ø±Ø§ÛŒ Ø«Ø¨Øª Ù†Ø¯Ø§Ø±Ø¯."
              : "No action to record.";

            const sectionFor = (wakeLabel) => {
              const k = normWake(wakeLabel);
              if (k === "mafia") {
                return `
                  <label>${escapeHtml(t("tool.flow.action.mafiaShot"))}
                    <select id="fl_mafia_shot">${mkAliveOptsSel(savedNight.mafiaShot)}</select>
                  </label>
                `;
              }
              if (k === "professional") {
                return `
                  <label>${escapeHtml(t("tool.flow.action.professionalShot"))}
                    <select id="fl_pro_shot">${mkAliveOptsSel(savedNight.professionalShot)}</select>
                  </label>
                `;
              }
              if (k === "detective") {
                // Show last saved detective result (per night/day) if present
                const key = String(f.day || 1);
                const dr = (d && d.detectiveResultByNight && d.detectiveResultByNight[key]) ? d.detectiveResultByNight[key] : null;
                const resultLine = (() => {
                  if (!dr || dr.isMafia === undefined || dr.isMafia === null) return "";
                  const isM = !!dr.isMafia;
                  const thumb = isM ? "ğŸ‘" : "ğŸ‘";
                  const label = (appLang === "fa")
                    ? (isM ? "Ù…Ø§ÙÛŒØ§" : "Ø´Ù‡Ø±ÙˆÙ†Ø¯")
                    : (isM ? "Mafia" : "Citizen");
                  const pre = (appLang === "fa") ? "Ù†ØªÛŒØ¬Ù‡ Ø§Ø³ØªØ¹Ù„Ø§Ù…: " : "Result: ";
                  return `${pre}${thumb} ${label}`;
                })();
                return `
                  <label>${escapeHtml(t("tool.flow.action.detectiveQuery"))}
                    <select id="fl_det_query">${mkAliveOptsSel(savedNight.detectiveQuery)}</select>
                  </label>
                  <div id="fl_det_result" class="note" style="margin-top:6px; ${resultLine ? "" : "display:none"}">${escapeHtml(resultLine || "")}</div>
                `;
              }
              if (k === "doctor") {
                return `
                  <label>${escapeHtml(t("tool.flow.action.doctorSave"))}
                    <select id="fl_doctor_save">${mkAliveOptsSel(savedNight.doctorSave)}</select>
                  </label>
                `;
              }
              if (k === "bomber") {
                const mkCodeOpts = (sel) => {
                  const s = String(sel ?? "").trim();
                  const opts = [`<option value="" ${s === "" ? "selected" : ""}>â€”</option>`];
                  for (let i = 1; i <= 4; i++) {
                    const v = String(i);
                    opts.push(`<option value="${v}" ${s === v ? "selected" : ""}>${v}</option>`);
                  }
                  return opts.join("");
                };
                return `
                  <label>${escapeHtml(t("tool.flow.action.bomber"))}
                    <select id="fl_bomb_target">${mkAliveOptsSel(savedNight.bombTarget)}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.bombCode"))}
                    <select id="fl_bomb_code">${mkCodeOpts((savedNight.bombCode != null ? savedNight.bombCode : d.bombCode) || "")}</select>
                  </label>
                  <div class="note" id="fl_bomb_code_note" style="display:none; margin-top:6px; color: rgba(255,92,116,.95); font-weight:950"></div>
                `;
              }
              if (k === "magician") {
                return `
                  <label>${escapeHtml(t("tool.flow.action.magicianDisable"))}
                    <select id="fl_magician_disable">${mkAliveOptsSel(savedNight.magicianDisable)}</select>
                  </label>
                `;
              }
              if (k === "zodiac") {
                return `
                  <label>${escapeHtml(t("tool.flow.action.zodiacShot"))} ${evenNight ? "" : `<span style="color:var(--muted); font-weight:900">(even nights only)</span>`}
                    <select id="fl_zodiac_shot" ${evenNight ? "" : "disabled"}>${mkAliveOptsSel(savedNight.zodiacShot)}</select>
                  </label>
                `;
              }
              if (k === "ocean") {
                const nightKey = String(f.day || 1);
                if (!d.oceanWakeByNight || typeof d.oceanWakeByNight !== "object") d.oceanWakeByNight = {};
                const teamArr = (() => {
                  try {
                    const byNight = Array.isArray(d.oceanWakeByNight[nightKey]) ? d.oceanWakeByNight[nightKey] : null;
                    const v = (byNight != null) ? byNight : ((f.draft && f.draft.oceanWake != null) ? f.draft.oceanWake : null);
                    if (Array.isArray(v)) return v.map((x) => parseInt(x, 10)).filter((x) => Number.isFinite(x));
                    if (typeof v === "number") return [v].filter((x) => Number.isFinite(x));
                    const s = String(v || "").trim();
                    if (!s) return [];
                    return s.split(",").map((x) => parseInt(String(x || "").trim(), 10)).filter((x) => Number.isFinite(x));
                  } catch {
                    return [];
                  }
                })();
                const selectedSet = new Set(teamArr);
                const oceanResultLine = (() => {
                  try {
                    const arr = Array.isArray(teamArr) ? teamArr : [];
                    if (!arr.length) return "";
                    let bad = false;
                    for (const tidx0 of arr) {
                      const tidx = parseInt(tidx0, 10);
                      if (!Number.isFinite(tidx)) continue;
                      const tr = (draw.players && draw.players[tidx] && draw.players[tidx].roleId) ? draw.players[tidx].roleId : "citizen";
                      const teamFa = (roles[tr] && roles[tr].teamFa) ? roles[tr].teamFa : "Ø´Ù‡Ø±";
                      if (teamFa === "Ù…Ø§ÙÛŒØ§" || tr === "zodiac") { bad = true; break; }
                    }
                    return `<div class="note" style="margin-top:6px">${escapeHtml(t(bad ? "tool.flow.ocean.result.bad" : "tool.flow.ocean.result.good"))}</div>`;
                  } catch {
                    return "";
                  }
                })();
                const oceanPickOpts = [`<option value="">â€”</option>`].concat(
                  aliveIdxs
                    .filter((idx) => !selectedSet.has(idx))
                    .map((idx) => `<option value="${idx}">${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</option>`)
                ).join("");
                const oceanList = teamArr.length
                  ? teamArr.map((idx) => {
                      const nm = names[idx] || t("common.playerN", { n: idx + 1 });
                      return `<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; padding:6px 0">
                        <div style="font-weight:950">${escapeHtml(nm)}</div>
                        <button class="btn" type="button" data-ocean-rm="${idx}" style="padding:6px 10px; font-size:12px">${escapeHtml(t("tool.flow.ocean.remove"))}</button>
                      </div>`;
                    }).join("")
                  : `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "Ú©Ø³ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª." : "No one selected.")}</div>`;
                const oceanHidden = teamArr.map((x) => String(parseInt(x, 10))).filter((x) => x !== "NaN").join(",");
                return `
                  <div style="font-weight:1100">${escapeHtml(t("tool.flow.ocean.team"))}</div>
                  <div style="height:6px"></div>
                  ${oceanList}
                  <div style="height:10px"></div>
                  <div class="row one">
                    <label>${escapeHtml(t("tool.flow.ocean.pick"))}
                      <select id="fl_ocean_pick">${oceanPickOpts}</select>
                    </label>
                  </div>
                  <div style="height:10px"></div>
                  <button class="btn" id="fl_ocean_add" type="button">${escapeHtml(t("tool.flow.ocean.add"))}</button>
                  <input id="fl_ocean_wake" type="hidden" value="${escapeHtml(oceanHidden)}" />
                  ${oceanResultLine}
                `;
              }
              if (k === "kane") {
                return `
                  <label>${escapeHtml(t("tool.flow.action.kaneMark"))}
                    <select id="fl_kane_mark">${mkAliveOptsSel(savedNight.kaneMark)}</select>
                  </label>
                `;
              }
              if (k === "constantine") {
                const deadIdxs = (draw.players || [])
                  .map((p, idx) => (p && p.alive === false) ? idx : null)
                  .filter((x) => x !== null);
                const optsDeadSel = (sel) => {
                  const sIdx = (sel === null || sel === undefined || sel === "") ? null : parseInt(sel, 10);
                  const s = (sIdx === null || !Number.isFinite(sIdx)) ? "" : String(sIdx);
                  const base = [`<option value="" ${s === "" ? "selected" : ""}>â€”</option>`];
                  for (const idx of deadIdxs) {
                    const v = String(idx);
                    base.push(`<option value="${v}" ${v === s ? "selected" : ""}>${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</option>`);
                  }
                  return base.join("");
                };
                return `
                  <label>${escapeHtml(t("tool.flow.action.constantineRevive"))}
                    <select id="fl_const_revive">${optsDeadSel(savedNight.constantineRevive)}</select>
                  </label>
                  ${deadIdxs.length ? `` : `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "Ú©Ø³ÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ù†ÛŒØ³Øª." : "No one to revive.")}</div>`}
                `;
              }
              if (k === "nostradamus") {
                const savedArr = Array.isArray(savedNight.nostPick3) ? savedNight.nostPick3 : [];
                const cleanArr = savedArr.map((x) => parseInt(x, 10)).filter((x) => Number.isFinite(x));
                const selSet = new Set(cleanArr);
                const allIdxs = (draw.players || []).map((_, i) => i);
                const pickOpts = [`<option value="">â€”</option>`].concat(
                  allIdxs
                    .filter((idx) => !selSet.has(idx))
                    .map((idx) => {
                      const p = draw.players[idx];
                      const nm = names[idx] || t("common.playerN", { n: idx + 1 });
                      const alive = p && p.alive !== false;
                      const outTxt = alive ? "" : (appLang === "fa" ? " (Ø®Ø§Ø±Ø¬ Ø´Ø¯)" : " (out)");
                      return `<option value="${idx}">${escapeHtml(nm + outTxt)}</option>`;
                    })
                ).join("");
                const listHtml = cleanArr.length
                  ? cleanArr.map((idx) => {
                      const p = draw.players[idx];
                      const nm = names[idx] || t("common.playerN", { n: idx + 1 });
                      const alive = p && p.alive !== false;
                      const outTxt = alive ? "" : (appLang === "fa" ? " (Ø®Ø§Ø±Ø¬ Ø´Ø¯)" : " (out)");
                      return `<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; padding:6px 0">
                        <div style="font-weight:950">${escapeHtml(nm + outTxt)}</div>
                        <button class="btn" type="button" data-nost-rm="${idx}" style="padding:6px 10px; font-size:12px">${escapeHtml(t("tool.flow.ocean.remove"))}</button>
                      </div>`;
                    }).join("")
                  : `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "Ú©Ø³ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª." : "No one selected.")}</div>`;
                const hid = cleanArr.join(",");
                return `
                  <div style="font-weight:1100">${escapeHtml(t("tool.flow.action.nostPick3"))}</div>
                  <div style="height:6px"></div>
                  ${listHtml}
                  <div style="height:10px"></div>
                  <div class="row one">
                    <label>${escapeHtml(t("tool.flow.ocean.pick"))}
                      <select id="fl_nost_pick">${pickOpts}</select>
                    </label>
                  </div>
                  <div style="height:10px"></div>
                  <button class="btn" id="fl_nost_add" type="button" ${cleanArr.length >= 3 ? "disabled" : ""}>${escapeHtml(appLang === "fa" ? "Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù†" : "Add")}</button>
                  <input id="fl_nost_pick3" type="hidden" value="${escapeHtml(hid)}" />
                `;
              }
              if (k === "heir") {
                const allIdxs = (draw.players || []).map((_, i) => i);
                const optsAllSel = (sel) => {
                  const sIdx = (sel === null || sel === undefined || sel === "") ? null : parseInt(sel, 10);
                  const s = (sIdx === null || !Number.isFinite(sIdx)) ? "" : String(sIdx);
                  const base = [`<option value="" ${s === "" ? "selected" : ""}>â€”</option>`];
                  for (const idx of allIdxs) {
                    const p = draw.players[idx];
                    const nm = names[idx] || t("common.playerN", { n: idx + 1 });
                    const alive = p && p.alive !== false;
                    const outTxt = alive ? "" : (appLang === "fa" ? " (Ø®Ø§Ø±Ø¬ Ø´Ø¯)" : " (out)");
                    const v = String(idx);
                    base.push(`<option value="${v}" ${v === s ? "selected" : ""}>${escapeHtml(nm + outTxt)}</option>`);
                  }
                  return base.join("");
                };
                return `
                  <label>${escapeHtml(t("tool.flow.action.heirPick"))} ${f.day === 1 ? `` : `<span style="color:var(--muted); font-weight:900">(${escapeHtml(t("tool.flow.action.heirIntroOnly"))})</span>`}
                    <select id="fl_heir_pick" ${f.day === 1 ? "" : "disabled"}>${optsAllSel(savedNight.heirPick)}</select>
                  </label>
                `;
              }
              if (k === "herbalist") {
                return `
                  <label>${escapeHtml(t("tool.flow.action.herbalistPoison"))}
                    <select id="fl_herb_poison">${mkAliveOptsSel(savedNight.herbalistPoison)}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.herbalistAntidote"))}
                    <select id="fl_herb_antidote">${mkAliveOptsSel(savedNight.herbalistAntidote)}</select>
                  </label>
                `;
              }
              if (k === "armorsmith") {
                const armorIdx = (() => {
                  try {
                    for (let i = 0; i < (draw.players || []).length; i++) {
                      const p = draw.players[i];
                      if (p && p.roleId === "armorsmith" && p.alive !== false) return i;
                    }
                  } catch {}
                  return null;
                })();
                const selfUsed = !!(d && d.armorsmithSelfUsed);
                const sIdx = (savedNight.armorsmithArmor === null || savedNight.armorsmithArmor === undefined) ? null : parseInt(savedNight.armorsmithArmor, 10);
                const optsArmor = (() => {
                  const s = (sIdx === null || !Number.isFinite(sIdx)) ? "" : String(sIdx);
                  const base = [`<option value="" ${s === "" ? "selected" : ""}>â€”</option>`];
                  for (const idx of aliveIdxs) {
                    const v = String(idx);
                    const isSelf = (armorIdx !== null && idx === armorIdx);
                    const dis = (isSelf && selfUsed && v !== s) ? "disabled" : "";
                    base.push(`<option value="${v}" ${v === s ? "selected" : ""} ${dis}>${escapeHtml(names[idx] || t("common.playerN", { n: idx + 1 }))}</option>`);
                  }
                  return base.join("");
                })();
                return `
                  <label>${escapeHtml(t("tool.flow.action.armorsmithArmor"))}
                    <select id="fl_armor_target">${optsArmor}</select>
                  </label>
                  <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.action.armorsmith.selfOnce"))}</div>
                `;
              }
              if (k === "gunslinger") {
                if (!showGunner) return `<div class="note">${escapeHtml(noActionTxt)}</div>`;
                const gunHolders = Object.keys(guns || {})
                  .map((k) => parseInt(k, 10))
                  .filter((idx) => Number.isFinite(idx) && idx >= 0 && draw.players && idx < draw.players.length)
                  .filter((idx) => (draw.players[idx] && draw.players[idx].alive !== false));
                const gunsList = gunHolders.length
                  ? gunHolders.map((idx) => {
                      const g = guns[idx] || {};
                      const nm = names[idx] || t("common.playerN", { n: idx + 1 });
                      const typeLabel = (g.type === "real") ? t("tool.flow.guns.type.real") : t("tool.flow.guns.type.fake");
                      const usedTxt = g.used ? ` <span style="color:var(--muted); font-weight:900">(${escapeHtml(appLang === "fa" ? "Ù…ØµØ±Ù Ø´Ø¯" : "used")})</span>` : "";
                      return `<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; padding:6px 0">
                        <div style="font-weight:950">${escapeHtml(nm)} â€” <span style="color:var(--muted)">${escapeHtml(typeLabel)}</span>${usedTxt}</div>
                        <button class="btn" type="button" data-gun-rm="${idx}" style="padding:6px 10px; font-size:12px">${escapeHtml(t("tool.flow.guns.remove"))}</button>
                      </div>`;
                    }).join("")
                  : `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "ÙØ¹Ù„Ø§Ù‹ Ú©Ø³ÛŒ ØªÙÙ†Ú¯ Ù†Ø¯Ø§Ø±Ø¯." : "No one has a gun yet.")}</div>`;
                return `
                  <div class="note" style="margin-top:2px">${escapeHtml(appLang === "fa" ? `ØªÙÙ†Ú¯â€ŒÙ‡Ø§ÛŒ Ø«Ø¨Øªâ€ŒØ´Ø¯Ù‡: ${givenCount}` : `Recorded guns: ${givenCount}`)}</div>
                  <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.guns.nightQuota", { n: nightGiveCount, r: nightRealCount }))}</div>
                  <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.guns.gunslingerIs", { name: gunnerName }))}</div>
                  <div class="row one" style="margin-top:8px">
                    <label>${escapeHtml(t("tool.flow.guns.giveTo"))}
                      <select id="fl_gun_give_to">${optsAlive}</select>
                    </label>
                    <label>${escapeHtml(t("tool.flow.guns.type"))}
                      <select id="fl_gun_type">
                        <option value="real">${escapeHtml(t("tool.flow.guns.type.real"))}</option>
                        <option value="fake">${escapeHtml(t("tool.flow.guns.type.fake"))}</option>
                      </select>
                    </label>
                  </div>
                  <div class="note" style="margin-top:8px">${escapeHtml(t("tool.flow.guns.selfFakeOnly"))}</div>
                  <div style="height:10px"></div>
                  <button class="btn" id="fl_gun_give" type="button">${escapeHtml(t("tool.flow.guns.give"))}</button>
                  <div class="note" id="fl_gun_give_note" style="display:none; margin-top:8px"></div>
                  <div style="height:12px"></div>
                  <div style="font-weight:1100">${escapeHtml(t("tool.flow.guns.hasGun"))}</div>
                  <div style="height:6px"></div>
                  ${gunsList}
                `;
              }
              return `<div class="note">${escapeHtml(noActionTxt)}</div>`;
            };

            const orderedRaw = (wake && wake.length) ? wake : [];
            // Bomb can only be used once per game; hide Bomber from night order after that.
            const bombAlreadyUsed = (() => {
              try {
                const byDay = (f.draft && f.draft.bombByDay && typeof f.draft.bombByDay === "object") ? f.draft.bombByDay : {};
                for (const day of Object.keys(byDay)) {
                  const rec = byDay[day];
                  if (rec && (rec.target !== null && rec.target !== undefined)) return true;
                }
                if (Array.isArray(f.events)) {
                  if (f.events.some((e) => e && e.kind === "bomb_resolve")) return true;
                }
                return false;
              } catch { return false; }
            })();
            // Hide Zodiac entirely on odd nights (no wake, no action block).
            const ordered = (evenNight ? orderedRaw : orderedRaw.filter((w) => normWake(w) !== "zodiac"))
              .filter((w) => normWake(w) !== "bomber" || !bombAlreadyUsed);
            // Death timing helpers (see `setPlayerLife` -> `deadAtByIdx`)
            const deathRec = (idx) => {
              try {
                const r = d && d.deadAtByIdx ? d.deadAtByIdx[String(idx)] : null;
                return (r && typeof r === "object") ? r : null;
              } catch {
                return null;
              }
            };
            const deadBeforeTonight = (idx) => {
              try {
                const p = (draw && draw.players) ? draw.players[idx] : null;
                if (!p) return true;
                if (p.alive !== false) return false;
                const r = deathRec(idx);
                // No record => treat as dead-before (safe).
                if (!r) return true;
                const rd = Number(r.day || 1);
                const rp = String(r.phase || "day");
                // We are in night_run, so f.phase should be "night".
                // If they died in a previous day/night, they are dead before tonight.
                if (rd < Number(f.day || 1)) return true;
                // If they died earlier today (day phase), they are dead for tonight.
                if (rd === Number(f.day || 1) && rp === "day") return true;
                // If they died this same night (resolved at dawn), they can still act tonight.
                if (rd === Number(f.day || 1) && rp === "night") return false;
                return true;
              } catch {
                return true;
              }
            };
            const aliveTonight = (idx) => {
              try {
                const p = (draw && draw.players) ? draw.players[idx] : null;
                if (!p) return false;
                if (p.alive !== false) return true;
                // dead now, but if death is "this night", treat as alive for tonight (pending).
                return !deadBeforeTonight(idx);
              } catch {
                return false;
              }
            };
            const nightStatusTag = (idx) => {
              try {
                const p = (draw && draw.players) ? draw.players[idx] : null;
                if (!p) return null;
                if (p.alive !== false) return null;
                return deadBeforeTonight(idx) ? "dead" : "pending";
              } catch {
                return null;
              }
            };
            const wakeActorSuffix = (wakeLabel) => {
              try {
                const k = normWake(wakeLabel);
                const joiner = (appLang === "fa") ? "ØŒ " : ", ";
                const deadTag = (appLang === "fa") ? "Ù…Ø±Ø¯Ù‡" : "dead";
                const pendingTag = (appLang === "fa") ? "Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØµØ¨Ø­" : "pending";
                const labelFor = (idx) => {
                  return (names && names[idx]) ? names[idx] : t("common.playerN", { n: idx + 1 });
                };
                const alive = (idx) => aliveTonight(idx);
                const idxsByRole = (roleIds, { onlyAlive } = {}) => {
                  try {
                    const out = [];
                    for (let i = 0; i < (draw.players || []).length; i++) {
                      const p = draw.players[i];
                      if (!p) continue;
                      if (onlyAlive && !alive(i)) continue;
                      if (roleIds.includes(p.roleId)) out.push(i);
                    }
                    return out;
                  } catch {
                    return [];
                  }
                };
                const idxsByTeamFa = (teamFa, { onlyAlive } = {}) => {
                  try {
                    const out = [];
                    for (let i = 0; i < (draw.players || []).length; i++) {
                      const p = draw.players[i];
                      if (!p) continue;
                      if (onlyAlive && !alive(i)) continue;
                      const rid = p.roleId || "citizen";
                      const tf = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
                      if (tf === teamFa) out.push(i);
                    }
                    return out;
                  } catch {
                    return [];
                  }
                };

                let idxs = [];
                if (k === "mafia") {
                  // Mafia wake is a team wake in most scenarios.
                  idxs = idxsByTeamFa("Ù…Ø§ÙÛŒØ§", { onlyAlive: false });
                } else if (k === "doctor") {
                  const s = String(wakeLabel || "").toLowerCase();
                  const isLecter = s.includes("lecter") || s.includes("Ù„Ú©ØªØ±") || s.includes("Ù„Ú©ØªÙØ±");
                  idxs = isLecter ? idxsByRole(["doctorLecter"], { onlyAlive: false }) : idxsByRole(["doctor", "watson"], { onlyAlive: false });
                } else if (k === "detective") {
                  idxs = idxsByRole(["detective"], { onlyAlive: false });
                } else if (k === "professional") {
                  idxs = idxsByRole(["professional"], { onlyAlive: false });
                } else if (k === "bomber") {
                  idxs = idxsByRole(["bomber"], { onlyAlive: false });
                } else if (k === "magician") {
                  idxs = idxsByRole(["magician"], { onlyAlive: false });
                } else if (k === "zodiac") {
                  idxs = idxsByRole(["zodiac"], { onlyAlive: false });
                } else if (k === "gunslinger") {
                  idxs = idxsByRole(["gunslinger"], { onlyAlive: false });
                } else if (k === "ocean") {
                  idxs = idxsByRole(["ocean"], { onlyAlive: false });
                } else {
                  idxs = [];
                }

                if (!idxs.length) return "";
                const list = idxs
                  .map((idx) => {
                    const st = nightStatusTag(idx);
                    if (st === "dead") return `${labelFor(idx)} (${deadTag})`;
                    if (st === "pending") return `${labelFor(idx)} (${pendingTag})`;
                    return labelFor(idx);
                  })
                  .join(joiner);
                return list ? ` (${list})` : "";
              } catch {
                return "";
              }
            };
            const wakeActors = (wakeLabel) => {
              try {
                const k = normWake(wakeLabel);
                const alive = (idx) => aliveTonight(idx);
                const idxsByRole = (roleIds) => {
                  const out = [];
                  for (let i = 0; i < (draw.players || []).length; i++) {
                    const p = draw.players[i];
                    if (!p) continue;
                    if (roleIds.includes(p.roleId)) out.push(i);
                  }
                  return out;
                };
                const idxsByTeamFa = (teamFa) => {
                  const out = [];
                  for (let i = 0; i < (draw.players || []).length; i++) {
                    const p = draw.players[i];
                    if (!p) continue;
                    const rid = p.roleId || "citizen";
                    const tf = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
                    if (tf === teamFa) out.push(i);
                  }
                  return out;
                };

                let all = [];
                if (k === "mafia") {
                  all = idxsByTeamFa("Ù…Ø§ÙÛŒØ§");
                } else if (k === "doctor") {
                  const s = String(wakeLabel || "").toLowerCase();
                  const isLecter = s.includes("lecter") || s.includes("Ù„Ú©ØªØ±") || s.includes("Ù„Ú©ØªÙØ±");
                  all = isLecter ? idxsByRole(["doctorLecter"]) : idxsByRole(["doctor", "watson"]);
                } else if (k === "detective") {
                  all = idxsByRole(["detective"]);
                } else if (k === "professional") {
                  all = idxsByRole(["professional"]);
                } else if (k === "bomber") {
                  all = idxsByRole(["bomber"]);
                } else if (k === "magician") {
                  all = idxsByRole(["magician"]);
                } else if (k === "zodiac") {
                  all = idxsByRole(["zodiac"]);
                } else if (k === "gunslinger") {
                  all = idxsByRole(["gunslinger"]);
                } else if (k === "ocean") {
                  all = idxsByRole(["ocean"]);
                } else {
                  all = [];
                }
                const aliveIdxs = all.filter((idx) => alive(idx));
                return { all, alive: aliveIdxs };
              } catch {
                return { all: [], alive: [] };
              }
            };
            const actionBlocks = ordered.map((w, i) => {
              const a = wakeActors(w);
              // If this role/team doesn't exist in the game at all, hide it.
              if (!a.all.length) return "";
              const isDeadBlock = a.alive.length === 0;
              const deadBadge = isDeadBlock ? ` â€¢ ${appLang === "fa" ? "Ù…Ø±Ø¯Ù‡" : "dead"}` : "";
              const headerTxt = `${i + 1}. ${String(w || "")}${wakeActorSuffix(w)}${deadBadge}`;
              return `
                <div style="padding:10px 0; border-bottom:1px solid rgba(255,255,255,.06); ${isDeadBlock ? "opacity:.55; filter:saturate(.2);" : ""}">
                  <div style="font-weight:1100">${escapeHtml(headerTxt)}</div>
                  <div style="height:8px"></div>
                  <div class="row one">
                    ${isDeadBlock ? `<div class="note">${escapeHtml(appLang === "fa" ? "Ø§ÛŒÙ† Ù†Ù‚Ø´/ØªÛŒÙ… Ù‚Ø¨Ù„ Ø§Ø² Ø§Ù…Ø´Ø¨ Ù…Ø±Ø¯Ù‡ Ø§Ø³Øª Ùˆ Ø§Ú©Ø´Ù† Ù†Ø¯Ø§Ø±Ø¯." : "This role/team is dead before tonight and has no action.")}</div>` : sectionFor(w)}
                  </div>
                </div>
              `;
            }).filter(Boolean).join("");

            body = `
              ${bombLine ? `<div class="note" style="margin-top:6px">${escapeHtml(bombLine)}</div>` : ``}
              <div style="height:10px"></div>
              <div style="font-weight:1100">${escapeHtml(t("tool.flow.night.run"))}</div>
              <div style="height:8px"></div>
              <div style="max-height: 60vh; overflow:auto; -webkit-overflow-scrolling: touch; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:10px; background: rgba(17,24,36,.25)">
                ${actionBlocks || `<div class="note">${escapeHtml(t("tool.wake.none"))}</div>`}
              </div>
            `;
          } else if (cur.id === "night_wake") {
            body = `${bombLine ? `<div class="note" style="margin-top:8px">${escapeHtml(bombLine)}</div>` : ``}
              <div style="height:10px"></div>
              ${wake.length ? wake.map((x, i) => `<div style="padding:6px 0;font-weight:950">${i + 1}. ${escapeHtml(x)}</div>`).join("") : `<div class="note">${escapeHtml(t("tool.wake.none"))}</div>`}`;
          } else if (cur.id === "day_guns") {
            // list gun holders
            const guns = f.guns || {};
            const holders = Object.keys(guns)
              .map((k) => parseInt(k, 10))
              .filter((idx) => Number.isFinite(idx) && idx >= 0 && idx < names.length)
              .filter((idx) => (draw.players[idx] && draw.players[idx].alive !== false)); // alive only

            const holderList = holders.length
              ? holders.map((idx) => {
                  const g = guns[idx] || {};
                  const typeLabel = (g.type === "real") ? t("tool.flow.guns.type.real") : t("tool.flow.guns.type.fake");
                  const usedTxt = g.used ? ` <span style="color:var(--muted); font-weight:900">(${escapeHtml(appLang === "fa" ? "Ù…ØµØ±Ù Ø´Ø¯" : "used")})</span>` : "";
                  return `<div style="padding:6px 0; font-weight:950">${escapeHtml(names[idx])} â€” <span style="color:var(--muted)">${escapeHtml(typeLabel)}</span>${usedTxt}</div>`;
                }).join("")
              : `<div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? "ÙØ¹Ù„Ø§Ù‹ Ú©Ø³ÛŒ ØªÙÙ†Ú¯ Ù†Ø¯Ø§Ø±Ø¯." : "No one has a gun yet.")}</div>`;

            const shooterOpts = [`<option value="">â€”</option>`].concat(
              holders.filter((idx) => !(guns[idx] && guns[idx].used)).map((idx) => `<option value="${idx}">${escapeHtml(names[idx])}</option>`)
            ).join("");
            const targetOpts = optsAlive;

            body = `
              <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.guns.title"))}</div>
              <div style="height:10px"></div>
              <div style="font-weight:1100">${escapeHtml(t("tool.flow.guns.hasGun"))}</div>
              <div style="height:6px"></div>
              ${holderList}
              <div style="height:12px"></div>
              <div style="font-weight:1100">${escapeHtml(t("tool.flow.guns.fire"))}</div>
              <div class="row one" style="margin-top:8px">
                <label>${escapeHtml(t("tool.flow.guns.shooter"))}
                  <select id="fl_gun_shooter">${shooterOpts}</select>
                </label>
                <label>${escapeHtml(t("tool.flow.guns.target"))}
                  <select id="fl_gun_target">${targetOpts}</select>
                </label>
              </div>
              <div style="height:10px"></div>
              <button class="btn primary" id="fl_gun_fire" type="button">${escapeHtml(t("tool.flow.guns.fire"))}</button>
              <div class="note" id="fl_gun_note" style="display:none; margin-top:10px"></div>
            `;
          } else if (cur.id === "night_actions") {
            const d = f.draft || {};
            const evenNight = ((f.day || 1) % 2 === 0);
            const gunnerIdxs = (draw.players || [])
              .map((p, idx) => (p && p.roleId === "gunslinger" && p.alive !== false) ? idx : null)
              .filter((x) => x !== null);
            const showGunner = !!gunnerIdxs.length;
            const gunnerOpts = [`<option value="">â€”</option>`].concat(
              gunnerIdxs.map((idx) => `<option value="${idx}">${escapeHtml(names[idx])}</option>`)
            ).join("");
            const guns = f.guns || {};
            const givenCount = Object.keys(guns || {}).length;
            const nightKey = String(f.day || 1);
            if (!d.nightGunGivesByNight || typeof d.nightGunGivesByNight !== "object") d.nightGunGivesByNight = {};
            const nightGives = Array.isArray(d.nightGunGivesByNight[nightKey]) ? d.nightGunGivesByNight[nightKey] : [];
            const nightGiveCount = nightGives.length;
            const nightRealCount = nightGives.filter((x) => x && x.type === "real").length;
            body = `
              <div style="max-height: 46vh; overflow:auto; -webkit-overflow-scrolling: touch;">
                ${showGunner ? `
                <div style="font-weight:1100">${escapeHtml(t("tool.flow.guns.add"))}</div>
                <div class="note" style="margin-top:6px">${escapeHtml(appLang === "fa" ? `ØªÙÙ†Ú¯â€ŒÙ‡Ø§ÛŒ Ø«Ø¨Øªâ€ŒØ´Ø¯Ù‡: ${givenCount}` : `Recorded guns: ${givenCount}`)}</div>
                <div class="note" style="margin-top:6px">${escapeHtml(t("tool.flow.guns.nightQuota", { n: nightGiveCount, r: nightRealCount }))}</div>
                <div class="row one" style="margin-top:8px">
                  <label>${escapeHtml(appLang === "fa" ? "ØªÙÙ†Ú¯Ø¯Ø§Ø±" : "Gunslinger")}
                    <select id="fl_gun_from">${gunnerOpts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.guns.giveTo"))}
                    <select id="fl_gun_give_to">${optsAlive}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.guns.type"))}
                    <select id="fl_gun_type">
                      <option value="real">${escapeHtml(t("tool.flow.guns.type.real"))}</option>
                      <option value="fake">${escapeHtml(t("tool.flow.guns.type.fake"))}</option>
                    </select>
                  </label>
                </div>
                <div class="note" style="margin-top:8px">${escapeHtml(t("tool.flow.guns.selfFakeOnly"))}</div>
                <div style="height:10px"></div>
                <button class="btn" id="fl_gun_give" type="button">${escapeHtml(t("tool.flow.guns.give"))}</button>
                <div class="note" id="fl_gun_give_note" style="display:none; margin-top:8px"></div>
                <div style="height:14px"></div>
                ` : ``}
                <div class="row one">
                  <label>${escapeHtml(t("tool.flow.action.mafiaShot"))}
                    <select id="fl_mafia_shot">${opts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.doctorSave"))}
                    <select id="fl_doctor_save">${opts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.bomber"))}
                    <select id="fl_bomb_target">${opts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.bombCode"))}
                    <select id="fl_bomb_code">
                      <option value="" ${(String(d.bombCode || "").trim() === "") ? "selected" : ""}>â€”</option>
                      <option value="1" ${(String(d.bombCode || "").trim() === "1") ? "selected" : ""}>1</option>
                      <option value="2" ${(String(d.bombCode || "").trim() === "2") ? "selected" : ""}>2</option>
                      <option value="3" ${(String(d.bombCode || "").trim() === "3") ? "selected" : ""}>3</option>
                      <option value="4" ${(String(d.bombCode || "").trim() === "4") ? "selected" : ""}>4</option>
                    </select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.magicianDisable"))}
                    <select id="fl_magician_disable">${opts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.zodiacShot"))} ${evenNight ? "" : `<span style="color:var(--muted); font-weight:900">(even nights only)</span>`}
                    <select id="fl_zodiac_shot" ${evenNight ? "" : "disabled"}>${opts}</select>
                  </label>
                  <label>${escapeHtml(t("tool.flow.action.oceanWake"))}
                    <select id="fl_ocean_wake" multiple size="${Math.min(8, Math.max(3, aliveIdxs.length))}">${opts}</select>
                  </label>
                </div>
              </div>
            `;
          } else {
            body = `
              ${bombLine ? `<div class="note" style="margin-top:6px">${escapeHtml(bombLine)}</div><div style="height:10px"></div>` : ``}
              <div class="note">${escapeHtml(appLang === "fa" ? "Ø§ÛŒÙ† Ù…Ø±Ø­Ù„Ù‡ Ù‡Ù†ÙˆØ² Ú©Ù†ØªØ±Ù„ Ø§Ø®ØªØµØ§ØµÛŒ Ù†Ø¯Ø§Ø±Ø¯." : "This step does not have a dedicated control yet.")}</div>
            `;
          }

          openToolModal(t("tool.flow.title"), `
            <div class="toolBox">
              <div style="text-align:center">
                <div style="font-weight:1200; font-size:22px; letter-spacing:.2px">${escapeHtml(flowPhaseTitle(f))}</div>
                <div style="color:var(--muted); font-weight:900; font-size:12px; margin-top:6px">${escapeHtml(stepLine)} â€¢ ${escapeHtml(cur.title)}</div>
              </div>

              <div style="height:12px"></div>
              ${body}

              <div style="height:14px"></div>
              <div class="actions">
                <button class="btn" id="fl_prev" type="button">${escapeHtml(t("tool.flow.prev"))}</button>
                <button class="btn primary" id="fl_next" type="button">${escapeHtml(t("tool.flow.next"))}</button>
              </div>
            </div>
          `, { hideBottom: true });

          $("fl_prev").onclick = prevFlowStep;
          const commitVoteFromUI = () => {
            try {
              const d = f.draft || {};
              if (!d.voteCountsByDay || typeof d.voteCountsByDay !== "object") d.voteCountsByDay = {};
              const counts = {};
              let total = 0;
              const todayOutIdx = (() => {
                try {
                  const ev = (f.events || []).slice().reverse().find((e) =>
                    e && e.kind === "day_elim_out" && e.phase === "day" && e.day === f.day && e.data && Number.isFinite(Number(e.data.out))
                  );
                  if (ev && ev.data && Number.isFinite(Number(ev.data.out))) return parseInt(ev.data.out, 10);
                } catch {}
                return null;
              })();
              const includeOutForVoteMax = !!(todayOutIdx !== null && draw.players && draw.players[todayOutIdx] && draw.players[todayOutIdx].alive === false);
              const votersAtVote = aliveIdxs.length + (includeOutForVoteMax ? 1 : 0);
              const maxVotes = Math.max(0, votersAtVote - 1);
              const listIdxs = aliveIdxs.concat(
                (todayOutIdx !== null && !aliveIdxs.includes(todayOutIdx)) ? [todayOutIdx] : []
              );
              for (const idx of listIdxs) {
                const el = document.getElementById(`fl_vote_${idx}`);
                const raw = el ? el.value : "0";
                const n = Math.max(0, Math.min(maxVotes, Math.floor(Number(raw || 0))));
                counts[idx] = Number.isFinite(n) ? n : 0;
                total += counts[idx] || 0;
              }
              d.voteCountsByDay[f.day] = counts;
              // Remember roster + voter count used for this day's Voting (source of truth for Defense threshold).
              d.voteRosterByDay = (d.voteRosterByDay && typeof d.voteRosterByDay === "object") ? d.voteRosterByDay : {};
              d.voteRosterByDay[f.day] = listIdxs.slice();
              d.voteVotersByDay = (d.voteVotersByDay && typeof d.voteVotersByDay === "object") ? d.voteVotersByDay : {};
              d.voteVotersByDay[f.day] = votersAtVote;

              // leaders (top vote getters, >0)
              const leaders = Object.keys(counts)
                .map((k) => ({ idx: parseInt(k, 10), v: counts[k] }))
                .filter((x) => Number.isFinite(x.idx) && x.v > 0)
                .sort((a, b) => b.v - a.v);
              const topV = leaders.length ? leaders[0].v : 0;
              const top = leaders.filter((x) => x.v === topV).slice(0, 10);
              d.voteLeadersByDay = (d.voteLeadersByDay && typeof d.voteLeadersByDay === "object") ? d.voteLeadersByDay : {};
              d.voteLeadersByDay[f.day] = top.map((x) => x.idx);
              f.draft = d;

              addFlowEvent("day_vote", { counts, total });
              saveState(appState);
              return true;
            } catch {
              return false;
            }
          };
          const snapshotElimVotesFromUI = () => {
            try {
              const d = f.draft || {};
              if (!d.elimVotesByDay || typeof d.elimVotesByDay !== "object") d.elimVotesByDay = {};
              const candIdxs = Array.isArray(d.elimCandidatesByDay && d.elimCandidatesByDay[f.day]) ? d.elimCandidatesByDay[f.day] : [];
              const voters = aliveIdxs.length;
              const eligibleVoters = Math.max(0, voters - 1);
              const elimThreshold = Math.floor(eligibleVoters / 2) + 1;
              // No defendants (no one reached threshold) => nothing to eliminate, allow advancing.
              if (!candIdxs.length) {
                d.elimVotesByDay[f.day] = {};
                d.elimLeadersByDay = (d.elimLeadersByDay && typeof d.elimLeadersByDay === "object") ? d.elimLeadersByDay : {};
                d.elimLeadersByDay[f.day] = [];
                d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
                d.elimPickedByDay[f.day] = null;
                f.draft = d;
                addFlowEvent("day_elim", { counts: {}, best: 0, leaders: [] });
                try { addFlowEvent("day_elim_out", { out: null }); } catch {}
                try { applyDayElimFromPayload(f, { out: null }); } catch {}
                saveState(appState);
                return true;
              }
              const maxVotes = Math.max(0, aliveIdxs.length - 1);
              const counts = {};
              let best = 0;
              for (const idx of candIdxs) {
                const el = document.getElementById(`fl_elim_${idx}`);
                const raw = el ? el.value : "0";
                const n = Math.max(0, Math.min(maxVotes, Math.floor(Number(raw || 0))));
                counts[idx] = Number.isFinite(n) ? n : 0;
                best = Math.max(best, counts[idx] || 0);
              }
              d.elimVotesByDay[f.day] = counts;
              const leaders = Object.keys(counts)
                .map((k) => ({ idx: parseInt(k, 10), v: counts[k] }))
                .filter((x) => Number.isFinite(x.idx))
                .sort((a, b) => (b.v - a.v) || (a.idx - b.idx));
              const top = leaders.filter((x) => x.v === best && best > 0);
              d.elimLeadersByDay = (d.elimLeadersByDay && typeof d.elimLeadersByDay === "object") ? d.elimLeadersByDay : {};
              d.elimLeadersByDay[f.day] = top.map((x) => x.idx);
              d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
              const prevPicked = (d.elimPickedByDay && d.elimPickedByDay[f.day] !== undefined) ? d.elimPickedByDay[f.day] : null;
              const prevPickedIdxRaw = Number.isFinite(Number(prevPicked)) ? parseInt(prevPicked, 10) : null;
              const prevPickedIdx = (prevPickedIdxRaw !== null && Number.isFinite(prevPickedIdxRaw)) ? prevPickedIdxRaw : (() => {
                try {
                  const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "day_elim_draw" && Number(e.day) === Number(f.day));
                  const p = ev && ev.data ? ev.data.picked : null;
                  const n = parseInt(String(p ?? ""), 10);
                  return Number.isFinite(n) ? n : null;
                } catch {
                  return null;
                }
              })();
              const keptPicked = (top.length === 1)
                ? top[0].idx
                : (top.length > 1 && prevPickedIdx !== null && top.some((x) => x.idx === prevPickedIdx))
                  ? prevPickedIdx
                  : null;
              d.elimPickedByDay[f.day] = keptPicked;
              f.draft = d;
              addFlowEvent("day_elim", { counts, best, leaders: top.map((x) => x.idx) });
              // Apply vote-out immediately so "(out)" moves when correcting votes.
              try {
                const desiredOut = (() => {
                  if (candIdxs.length === 1) {
                    const only = candIdxs[0];
                    const v = counts[only] || 0;
                    return (v >= elimThreshold) ? only : null;
                  }
                  if (top.length === 1 && best > 0) return top[0].idx;
                  if (top.length > 1 && keptPicked !== null) return keptPicked;
                  return null;
                })();
                addFlowEvent("day_elim_out", { out: desiredOut, preview: true });
                const changed = applyDayElimFromPayload(f, { out: desiredOut });
                if (changed) {
                  try { renderCast(); } catch {}
                  try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
                }
              } catch {}
              saveState(appState);
              return true;
            } catch {
              return false;
            }
          };
          const snapshotNightActionsFromUI = () => {
            try {
              // Only when relevant controls exist (night_run page).
              const hasAny =
                document.getElementById("fl_mafia_shot") ||
                document.getElementById("fl_doctor_save") ||
                document.getElementById("fl_det_query") ||
                document.getElementById("fl_pro_shot") ||
                document.getElementById("fl_bomb_target") ||
                document.getElementById("fl_magician_disable") ||
                document.getElementById("fl_zodiac_shot") ||
                document.getElementById("fl_ocean_wake") ||
                document.getElementById("fl_bomb_code") ||
                document.getElementById("fl_kane_mark") ||
                document.getElementById("fl_const_revive") ||
                document.getElementById("fl_nost_pick3") ||
                document.getElementById("fl_heir_pick") ||
                document.getElementById("fl_herb_poison") ||
                document.getElementById("fl_herb_antidote") ||
                document.getElementById("fl_armor_target");
              if (!hasAny) return false;

              const mafiaShot = (document.getElementById("fl_mafia_shot") || {}).value || "";
              const doctorSave = (document.getElementById("fl_doctor_save") || {}).value || "";
              const detQuery = (document.getElementById("fl_det_query") || {}).value || "";
              const proShot = (document.getElementById("fl_pro_shot") || {}).value || "";
              const bombTarget = (document.getElementById("fl_bomb_target") || {}).value || "";
              const bombCode = (document.getElementById("fl_bomb_code") || {}).value || "";
              const magicianDisable = (document.getElementById("fl_magician_disable") || {}).value || "";
              const zodiacShot = (document.getElementById("fl_zodiac_shot") || {}).value || "";
              const kaneMark = (document.getElementById("fl_kane_mark") || {}).value || "";
              const constantineRevive = (document.getElementById("fl_const_revive") || {}).value || "";
              const heirPick = (document.getElementById("fl_heir_pick") || {}).value || "";
              const herbalistPoison = (document.getElementById("fl_herb_poison") || {}).value || "";
              const herbalistAntidote = (document.getElementById("fl_herb_antidote") || {}).value || "";
              const armorsmithArmor = (document.getElementById("fl_armor_target") || {}).value || "";
              const nostPick3 = (() => {
                const el = document.getElementById("fl_nost_pick3");
                if (!el) return [];
                const s = String(el.value || "").trim();
                if (!s) return [];
                return s.split(",")
                  .map((x) => parseInt(String(x || "").trim(), 10))
                  .filter((x) => Number.isFinite(x))
                  .slice(0, 3);
              })();
              const oceanWake = (() => {
                const el = document.getElementById("fl_ocean_wake");
                if (!el) return [];
                try {
                  if (String((el.tagName || "")).toUpperCase() === "SELECT" && el.selectedOptions) {
                    return Array.from(el.selectedOptions)
                      .map((o) => parseInt(o.value, 10))
                      .filter((x) => Number.isFinite(x));
                  }
                } catch {}
                // fallback
                const s = String(el.value || "").trim();
                if (!s) return [];
                return s.split(",").map((x) => parseInt(String(x || "").trim(), 10)).filter((x) => Number.isFinite(x));
              })();

              // Persist drafts
              if (!f.draft || typeof f.draft !== "object") f.draft = {};
              // Save per-night actions so UI can repopulate reliably.
              const nk = String(f.day || 1);
              const d = f.draft;
              if (!d.nightActionsByNight || typeof d.nightActionsByNight !== "object") d.nightActionsByNight = {};
              const per = (d.nightActionsByNight[nk] && typeof d.nightActionsByNight[nk] === "object") ? d.nightActionsByNight[nk] : {};
              per.mafiaShot = mafiaShot === "" ? null : parseInt(mafiaShot, 10);
              per.doctorSave = doctorSave === "" ? null : parseInt(doctorSave, 10);
              per.detectiveQuery = detQuery === "" ? null : parseInt(detQuery, 10);
              per.professionalShot = proShot === "" ? null : parseInt(proShot, 10);
              per.bombTarget = bombTarget === "" ? null : parseInt(bombTarget, 10);
              per.bombCode = String(bombCode || "");
              per.magicianDisable = magicianDisable === "" ? null : parseInt(magicianDisable, 10);
              per.zodiacShot = zodiacShot === "" ? null : parseInt(zodiacShot, 10);
              per.oceanWake = Array.isArray(oceanWake) ? oceanWake : [];
              per.kaneMark = kaneMark === "" ? null : parseInt(kaneMark, 10);
              per.constantineRevive = constantineRevive === "" ? null : parseInt(constantineRevive, 10);
              per.nostPick3 = Array.isArray(nostPick3) ? nostPick3 : [];
              per.heirPick = heirPick === "" ? null : parseInt(heirPick, 10);
              per.herbalistPoison = herbalistPoison === "" ? null : parseInt(herbalistPoison, 10);
              per.herbalistAntidote = herbalistAntidote === "" ? null : parseInt(herbalistAntidote, 10);
              per.armorsmithArmor = armorsmithArmor === "" ? null : parseInt(armorsmithArmor, 10);
              d.nightActionsByNight[nk] = per;
              // keep existing legacy draft fields too
              d.bombCode = String(bombCode || "");
              d.oceanWake = Array.isArray(oceanWake) ? oceanWake : [];
              f.draft = d;
              
              // Track Armorsmith self-armor consumption (once per game), but allow clearing.
              try {
                if (per.armorsmithArmor !== null && Number.isFinite(Number(per.armorsmithArmor))) {
                  const armorIdx = (() => {
                    for (let i = 0; i < (appState.draw.players || []).length; i++) {
                      const p = appState.draw.players[i];
                      if (p && p.roleId === "armorsmith" && p.alive !== false) return i;
                    }
                    return null;
                  })();
                  if (armorIdx !== null && parseInt(per.armorsmithArmor, 10) === armorIdx) {
                    d.armorsmithSelfUsed = true;
                    f.draft = d;
                  }
                }
              } catch {}

              const payload = {
                mafiaShot: mafiaShot === "" ? null : parseInt(mafiaShot, 10),
                doctorSave: doctorSave === "" ? null : parseInt(doctorSave, 10),
                detectiveQuery: detQuery === "" ? null : parseInt(detQuery, 10),
                professionalShot: proShot === "" ? null : parseInt(proShot, 10),
                bombTarget: bombTarget === "" ? null : parseInt(bombTarget, 10),
                bombCode: String(bombCode || "").trim() || null,
                magicianDisable: magicianDisable === "" ? null : parseInt(magicianDisable, 10),
                zodiacShot: zodiacShot === "" ? null : parseInt(zodiacShot, 10),
                oceanWake: (Array.isArray(oceanWake) && oceanWake.length) ? oceanWake : null,
                kaneMark: kaneMark === "" ? null : parseInt(kaneMark, 10),
                constantineRevive: constantineRevive === "" ? null : parseInt(constantineRevive, 10),
                nostPick3: (Array.isArray(nostPick3) && nostPick3.length) ? nostPick3 : null,
                heirPick: heirPick === "" ? null : parseInt(heirPick, 10),
                herbalistPoison: herbalistPoison === "" ? null : parseInt(herbalistPoison, 10),
                herbalistAntidote: herbalistAntidote === "" ? null : parseInt(herbalistAntidote, 10),
                armorsmithArmor: armorsmithArmor === "" ? null : parseInt(armorsmithArmor, 10),
              };
              addFlowEvent("night_actions", payload);

              // NOTE: Bomb is planted at NIGHT, but becomes "active" on the NEXT day.
              // So we DO NOT toggle `f.bombActive` here. It will be set during the nightâ†’day transition.

              // Apply mafia shot immediately (so closing the UI still shows correct alive/dead).
              // IMPORTANT: Night kills are resolved at the END of the night (night -> day),
              // so being shot does NOT prevent a role from acting that same night.
              // (Disables like Magician/Matador can still block actions that night.)

              // Detective result (for display)
              try {
                const key = String(f.day || 1);
                const d = f.draft || {};
                if (!d.detectiveResultByNight || typeof d.detectiveResultByNight !== "object") d.detectiveResultByNight = {};

                if (payload.detectiveQuery !== null && appState.draw && appState.draw.players && appState.draw.players[payload.detectiveQuery]) {
                  const tIdx = payload.detectiveQuery;
                  const tr = (appState.draw.players[tIdx] && appState.draw.players[tIdx].roleId) ? appState.draw.players[tIdx].roleId : "citizen";
                  const isMafia = detectiveInquiryIsMafia(tr);
                  d.detectiveResultByNight[key] = { target: tIdx, isMafia, at: Date.now() };
                  f.draft = d;
                  addFlowEvent("detective_query", { target: tIdx, isMafia });

                  // Update UI immediately (no full re-render needed).
                  try {
                    const el = document.getElementById("fl_det_result");
                    if (el) {
                      const thumb = isMafia ? "ğŸ‘" : "ğŸ‘";
                      const label = (appLang === "fa") ? (isMafia ? "Ù…Ø§ÙÛŒØ§" : "Ø´Ù‡Ø±ÙˆÙ†Ø¯") : (isMafia ? "Mafia" : "Citizen");
                      const pre = (appLang === "fa") ? "Ù†ØªÛŒØ¬Ù‡ Ø§Ø³ØªØ¹Ù„Ø§Ù…: " : "Result: ";
                      el.style.display = "";
                      el.textContent = `${pre}${thumb} ${label}`;
                    }
                  } catch {}
                } else {
                  // If cleared, hide/remove the result for this night so we don't show stale values.
                  d.detectiveResultByNight[key] = null;
                  f.draft = d;
                  try {
                    const el = document.getElementById("fl_det_result");
                    if (el) { el.style.display = "none"; el.textContent = ""; }
                  } catch {}
                  try { addFlowEvent("detective_query", { target: null, isMafia: null, cleared: true }); } catch {}
                }
              } catch {}
              saveState(appState);
              return true;
            } catch {
              return false;
            }
          };
          // Let closing the tool modal auto-save Flow inputs.
          try {
            window.__flowOnClose = () => {
              try {
                // Night actions
                if (
                  document.getElementById("fl_mafia_shot") ||
                  document.getElementById("fl_doctor_save") ||
                  document.getElementById("fl_det_query") ||
                  document.getElementById("fl_pro_shot") ||
                  document.getElementById("fl_bomb_target") ||
                  document.getElementById("fl_magician_disable") ||
                  document.getElementById("fl_zodiac_shot") ||
                  document.getElementById("fl_ocean_wake") ||
                  document.getElementById("fl_bomb_code")
                ) {
                  snapshotNightActionsFromUI();
                }
              } catch {}
              try {
                // Day voting
                if (document.querySelector('select[id^="fl_vote_"]')) {
                  commitVoteFromUI();
                }
              } catch {}
              try {
                // Day elimination votes
                if (document.querySelector('select[id^="fl_elim_"]')) {
                  snapshotElimVotesFromUI();
                }
              } catch {}
            };
          } catch {}
          const commitElimFromUI = () => {
            try {
              const d = f.draft || {};
              if (!d.elimVotesByDay || typeof d.elimVotesByDay !== "object") d.elimVotesByDay = {};
              const candIdxs = Array.isArray(d.elimCandidatesByDay && d.elimCandidatesByDay[f.day]) ? d.elimCandidatesByDay[f.day] : [];
              // No defendants today => allow advancing.
              if (!candIdxs.length) {
                try { addFlowEvent("day_elim", { counts: {}, best: 0, leaders: [] }); } catch {}
                try { addFlowEvent("day_elim_out", { out: null }); } catch {}
                try { applyDayElimFromPayload(f, { out: null }); } catch {}
                try { saveState(appState); } catch {}
                return true;
              }

              const maxVotes = Math.max(0, aliveIdxs.length - 1);
              const counts = {};
              let best = 0;
              for (const idx of candIdxs) {
                const el = document.getElementById(`fl_elim_${idx}`);
                const raw = el ? el.value : "0";
                const n = Math.max(0, Math.min(maxVotes, Math.floor(Number(raw || 0))));
                counts[idx] = Number.isFinite(n) ? n : 0;
                best = Math.max(best, counts[idx] || 0);
              }
              d.elimVotesByDay[f.day] = counts;

              // Single defendant: require majority to be voted out.
              if (candIdxs.length === 1) {
                const voters = aliveIdxs.length;
                const eligibleVoters = Math.max(0, voters - 1);
                const threshold = Math.floor(eligibleVoters / 2) + 1;
                const only = candIdxs[0];
                const v = counts[only] || 0;
                const out = (v >= threshold) ? only : null;
                d.elimLeadersByDay = (d.elimLeadersByDay && typeof d.elimLeadersByDay === "object") ? d.elimLeadersByDay : {};
                d.elimLeadersByDay[f.day] = (best > 0) ? [only] : [];
                d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
                d.elimPickedByDay[f.day] = out;
                f.draft = d;
                addFlowEvent("day_elim", { counts, best, leaders: (best > 0) ? [only] : [] });
                addFlowEvent("day_elim_out", { out, auto: true, single: true });
                try { applyDayElimFromPayload(f, { out }); } catch {}
                try { renderCast(); } catch {}
                try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
                saveState(appState);
                return true;
              }

              const leaders = Object.keys(counts)
                .map((k) => ({ idx: parseInt(k, 10), v: counts[k] }))
                .filter((x) => Number.isFinite(x.idx))
                .sort((a, b) => (b.v - a.v) || (a.idx - b.idx));
              const top = leaders.filter((x) => x.v === best && best > 0);
              d.elimLeadersByDay = (d.elimLeadersByDay && typeof d.elimLeadersByDay === "object") ? d.elimLeadersByDay : {};
              d.elimLeadersByDay[f.day] = top.map((x) => x.idx);
              d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
              const prevPicked = (d.elimPickedByDay && d.elimPickedByDay[f.day] !== undefined) ? d.elimPickedByDay[f.day] : null;
              const prevPickedIdxRaw = Number.isFinite(Number(prevPicked)) ? parseInt(prevPicked, 10) : null;
              const prevPickedIdx = (prevPickedIdxRaw !== null && Number.isFinite(prevPickedIdxRaw)) ? prevPickedIdxRaw : (() => {
                try {
                  const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "day_elim_draw" && Number(e.day) === Number(f.day));
                  const p = ev && ev.data ? ev.data.picked : null;
                  const n = parseInt(String(p ?? ""), 10);
                  return Number.isFinite(n) ? n : null;
                } catch {
                  return null;
                }
              })();
              const keptPicked = (top.length === 1)
                ? top[0].idx
                : (top.length > 1 && prevPickedIdx !== null && top.some((x) => x.idx === prevPickedIdx))
                  ? prevPickedIdx
                  : null;
              d.elimPickedByDay[f.day] = keptPicked;
              f.draft = d;

              addFlowEvent("day_elim", { counts, best, leaders: top.map((x) => x.idx) });
              saveState(appState);

              // No one is eliminated (e.g., scenario allows no-out, or votes are all 0): allow advancing.
              if (!(best > 0) || !top.length) {
                try { addFlowEvent("day_elim_out", { out: null }); } catch {}
                try { applyDayElimFromPayload(f, { out: null }); } catch {}
                return true;
              }

              // Single winner: apply elimination and allow advancing.
              if (top.length === 1 && best > 0) {
                try { applyDayElimFromPayload(f, { out: top[0].idx }); } catch {}
                addFlowEvent("day_elim_out", { out: top[0].idx, auto: true });
                try { renderCast(); } catch {}
                try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
                saveState(appState);
                return true;
              }

              // Tie: if Draw already picked someone, allow advancing; otherwise require Draw.
              if (top.length > 1 && keptPicked !== null) {
                try { applyDayElimFromPayload(f, { out: keptPicked }); } catch {}
                addFlowEvent("day_elim_out", { out: keptPicked, draw: true, via: "next" });
                try { renderCast(); } catch {}
                try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
                saveState(appState);
                return true;
              }

              showFlowTool();
              return false;
            } catch {
              return false;
            }
          };

          $("fl_next").onclick = () => {
            if (cur && cur.id === "night_run") {
              // Validation: if Bomber planted a bomb, code/password is required.
              try {
                const bt = (document.getElementById("fl_bomb_target") || {}).value || "";
                const bc = (document.getElementById("fl_bomb_code") || {}).value || "";
                const hasTarget = bt !== "" && Number.isFinite(Number(bt));
                const hasCode = bc !== "" && Number.isFinite(Number(bc));
                if (hasTarget && !hasCode) {
                  const sel = document.getElementById("fl_bomb_code");
                  const note = document.getElementById("fl_bomb_code_note");
                  if (sel) {
                    sel.style.borderColor = "rgba(255,92,116,.75)";
                    sel.style.boxShadow = "0 0 0 3px rgba(255,92,116,.18)";
                    try { sel.scrollIntoView({ block: "center", behavior: "smooth" }); } catch {}
                  }
                  if (note) {
                    note.style.display = "block";
                    note.textContent = (appLang === "fa")
                      ? "Ø¨Ø±Ø§ÛŒ Ø¨Ù…Ø¨ØŒ Â«Ú©Ø¯/Ø±Ù…Ø²Â» Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ (Û± ØªØ§ Û´)."
                      : "Pick a bomb code/password (1â€“4) before continuing.";
                  }
                  return;
                }
              } catch {}
              nextFlowStep();
              return;
            }
            if (cur && cur.id === "day_bomb") {
              const applied = applyBombResultFromForm();
              const r0 = (f.draft && f.draft.bombResolveByDay && f.draft.bombResolveByDay[String(f.day)]) ? f.draft.bombResolveByDay[String(f.day)] : null;
              if (!applied && !(r0 && r0.resolved)) {
                showFlowTool();
                return;
              }
              try {
                const stepsAfter = getFlowSteps(f);
                const voteIdx = stepsAfter.findIndex((s) => s && s.id === "day_vote");
                f.step = (voteIdx >= 0) ? voteIdx : 0;
                saveState(appState);
              } catch {}
              showFlowTool();
              return;
            }
            if (cur && cur.id === "day_vote") {
              commitVoteFromUI();
              nextFlowStep();
              return;
            }
            if (cur && cur.id === "day_elim") {
              const ok = commitElimFromUI();
              if (ok) nextFlowStep();
              return;
            }
            nextFlowStep();
          };

          // Auto-save: persist changes immediately when user selects values.
          if (cur && cur.id === "day_bomb") {
            try {
              const saveBombDraft = () => {
                try {
                  const d = f.draft || {};
                  if (!d.bombResolveByDay || typeof d.bombResolveByDay !== "object") d.bombResolveByDay = {};
                  const r0 = (d.bombResolveByDay[String(f.day)] && typeof d.bombResolveByDay[String(f.day)] === "object")
                    ? d.bombResolveByDay[String(f.day)]
                    : {};
                  r0.guardSacrifice = !!(document.getElementById("fl_bomb_guard") && document.getElementById("fl_bomb_guard").checked);
                  r0.guardGuess = String(((document.getElementById("fl_bomb_guard_guess") || {}).value) || "").trim();
                  r0.targetGuess = String(((document.getElementById("fl_bomb_target_guess") || {}).value) || "").trim();
                  d.bombResolveByDay[String(f.day)] = r0;
                  f.draft = d;
                  saveState(appState);
                } catch {}
              };
              const els = ["fl_bomb_guard", "fl_bomb_guard_guess", "fl_bomb_target_guess"]
                .map((id) => document.getElementById(id))
                .filter(Boolean);
              els.forEach((el) => el.addEventListener("change", () => {
                saveBombDraft();
                if (applyBombResultFromForm()) bombApplyJustHappened = true;
                try { showFlowTool(); } catch {}
                bombApplyJustHappened = false;
              }));
            } catch {}
          }
          if (cur && cur.id === "day_vote") {
            try {
              const els = document.querySelectorAll('select[id^="fl_vote_"]');
              els.forEach((el) => {
                el.addEventListener("change", () => { try { commitVoteFromUI(); } catch {} });
              });
            } catch {}
          }
          if (cur && cur.id === "day_elim") {
            try {
              const els = document.querySelectorAll('select[id^="fl_elim_"]');
              els.forEach((el) => {
                el.addEventListener("change", () => {
                  try { snapshotElimVotesFromUI(); } catch {}
                  // Re-render so the result (and Draw visibility) updates immediately.
                  try { showFlowTool(); } catch {}
                });
              });
            } catch {}
          }
          if (cur && cur.id === "night_run") {
            const ids = [
              "fl_mafia_shot",
              "fl_doctor_save",
              "fl_det_query",
              "fl_pro_shot",
              "fl_bomb_target",
              "fl_magician_disable",
              "fl_zodiac_shot",
              "fl_ocean_wake",
              "fl_bomb_code",
              "fl_kane_mark",
              "fl_const_revive",
              "fl_heir_pick",
              "fl_herb_poison",
              "fl_herb_antidote",
              "fl_armor_target",
            ];
            for (const id of ids) {
              const el = document.getElementById(id);
              if (!el) continue;
              const evt = "change";
              try {
                el.addEventListener(evt, () => {
                  snapshotNightActionsFromUI();
                  // Re-render when disable target changes so blocked actions get greyed/disabled correctly.
                  if (id === "fl_magician_disable") {
                    try { showFlowTool(); } catch {}
                  }
                  // Clear bomb code validation feedback when user selects a code/target.
                  if (id === "fl_bomb_code" || id === "fl_bomb_target") {
                    try {
                      const sel = document.getElementById("fl_bomb_code");
                      const note = document.getElementById("fl_bomb_code_note");
                      if (sel) { sel.style.borderColor = ""; sel.style.boxShadow = ""; }
                      if (note) { note.style.display = "none"; note.textContent = ""; }
                    } catch {}
                  }
                });
              } catch {}
            }
          }
          // mid_vote (legacy midday bomb page) removed

          const elimDrawBtn = document.getElementById("fl_elim_draw");
          if (elimDrawBtn) {
            elimDrawBtn.onclick = () => {
              const d = f.draft || {};
              const arr = (d.elimLeadersByDay && d.elimLeadersByDay[f.day]) ? d.elimLeadersByDay[f.day] : [];
              const ties = Array.isArray(arr) ? arr.slice().filter((x) => Number.isFinite(Number(x))) : [];
              if (!ties.length) return;
              const picked = ties[Math.floor(Math.random() * ties.length)];
              d.elimPickedByDay = (d.elimPickedByDay && typeof d.elimPickedByDay === "object") ? d.elimPickedByDay : {};
              d.elimPickedByDay[f.day] = picked;
              f.draft = d;
              addFlowEvent("day_elim_draw", { picked, ties });
              // Apply result immediately: picked player is out by vote (reversible if corrected later).
              try { applyDayElimFromPayload(f, { out: parseInt(picked, 10) }); } catch {}
              addFlowEvent("day_elim_out", { out: parseInt(picked, 10), draw: true });
              try { renderCast(); } catch {}
              try { if (typeof renderNameGrid === "function") renderNameGrid(); } catch {}
              saveState(appState);
              showFlowTool();
            };
          }

          // (No separate "Out" button needed: elimination is applied on Save (single winner) or Draw (tie).)

          const giveGunBtn = document.getElementById("fl_gun_give");
          if (giveGunBtn) {
            giveGunBtn.onclick = () => {
              const toVal = (document.getElementById("fl_gun_give_to") || {}).value || "";
              const tp = (document.getElementById("fl_gun_type") || {}).value || "real";
              const note = document.getElementById("fl_gun_give_note");
              if (toVal === "") return;
              const idx = parseInt(toVal, 10);
              if (!Number.isFinite(idx)) return;
              const fromIdx = (() => {
                try {
                  const draw = appState.draw;
                  if (!draw || !draw.players) return null;
                  for (let i = 0; i < draw.players.length; i++) {
                    const p = draw.players[i];
                    if (p && p.roleId === "gunslinger" && p.alive !== false) return i;
                  }
                } catch {}
                return null;
              })();

              // Night limits: (user request) no max total; keep max 1 real per night.
              const d = f.draft || {};
              const nightKey = String(f.day || 1);
              if (!d.nightGunGivesByNight || typeof d.nightGunGivesByNight !== "object") d.nightGunGivesByNight = {};
              let nightGives = Array.isArray(d.nightGunGivesByNight[nightKey]) ? d.nightGunGivesByNight[nightKey] : [];

              // Determine desired type (with self->fake rule).
              let type = (tp === "fake") ? "fake" : "real";
              if (fromIdx !== null && Number.isFinite(fromIdx) && fromIdx === idx) type = "fake";

              // Replace/update existing give to same recipient (doesn't consume extra quota).
              const exAt = nightGives.findIndex((x) => x && Number.isFinite(Number(x.to)) && parseInt(x.to, 10) === idx);
              const realUsed = nightGives.filter((x, i) => x && x.type === "real" && i !== exAt).length;

              if (type === "real" && realUsed >= 1) {
                if (note) { note.style.display = "block"; note.textContent = t("tool.flow.guns.limit1Real"); }
                return;
              }

              const entry = { from: fromIdx, to: idx, type, at: Date.now() };
              if (exAt >= 0) nightGives[exAt] = entry;
              else nightGives = nightGives.concat([entry]);
              d.nightGunGivesByNight[nightKey] = nightGives;
              f.draft = d;

              // Gunslinger can give anyone a gun, but can only give themselves a fake gun.
              if (!f.guns || typeof f.guns !== "object") f.guns = {};
              f.guns[idx] = { type, used: false, givenAt: Date.now() };
              addFlowEvent("gun_give", { from: fromIdx, to: idx, type: f.guns[idx].type });
              saveState(appState);
              showFlowTool();
            };
          }

          // Remove a gun (undo mistakes)
          try {
            const rmBtns = document.querySelectorAll("[data-gun-rm]");
            rmBtns.forEach((btn) => {
              btn.addEventListener("click", () => {
                try {
                  const raw = btn.getAttribute("data-gun-rm");
                  const idx = parseInt(String(raw || ""), 10);
                  if (!Number.isFinite(idx)) return;
                  // Remove gun from holder
                  if (f.guns && typeof f.guns === "object") {
                    try { delete f.guns[idx]; } catch { f.guns[idx] = undefined; }
                  }
                  // Remove from per-night give tracking (all nights, to be safe)
                  const d = f.draft || {};
                  if (d.nightGunGivesByNight && typeof d.nightGunGivesByNight === "object") {
                    for (const nk of Object.keys(d.nightGunGivesByNight)) {
                      const arr = Array.isArray(d.nightGunGivesByNight[nk]) ? d.nightGunGivesByNight[nk] : [];
                      d.nightGunGivesByNight[nk] = arr.filter((x) => !(x && Number.isFinite(Number(x.to)) && parseInt(x.to, 10) === idx));
                    }
                  }
                  f.draft = d;
                  addFlowEvent("gun_remove", { to: idx });
                  saveState(appState);
                  showFlowTool();
                } catch {}
              });
            });
          } catch {}

          // Ocean team: add/remove via buttons (undo mistakes)
          const oceanAddBtn = document.getElementById("fl_ocean_add");
          if (oceanAddBtn) {
            oceanAddBtn.onclick = () => {
              try {
                const pick = (document.getElementById("fl_ocean_pick") || {}).value || "";
                if (pick === "") return;
                const idx = parseInt(pick, 10);
                if (!Number.isFinite(idx)) return;
                const d = f.draft || {};
                const nightKey = String(f.day || 1);
                if (!d.oceanWakeByNight || typeof d.oceanWakeByNight !== "object") d.oceanWakeByNight = {};
                const arr = Array.isArray(d.oceanWakeByNight[nightKey]) ? d.oceanWakeByNight[nightKey].slice() : [];
                if (!arr.includes(idx)) arr.push(idx);
                d.oceanWakeByNight[nightKey] = arr;
                f.draft = d;
                // keep compatibility mirror
                f.draft.oceanWake = arr;
                // Update hidden field so snapshot picks it up and applies Ocean rule immediately
                try {
                  const hid = document.getElementById("fl_ocean_wake");
                  if (hid) hid.value = arr.join(",");
                } catch {}
                snapshotNightActionsFromUI();
                showFlowTool();
              } catch {}
            };
          }
          try {
            const oceanRmBtns = document.querySelectorAll("[data-ocean-rm]");
            oceanRmBtns.forEach((btn) => {
              btn.addEventListener("click", () => {
                try {
                  const raw = btn.getAttribute("data-ocean-rm");
                  const idx = parseInt(String(raw || ""), 10);
                  if (!Number.isFinite(idx)) return;
                  const d = f.draft || {};
                  const nightKey = String(f.day || 1);
                  if (!d.oceanWakeByNight || typeof d.oceanWakeByNight !== "object") d.oceanWakeByNight = {};
                  const arr = Array.isArray(d.oceanWakeByNight[nightKey]) ? d.oceanWakeByNight[nightKey].slice() : [];
                  const next = arr.filter((x) => parseInt(x, 10) !== idx);
                  d.oceanWakeByNight[nightKey] = next;
                  f.draft = d;
                  f.draft.oceanWake = next;
                  try {
                    const hid = document.getElementById("fl_ocean_wake");
                    if (hid) hid.value = next.join(",");
                  } catch {}
                  snapshotNightActionsFromUI();
                  showFlowTool();
                } catch {}
              });
            });
          } catch {}

          // Nostradamus picks: add/remove (mobile-friendly)
          const nostAddBtn = document.getElementById("fl_nost_add");
          if (nostAddBtn) {
            nostAddBtn.onclick = () => {
              try {
                const pick = (document.getElementById("fl_nost_pick") || {}).value || "";
                if (pick === "") return;
                const idx = parseInt(pick, 10);
                if (!Number.isFinite(idx)) return;
                const nk = String(f.day || 1);
                const d = f.draft || {};
                if (!d.nightActionsByNight || typeof d.nightActionsByNight !== "object") d.nightActionsByNight = {};
                const per = (d.nightActionsByNight[nk] && typeof d.nightActionsByNight[nk] === "object") ? d.nightActionsByNight[nk] : {};
                const arr = Array.isArray(per.nostPick3) ? per.nostPick3.slice() : [];
                if (arr.length >= 3) return;
                if (!arr.includes(idx)) arr.push(idx);
                per.nostPick3 = arr.slice(0, 3);
                d.nightActionsByNight[nk] = per;
                f.draft = d;
                try {
                  const hid = document.getElementById("fl_nost_pick3");
                  if (hid) hid.value = per.nostPick3.join(",");
                } catch {}
                snapshotNightActionsFromUI();
                showFlowTool();
              } catch {}
            };
          }
          try {
            const nostRmBtns = document.querySelectorAll("[data-nost-rm]");
            nostRmBtns.forEach((btn) => {
              btn.addEventListener("click", () => {
                try {
                  const raw = btn.getAttribute("data-nost-rm");
                  const idx = parseInt(String(raw || ""), 10);
                  if (!Number.isFinite(idx)) return;
                  const nk = String(f.day || 1);
                  const d = f.draft || {};
                  if (!d.nightActionsByNight || typeof d.nightActionsByNight !== "object") d.nightActionsByNight = {};
                  const per = (d.nightActionsByNight[nk] && typeof d.nightActionsByNight[nk] === "object") ? d.nightActionsByNight[nk] : {};
                  const arr = Array.isArray(per.nostPick3) ? per.nostPick3.slice() : [];
                  const next = arr.filter((x) => parseInt(x, 10) !== idx);
                  per.nostPick3 = next.slice(0, 3);
                  d.nightActionsByNight[nk] = per;
                  f.draft = d;
                  try {
                    const hid = document.getElementById("fl_nost_pick3");
                    if (hid) hid.value = per.nostPick3.join(",");
                  } catch {}
                  snapshotNightActionsFromUI();
                  showFlowTool();
                } catch {}
              });
            });
          } catch {}

          // Inline Last Move draw (only present in day_elim when a player is picked)
          const lmElimBtn = document.getElementById("lm_draw_elim");
          if (lmElimBtn) {
            lmElimBtn.onclick = () => {
              try {
                const supports = getScenario() === "shab_mafia";
                if (!supports) return;
                const lastMoveCards = [
                  { id: "insomnia", fa: "Ø¨ÛŒâ€ŒØ®ÙˆØ§Ø¨ÛŒ", en: "Insomnia" },
                  { id: "final_shot", fa: "Ø´Ù„ÛŒÚ© Ù†Ù‡Ø§ÛŒÛŒ", en: "Final Shot" },
                  { id: "beautiful_mind", fa: "Ø°Ù‡Ù† Ø²ÛŒØ¨Ø§", en: "Beautiful Mind" },
                  { id: "thirteen_lies", fa: "Ø¯Ø±ÙˆØº Ø³ÛŒØ²Ø¯Ù‡", en: "Thirteen Lies" },
                  { id: "green_mile", fa: "Ù…Ø³ÛŒØ± Ø³Ø¨Ø²", en: "Green Mile" },
                  { id: "red_carpet", fa: "ÙØ±Ø´ Ù‚Ø±Ù…Ø²", en: "Red Carpet" },
                ];
                const used = new Set((appState.god && appState.god.lastMove && Array.isArray(appState.god.lastMove.used)) ? appState.god.lastMove.used : []);
                const remaining = lastMoveCards.filter((c) => !used.has(c.id));
                const note = document.getElementById("lm_note_elim");
                if (!remaining.length) {
                  if (note) {
                    note.style.display = "block";
                    note.textContent = t("tool.lastMove.allUsed");
                  }
                  return;
                }
                const picked = remaining[Math.floor(Math.random() * remaining.length)];
                if (!appState.god.lastMove || typeof appState.god.lastMove !== "object") appState.god.lastMove = { last: null, at: null, used: [] };
                if (!Array.isArray(appState.god.lastMove.used)) appState.god.lastMove.used = [];
                appState.god.lastMove.last = picked.id;
                appState.god.lastMove.at = Date.now();
                appState.god.lastMove.used.push(picked.id);
                saveState(appState);
                showFlowTool();
              } catch {}
            };
          }

          // UX: if gunslinger gives to self, force fake-only in dropdown.
          (function () {
            const toSel = document.getElementById("fl_gun_give_to");
            const typeSel = document.getElementById("fl_gun_type");
            if (!toSel || !typeSel) return;
            const realOpt = typeSel.querySelector('option[value="real"]');
            const giveBtn = document.getElementById("fl_gun_give");
            const adjust = () => {
              const tv = (toSel.value || "");
              const fidx = (() => {
                try {
                  const draw = appState.draw;
                  if (!draw || !draw.players) return null;
                  for (let i = 0; i < draw.players.length; i++) {
                    const p = draw.players[i];
                    if (p && p.roleId === "gunslinger" && p.alive !== false) return i;
                  }
                } catch {}
                return null;
              })();
              const tidx = tv === "" ? null : parseInt(tv, 10);
              const self = (fidx !== null && tidx !== null && Number.isFinite(fidx) && Number.isFinite(tidx) && fidx === tidx);
              const d = f.draft || {};
              const nightKey = String(f.day || 1);
              const nightGives = (d.nightGunGivesByNight && Array.isArray(d.nightGunGivesByNight[nightKey])) ? d.nightGunGivesByNight[nightKey] : [];
              const exAt = nightGives.findIndex((x) => x && Number.isFinite(Number(x.to)) && parseInt(x.to, 10) === tidx);
              const realUsed = nightGives.filter((x, i) => x && x.type === "real" && i !== exAt).length;
              // Disable real when self OR already used real quota (except editing existing real entry).
              if (realOpt) realOpt.disabled = !!self || (realUsed >= 1);
              if (self && typeSel.value === "real") typeSel.value = "fake";
              if (realUsed >= 1 && typeSel.value === "real") typeSel.value = "fake";

              // Give button is always enabled (no per-night max total).
              if (giveBtn) giveBtn.disabled = false;
            };
            try { toSel.addEventListener("change", adjust); } catch {}
            adjust();
          })();

          const fireGunBtn = document.getElementById("fl_gun_fire");
          if (fireGunBtn) {
            fireGunBtn.onclick = () => {
              const shVal = (document.getElementById("fl_gun_shooter") || {}).value || "";
              const tgVal = (document.getElementById("fl_gun_target") || {}).value || "";
              const note = document.getElementById("fl_gun_note");
              if (shVal === "" || tgVal === "") return;
              const shooter = parseInt(shVal, 10);
              const target = parseInt(tgVal, 10);
              if (!Number.isFinite(shooter) || !Number.isFinite(target)) return;
              const g = (f.guns && f.guns[shooter]) ? f.guns[shooter] : null;
              if (!g || g.used) return;

              g.used = true;
              addFlowEvent("gun_shot", { shooter, target, type: g.type });

              if (g.type === "real") {
                setPlayerLife(target, { alive: false, reason: "shot" });
                try { renderCast(); } catch {}
                if (note) { note.style.display = "block"; note.textContent = t("tool.flow.guns.killedTarget"); }
              } else {
                if (note) { note.style.display = "block"; note.textContent = t("tool.flow.guns.noEffect"); }
              }
              saveState(appState);
              showFlowTool();
            };
          }

          // (No manual "Record actions" / bomb toggle buttons; changes auto-save.)
        }

        function showRoleChangeTool() {
          const draw = appState.draw;
          if (!draw || !draw.players) {
            openToolModal(t("tool.roleChange.title"), `<div class="toolBox">${escapeHtml(t("tool.roleChange.needDeal"))}</div>`);
            return;
          }
          const roleIds = getAllowedRoleIdsForScenario();
          const playerOpts = draw.players.map((p, i) => {
            const name = (appState.ui.playerNames && appState.ui.playerNames[i]) ? appState.ui.playerNames[i] : t("common.playerN", { n: i + 1 });
            return `<option value="${i}">${escapeHtml(name)}</option>`;
          }).join("");
          const roleOpts = roleIds.map((rid) => `<option value="${rid}">${escapeHtml(roleName(rid))}</option>`).join("");

          openToolModal(t("tool.roleChange.title"), `
            <div class="toolBox">
              <div style="font-weight:1100;margin-bottom:10px">${escapeHtml(t("tool.roleChange.pick"))}</div>
              <div class="row one">
                <label>${escapeHtml(t("tool.roleChange.labelPlayer"))}
                  <select id="rc_player">${playerOpts}</select>
                </label>
                <label>${escapeHtml(t("tool.roleChange.labelRole"))}
                  <select id="rc_role">${roleOpts}</select>
                </label>
              </div>
              <div style="height:10px"></div>
              <button class="btn primary" id="rc_apply" type="button">${escapeHtml(t("tool.roleChange.apply"))}</button>
              <div style="height:10px"></div>
              <button class="btn" id="rc_shuffle_all" type="button">${escapeHtml(t("tool.roleChange.shuffleAll"))}</button>
              <div class="note" id="rc_shuffle_note" style="display:none">
                ${escapeHtml(t("tool.roleChange.shuffleWarn"))}
              </div>
            </div>
          `);

          $("rc_apply").onclick = () => {
            const idx = parseInt($("rc_player").value, 10);
            const rid = $("rc_role").value;
            if (!Number.isFinite(idx) || !roles[rid]) return;
            draw.players[idx].roleId = rid;
            saveState(appState);
            renderCast();
            closeToolModal();
          };

          // Dangerous action: require confirmation click.
          let shuffleArmed = false;
          let shuffleArmTimer = null;
          const shuffleBtn = $("rc_shuffle_all");
          const shuffleNote = $("rc_shuffle_note");
          const disarmShuffle = () => {
            shuffleArmed = false;
            if (shuffleArmTimer) { try { clearTimeout(shuffleArmTimer); } catch {} }
            shuffleArmTimer = null;
            if (shuffleBtn) {
              shuffleBtn.classList.remove("danger");
              shuffleBtn.textContent = t("tool.roleChange.shuffleAll");
            }
            if (shuffleNote) shuffleNote.style.display = "none";
          };
          if (shuffleBtn) {
            shuffleBtn.onclick = () => {
              if (!shuffleArmed) {
                shuffleArmed = true;
                if (shuffleBtn) {
                  shuffleBtn.classList.add("danger");
                  shuffleBtn.textContent = t("tool.roleChange.shuffleConfirm");
                }
                if (shuffleNote) shuffleNote.style.display = "block";
                if (shuffleArmTimer) { try { clearTimeout(shuffleArmTimer); } catch {} }
                shuffleArmTimer = setTimeout(disarmShuffle, 6000);
                return;
              }
              // confirmed: Shuffle role assignments across all players (preserve role multiset).
              const roleIds = draw.players.map((p) => p.roleId || "citizen");
              shuffle(roleIds);
              for (let i = 0; i < draw.players.length; i++) {
                draw.players[i].roleId = roleIds[i];
                draw.players[i].revealed = true; // role list screen assumes roles are known to narrator
              }
              saveState(appState);
              renderCast();
              closeToolModal();
            };
          }
        }

        function showChanceTool() {
          const draw = appState.draw;
          if (!draw || !draw.players) {
            openToolModal(t("tool.chance.title"), `<div class="toolBox">${escapeHtml(t("tool.roleChange.needDeal"))}</div>`);
            return;
          }
          const n = draw.players.length;
          openToolModal(t("tool.chance.title"), `
            <div class="toolBox">
              <div style="font-weight:1100;margin-bottom:10px">${escapeHtml(t("tool.chance.ask"))}</div>
              <label>
                ${escapeHtml(t("tool.chance.count"))}
                <select id="ch_n">
                  ${Array.from({ length: Math.min(10, n) }, (_, i) => i + 2)
                    .filter((k) => k <= n)
                    .map((k) => `<option value="${k}">${k}</option>`)
                    .join("")}
                </select>
              </label>
              <div style="height:10px"></div>
              <button class="btn primary" id="ch_spin" type="button">${escapeHtml(t("tool.chance.spin"))}</button>
              <div style="height:10px"></div>
              <div style="font-weight:1100">${escapeHtml(t("tool.chance.result"))}</div>
              <div id="ch_res" style="padding-top:6px; font-weight:950; line-height:1.9">â€”</div>
            </div>
          `);
          $("ch_spin").onclick = () => {
            const k = parseInt($("ch_n").value, 10);
            const kk = Math.max(1, Math.min(n, Number.isFinite(k) ? k : 1));
            const picked = 1 + Math.floor(Math.random() * kk);
            const res = t("common.playerN", { n: picked });
            $("ch_res").textContent = res;
            appState.god.chance = { last: picked, at: Date.now() };
            saveState(appState);
          };
        }

        let timerInterval = null;
        let audioCtx = null;
        let audioUnlocked = false;
        function ensureTimers() {
          if (appState.god.timers) return;
          appState.god.timers = {
            talk: 50,
            challenge: 40,
            defense: 60,
            running: null, // key
            remaining: { talk: 50, challenge: 40, defense: 60 },
            startedAt: null,
          };
        }
        function stopTimerInterval() {
          if (timerInterval) clearInterval(timerInterval);
          timerInterval = null;
        }

        function unlockAudio() {
          try {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) return false;
            if (!audioCtx) audioCtx = new AC();
            // On iOS Safari, resume must happen during a user gesture.
            if (audioCtx.state === "suspended") {
              try { audioCtx.resume(); } catch {}
            }
            // Play an almost-silent blip to "unlock" audio output.
            const now = audioCtx.currentTime;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.00001, now);
            g.connect(audioCtx.destination);
            const o = audioCtx.createOscillator();
            o.type = "sine";
            o.frequency.setValueAtTime(440, now);
            o.connect(g);
            o.start(now);
            o.stop(now + 0.01);
            audioUnlocked = true;
            return true;
          } catch {
            return false;
          }
        }

        function playBeep() {
          try {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) return;
            if (!audioCtx) audioCtx = new AC();
            if (audioCtx.state === "suspended") {
              // If we didn't unlock earlier via a user tap, iOS may block this resume.
              try { audioCtx.resume(); } catch {}
            }

            const now = audioCtx.currentTime;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.0001, now);
            gain.gain.linearRampToValueAtTime(0.22, now + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
            gain.connect(audioCtx.destination);

            const osc = audioCtx.createOscillator();
            osc.type = "sine";
            osc.frequency.setValueAtTime(880, now);
            osc.connect(gain);
            osc.start(now);
            osc.stop(now + 0.36);

            // small second beep
            const gain2 = audioCtx.createGain();
            gain2.gain.setValueAtTime(0.0001, now + 0.45);
            gain2.gain.linearRampToValueAtTime(0.20, now + 0.46);
            gain2.gain.exponentialRampToValueAtTime(0.0001, now + 0.72);
            gain2.connect(audioCtx.destination);

            const osc2 = audioCtx.createOscillator();
            osc2.type = "sine";
            osc2.frequency.setValueAtTime(880, now + 0.45);
            osc2.connect(gain2);
            osc2.start(now + 0.45);
            osc2.stop(now + 0.73);
          } catch {
            // ignore audio errors (autoplay policies, etc.)
          }
        }
        function tickTimers() {
          const t = appState.god.timers;
          if (!t || !t.running) return;
          if (!t.startedAt) t.startedAt = Date.now();
          const now = Date.now();
          const elapsed = Math.floor((now - t.startedAt) / 1000);
          const base = t.remaining[t.running + "_base"] ?? t.remaining[t.running];
          const rem = Math.max(0, base - elapsed);
          t.remaining[t.running] = rem;
          const el = document.getElementById("tm_" + t.running);
          if (el) el.textContent = formatMMSS(rem);
          if (rem <= 0) {
            const endedKey = t.running;
            t.running = null;
            t.startedAt = null;
            stopTimerInterval();
            playBeep();
            // reset this timer to runner-configured duration
            if (endedKey && typeof t[endedKey] === "number") {
              t.remaining[endedKey] = t[endedKey];
              delete t.remaining[endedKey + "_base"];
              const el2 = document.getElementById("tm_" + endedKey);
              if (el2) el2.textContent = formatMMSS(t.remaining[endedKey]);
            }
            saveState(appState);
          }
          // refresh play/pause icons if tool is open
          updateTimerIcons();
        }

        function updateTimerIcons() {
          const t = appState.god.timers;
          if (!t) return;
          const playSvg = `<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5v14l12-7-12-7z"/></svg>`;
          const pauseSvg = `<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M6 5h4v14H6V5zm8 0h4v14h-4V5z"/></svg>`;
          const set = (key) => {
            const b = document.getElementById("tm_btn_" + key);
            if (!b) return;
            const running = (t.running === key);
            b.innerHTML = running ? pauseSvg : playSvg;
            b.classList.toggle("is-running", running);
          };
          set("talk");
          set("challenge");
          set("defense");
        }

        function showTimerPicker(key) {
          ensureTimers();
          const tmr = appState.god.timers;
          const labels = { talk: t("tool.timer.turn"), challenge: t("tool.timer.challenge"), defense: t("tool.timer.defense") };
          const presets = [
            10, 15, 20, 30, 40, 45, 50, 55, 60, 75, 90, 120, 150, 180,
          ];
          openToolModal(t("tool.timer.pick.title"), `
            <div class="toolBox">
              <div style="font-weight:1100;margin-bottom:10px">${escapeHtml(t("tool.timer.pick.ask", { label: labels[key] || key }))}</div>
              <label>
                ${escapeHtml(t("tool.timer.pick.seconds"))}
                <select id="tp_val">
                  ${presets.map((s) => `<option value="${s}" ${tmr[key] === s ? "selected" : ""}>${s}</option>`).join("")}
                </select>
              </label>
              <div style="height:12px"></div>
              <button class="btn primary" id="tp_apply" type="button">${escapeHtml(t("tool.timer.pick.apply"))}</button>
              <div style="height:10px"></div>
              <button class="btn" id="tp_cancel" type="button">${escapeHtml(t("tool.timer.pick.back"))}</button>
            </div>
          `, { hideBottom: true });

          $("tp_apply").onclick = () => {
            const v = parseInt($("tp_val").value, 10);
            if (!Number.isFinite(v) || v <= 0) return;
            // stop if currently running this timer
            if (tmr.running === key) {
              tmr.running = null;
              tmr.startedAt = null;
              stopTimerInterval();
            }
            tmr[key] = v;
            tmr.remaining[key] = v;
            delete tmr.remaining[key + "_base"];
            saveState(appState);
            showTimerTool();
          };
          $("tp_cancel").onclick = () => showTimerTool();
        }
        function startOrPauseTimer(key) {
          ensureTimers();
          const t = appState.god.timers;
          // iOS Safari: unlock audio during a user gesture (button click).
          if (!audioUnlocked) unlockAudio();
          if (t.running === key) {
            // pause
            t.running = null;
            t.startedAt = null;
            stopTimerInterval();
            saveState(appState);
            updateTimerIcons();
            return;
          }
          // set base snapshot
          t.remaining[key + "_base"] = t.remaining[key];
          t.running = key;
          t.startedAt = Date.now();
          stopTimerInterval();
          timerInterval = setInterval(tickTimers, 250);
          saveState(appState);
          updateTimerIcons();
        }
        function resetTimers() {
          ensureTimers();
          const t = appState.god.timers;
          t.running = null;
          t.startedAt = null;
          t.remaining = { talk: t.talk, challenge: t.challenge, defense: t.defense };
          try { delete t.remaining.talk_base; delete t.remaining.challenge_base; delete t.remaining.defense_base; } catch {}
          stopTimerInterval();
          saveState(appState);
          updateTimerIcons();
          // update visible numbers immediately (if tool is open)
          try {
            const a = document.getElementById("tm_talk");
            const b = document.getElementById("tm_challenge");
            const c = document.getElementById("tm_defense");
            if (a) a.textContent = formatMMSS(t.remaining.talk);
            if (b) b.textContent = formatMMSS(t.remaining.challenge);
            if (c) c.textContent = formatMMSS(t.remaining.defense);
          } catch {}
        }
        function showTimerTool() {
          ensureTimers();
          const tmr = appState.god.timers;
          // iOS Safari: opening timer tool is a user gesture; unlock audio here.
          if (!audioUnlocked) unlockAudio();
          openToolModal(t("tool.timer.title"), `
            <div class="timerRow">
              <div class="timerCard">
                <div class="tname">${escapeHtml(t("tool.timer.turn"))}</div>
                <div class="tval clickable" id="tm_talk">${formatMMSS(tmr.remaining.talk)}</div>
                <button class="tbtn" id="tm_btn_talk" type="button" aria-label="Play/Pause"></button>
              </div>
              <div class="timerCard">
                <div class="tname">${escapeHtml(t("tool.timer.challenge"))}</div>
                <div class="tval clickable" id="tm_challenge">${formatMMSS(tmr.remaining.challenge)}</div>
                <button class="tbtn" id="tm_btn_challenge" type="button" aria-label="Play/Pause"></button>
              </div>
              <div class="timerCard" style="grid-column: 1 / -1;">
                <div class="tname">${escapeHtml(t("tool.timer.defense"))}</div>
                <div class="tval clickable" id="tm_defense">${formatMMSS(tmr.remaining.defense)}</div>
                <button class="tbtn" id="tm_btn_defense" type="button" aria-label="Play/Pause"></button>
              </div>
            </div>
            <div class="timerActions">
              <button class="reset" id="tm_reset" type="button">${escapeHtml(t("tool.timer.reset"))}</button>
              <button class="close" id="tm_close" type="button">${escapeHtml(t("tool.timer.close"))}</button>
            </div>
          `, { hideBottom: true });

          $("tm_btn_talk").onclick = () => startOrPauseTimer("talk");
          $("tm_btn_challenge").onclick = () => startOrPauseTimer("challenge");
          $("tm_btn_defense").onclick = () => startOrPauseTimer("defense");
          $("tm_talk").onclick = () => showTimerPicker("talk");
          $("tm_challenge").onclick = () => showTimerPicker("challenge");
          $("tm_defense").onclick = () => showTimerPicker("defense");
          $("tm_reset").onclick = resetTimers;
          $("tm_close").onclick = closeToolModal;

          updateTimerIcons();

          // if a timer is running, ensure UI ticks
          if (appState.god.timers.running && !timerInterval) {
            timerInterval = setInterval(tickTimers, 250);
          }
        }

        function ensureNamesLength(n) {
          if (!Array.isArray(appState.ui.playerNames)) appState.ui.playerNames = [];
          const cur = appState.ui.playerNames.slice(0, n);
          while (cur.length < n) cur.push("");
          appState.ui.playerNames = cur;
        }

        function setNamesMode(mode) {
          appState.ui.namesMode = mode;
          $("namesDefaultBtn").classList.toggle("active", mode === "default");
          $("namesLastBtn").classList.toggle("active", mode === "last");
          if (mode === "last") {
            const last = loadLastNames();
            if (last && last.length) {
              ensureNamesLength(appState.ui.nPlayers);
              for (let i = 0; i < appState.ui.nPlayers; i++) {
                appState.ui.playerNames[i] = (last[i] || "").trim();
              }
            }
          }
          renderNameGrid();
          saveState(appState);
        }

        function renderNameGrid() {
          const host = $("nameGrid");
          host.innerHTML = "";
          ensureNamesLength(appState.ui.nPlayers);
          for (let i = 0; i < appState.ui.nPlayers; i++) {
            const row = document.createElement("div");
            row.className = "nameRow";
            row.innerHTML = `
              <div class="num">${i + 1}</div>
              <input id="nm_${i}" type="text" inputmode="text" placeholder="${escapeHtml(t("common.playerN", { n: i + 1 }))}" value="${escapeHtml(appState.ui.playerNames[i] || "")}" />
            `;
            host.appendChild(row);
          }
          for (let i = 0; i < appState.ui.nPlayers; i++) {
            const el = $("nm_" + i);
            el.addEventListener("input", () => {
              appState.ui.playerNames[i] = el.value;
              saveState(appState);
              validatePlayerNamesAndShowError();
            });
          }
        }

        function normalizeNameForCompare(name) {
          return String(name || "")
            .trim()
            .replace(/\s+/g, " ")
            .toLocaleLowerCase(appLang === "fa" ? "fa" : "en");
        }

        function readNamesFromInputs() {
          ensureNamesLength(appState.ui.nPlayers);
          const names = [];
          for (let i = 0; i < appState.ui.nPlayers; i++) {
            const el = $("nm_" + i);
            names.push((el ? el.value : appState.ui.playerNames[i] || "").trim());
          }
          return names;
        }

        function getDuplicateNames(names) {
          const seen = new Map(); // norm -> firstIndex
          const dups = new Set();
          for (let i = 0; i < names.length; i++) {
            const norm = normalizeNameForCompare(names[i]);
            if (!norm) continue; // ignore empty names
            if (seen.has(norm)) dups.add(norm);
            else seen.set(norm, i);
          }
          return Array.from(dups);
        }

        function getFirstRepeatedName(names) {
          const seen = new Map(); // norm -> displayName
          for (let i = 0; i < names.length; i++) {
            const display = String(names[i] || "").trim();
            const norm = normalizeNameForCompare(display);
            if (!norm) continue;
            if (seen.has(norm)) return seen.get(norm) || display;
            seen.set(norm, display);
          }
          return null;
        }

        function validatePlayerNamesAndShowError() {
          const names = readNamesFromInputs();
          const repeated = getFirstRepeatedName(names);
          if (repeated) {
            setError(t("error.duplicateName", { name: repeated }));
            return false;
          }
          // don't clear other errors if set elsewhere; only clear if this was the reason
          setError("");
          return true;
        }

        function escapeHtml(s) {
          return String(s)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#39;");
        }

        function openRoleHelpOverlay(roleId) {
          const rid = roleId || "";
          const scenario = (appState.draw && appState.draw.uiAtDraw && appState.draw.uiAtDraw.scenario)
            ? appState.draw.uiAtDraw.scenario
            : getScenario();
          const rBase = roles[rid];
          const rOv = (roleScenarioOverrides[rid] && roleScenarioOverrides[rid][scenario]) ? roleScenarioOverrides[rid][scenario] : null;
          const r = rBase ? { ...rBase, ...(rOv || {}) } : null;
          const teamFa = r ? (r.teamFa || "Ø´Ù‡Ø±") : "Ø´Ù‡Ø±";
          const teamCls =
            teamFa === "Ù…Ø§ÙÛŒØ§" ? "team-mafia" :
            teamFa === "Ø´Ù‡Ø±" ? "team-city" : "team-ind";
          const rName = roleName(rid);
          const rDesc = roleDesc(rid, scenario);

          // Make "Role help" look like the role reveal card UI.
          openToolModal(t("common.roleHelp"), `
            <div class="roleCard roleReveal ${teamCls}">
              <div class="ricon" aria-hidden="true">${roleIconSvg(rid, teamFa)}</div>
              <div class="rname">${escapeHtml(rName)}</div>
              <div class="rteam">${escapeHtml(`${t("lifeSheet.team")}: ${teamLabel(teamFa)}`)}</div>
            </div>
            <div class="note roleRevealNote ${teamCls}">${escapeHtml(rDesc)}</div>
          `, { hideBottom: true });
        }

        function applyUIFromState() {
          appState.ui.scenario = sanitizeScenarioValue(appState.ui.scenario);
          $("scenario").value = appState.ui.scenario;
          $("playersCount").value = String(appState.ui.nPlayers);
          fillMafiaSelect(appState.ui.nPlayers, computeSuggestedMafia(appState.ui.nPlayers));
          $("mafiaCount").value = String(appState.ui.mafiaCount);

          const mafiaCount = parseInt($("mafiaCount").value, 10);
          const disableMafiaBoss = mafiaCount <= 0;
          const disableSwindler = mafiaCount <= 1; // need room for specials
          // scenario may have changed since last save; normalize then apply
          appState.ui.toggles = normalizeTogglesForScenario(appState.ui.toggles, $("scenario").value);
          applyToggles(appState.ui.toggles, { disableMafiaBoss, disableSwindler });
          applyScenarioAvailability($("scenario").value);

          renderNameGrid();
          setNamesMode(appState.ui.namesMode || "default");
          $("playersStat").textContent = (appLang === "fa")
            ? `Ø¨Ø§Ø²ÛŒÚ©Ù†: ${appState.ui.nPlayers}`
            : `Players: ${appState.ui.nPlayers}`;
        }

        function syncUIToState() {
          const s = readUIState();
          appState.ui = {
            scenario: sanitizeScenarioValue(s.scenario),
            nPlayers: s.nPlayers,
            mafiaCount: s.mafiaCount,
            toggles: s.toggles,
            playerNames: appState.ui.playerNames || [],
            namesMode: appState.ui.namesMode || "default",
            customized: !!(appState.ui && appState.ui.customized),
          };
        }

        function regenerateFromUI() {
          syncUIToState();
          saveState(appState);
          updateQuickStat();
        }

        // Scenario defaults (recommended config).
        // If a scenario doesn't have a known "official" player count, we still support
        // resetting roles to that scenario's default role-set + recomputing mafia count.
        const scenarioDefaults = {
          // Classic Mafia: commonly defined as min 12 (8 citizens, 4 mafia).
          // Source: danoma.ir (scenario classic).
          classic: { nPlayers: 12, mafiaCount: 4 },

          // "Shahrvand o Mafia" TV scenario (Ø¨Ø§Ø²Ù¾Ø±Ø³): 3 mafia + 7 citizens.
          // Source: fa.wikipedia.org/wiki/Ø´Ù‡Ø±ÙˆÙ†Ø¯_Ùˆ_Ù…Ø§ÙÛŒØ§
          bazras: { nPlayers: 10, mafiaCount: 3 },
          // These are variants of the same TV-style scenario family in this app.
          namayande: { nPlayers: 10, mafiaCount: 3 },
          mozaker: { nPlayers: 10, mafiaCount: 3 },
          takavar: { nPlayers: 10, mafiaCount: 3 },

          // Capo: designed for 10 players (7 citizens, 3 mafia).
          // Source: danoma.ir (scenario list) and gorgine.com (capo).
          kabo: { nPlayers: 10, mafiaCount: 3 },

          // Pedarkhande: designed for 11 players (7 citizens, 3 mafia, 1 independent).
          // Source: danoma.ir (scenario pedarkhande).
          pedarkhande: { nPlayers: 11, mafiaCount: 3 },

          // Zodiac (Shab-haye Mafia: Zodiac): 12 players per match (the show). We default to 12.
          // Source: fa.wikipedia.org/wiki/Ø´Ø¨â€ŒÙ‡Ø§ÛŒ_Ù…Ø§ÙÛŒØ§
          zodiac: { nPlayers: 12, mafiaCount: 3 },

          // "Meeting/Epic" and "Pishrafte" are advanced mixes in this app.
          // We default them to a common advanced-classic count.
          // Source: danoma.ir (classic advanced: 12/13/15 players).
          meeting_epic: { nPlayers: 12, mafiaCount: 4 },
          pishrafte: { nPlayers: 15, mafiaCount: 5 },

          // Shab-haye Mafia: 12 players per match.
          // Source: fa.wikipedia.org/wiki/Ø´Ø¨â€ŒÙ‡Ø§ÛŒ_Ù…Ø§ÙÛŒØ§
          shab_mafia: { nPlayers: 12, mafiaCount: 4 },
        };
        let applyingScenarioDefaults = false;

        function scenarioHasDefaults(scenario) {
          // We support "reset to scenario defaults" for all known scenarios.
          return !!scenario;
        }
        function countEnabledToggles(toggles) {
          let n = 0;
          for (const def of toggleDefs) if (toggles && toggles[def.key]) n++;
          return n;
        }
        function countEnabledMafiaSpecials(toggles) {
          let n = 0;
          for (const def of toggleDefs) if (def.group === "mafia" && toggles && toggles[def.key]) n++;
          return n;
        }
        function computeScenarioDefaultCounts(scenario) {
          // Use explicit overrides if known; otherwise derive a reasonable default from the scenario's default roles.
          const d = scenarioDefaults[scenario] || {};
          const defaultTog = normalizeTogglesForScenario(defaultTogglesForScenario(scenario), scenario);
          const enabled = countEnabledToggles(defaultTog);
          const mafiaSpecials = countEnabledMafiaSpecials(defaultTog);

          let nPlayers = (d.nPlayers != null)
            ? parseInt(d.nPlayers, 10)
            : clamp(enabled + 7, 5, 30); // enough room for base roles + some citizens/mafia

          // ensure mafia suggestion can accommodate mafia specials
          let mafiaCount = (d.mafiaCount != null)
            ? parseInt(d.mafiaCount, 10)
            : computeSuggestedMafia(nPlayers);

          // cap by UI max (can't be >= nPlayers)
          const maxMafia = Math.max(1, Math.floor((nPlayers - 1) / 2));
          mafiaCount = clamp(mafiaCount, 1, maxMafia);
          if (mafiaSpecials > mafiaCount) mafiaCount = mafiaSpecials;

          // If this config still fails due to too many roles, increase players until it fits (up to 30).
          while (nPlayers < 30) {
            const r = buildRolePool(nPlayers, mafiaCount, defaultTog);
            if (r.ok) break;
            nPlayers++;
            const maxM = Math.max(1, Math.floor((nPlayers - 1) / 2));
            mafiaCount = clamp(mafiaCount, 1, maxM);
          }
          return { nPlayers, mafiaCount, toggles: defaultTog };
        }

        function applyScenarioDefaults(scenario) {
          applyingScenarioDefaults = true;
          try {
            // Applying scenario defaults implies starting a fresh game.
            // Clear any saved/in-progress draw so "Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø§Ø²ÛŒ" disappears.
            appState.draw = null;
            if (appState.god) {
              appState.god.status = null;
              appState.god.lastMove = null;
              appState.god.timers = null;
              appState.god.chance = null;
            }

            const def = computeScenarioDefaultCounts(scenario);
            // players
            $("playersCount").value = String(clamp(parseInt(def.nPlayers, 10), 5, 30));
            const nPlayers = parseInt($("playersCount").value, 10);
            appState.ui.nPlayers = nPlayers;
            ensureNamesLength(nPlayers);
            renderNameGrid();

            // mafia count (rebuild dropdown based on players)
            fillMafiaSelect(nPlayers, computeSuggestedMafia(nPlayers));
            const maxM = parseInt($("mafiaCount").lastChild.value, 10);
            const desiredM = parseInt(def.mafiaCount, 10);
            $("mafiaCount").value = String(clamp(desiredM, 1, maxM));
            appState.ui.mafiaCount = parseInt($("mafiaCount").value, 10);

            // roles
            appState.ui.scenario = scenario;
            appState.ui.toggles = def.toggles;
            applyScenarioAvailability(scenario);
            const mafiaCount = parseInt($("mafiaCount").value, 10);
            applyToggles(appState.ui.toggles, { disableMafiaBoss: mafiaCount <= 0, disableSwindler: mafiaCount <= 1 });

            appState.ui.customized = false;
            regenerateFromUI();
            updateResumeUI();
          } finally {
            applyingScenarioDefaults = false;
          }
        }

        // Role icons (used in cast list + role reveal modal)
        // Kept inline so this stays a single-file app.
        const ROLE_ICON_PATHS = {
          user: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0"/>
            <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"/>
          `,
          gangster: `
            <path d="M14 18a2 2 0 0 0-4 0" stroke-width="1"/>
            <path d="m19 11-2.11-6.657a2 2 0 0 0-2.752-1.148l-1.276.61A2 2 0 0 1 12 4H8.5a2 2 0 0 0-1.925 1.456L5 11"/>
            <path d="M2 11h20"/>
            <!-- sunglasses (filled lenses) -->
            <rect x="3.8" y="14.2" width="7.4" height="5" rx="1.7" fill="currentColor" stroke="none"/>
            <rect x="12.8" y="14.2" width="7.4" height="5" rx="1.7" fill="currentColor" stroke="none"/>
          `,
          mask: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M9 12a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"/>
            <path d="M4 6a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2l0 -12"/>
          `,
          crown: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M12 6l4 6l5 -4l-2 10h-14l-2 -10l5 4l4 -6"/>
          `,
          cards: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M3.604 7.197l7.138 -3.109a.96 .96 0 0 1 1.27 .527l4.924 11.902a1 1 0 0 1 -.514 1.304l-7.137 3.109a.96 .96 0 0 1 -1.271 -.527l-4.924 -11.903a1 1 0 0 1 .514 -1.304l0 .001"/>
            <path d="M15 4h1a1 1 0 0 1 1 1v3.5"/>
            <path d="M20 6c.264 .112 .52 .217 .768 .315a1 1 0 0 1 .53 1.311l-2.298 5.374"/>
          `,
          "heart-handshake": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M19.5 12.572l-7.5 7.428l-7.5 -7.428a5 5 0 1 1 7.5 -6.566a5 5 0 1 1 7.5 6.572"/>
            <path d="M12 6l-3.293 3.293a1 1 0 0 0 0 1.414l.543 .543c.69 .69 1.81 .69 2.5 0l1 -1a3.182 3.182 0 0 1 4.5 0l2.25 2.25"/>
            <path d="M12.5 15.5l2 2"/>
            <path d="M15 13l2 2"/>
          `,
          "microphone-off": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 3l18 18"/>
            <path d="M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1"/>
            <path d="M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85"/>
            <path d="M8 21l8 0"/>
            <path d="M12 17l0 4"/>
          `,
          stethoscope: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M6 4h-1a2 2 0 0 0 -2 2v3.5a5.5 5.5 0 0 0 11 0v-3.5a2 2 0 0 0 -2 -2h-1"/>
            <path d="M8 15a6 6 0 1 0 12 0v-3"/>
            <path d="M11 3v2"/>
            <path d="M6 3v2"/>
            <path d="M18 10a2 2 0 1 0 4 0a2 2 0 1 0 -4 0"/>
          `,
          search: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"/>
            <path d="M21 21l-6 -6"/>
          `,
          detective: `
            <!-- hat -->
            <path d="M7 10.8v-2.5a3 3 0 0 1 3 -3h4a3 3 0 0 1 3 3v2.5" />
            <path d="M4.5 10.8c2.4 2.4 12.6 2.4 15 0" />
            <path d="M9 8.0h6" />
            <!-- magnifying glass -->
            <circle cx="10.6" cy="18.6" r="3.0" />
            <path d="M12.6 20.6L15.1 23.1" />
          `,
          "clipboard-search": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h4.5m7.5 -10v-4a2 2 0 0 0 -2 -2h-2"/>
            <path d="M9 5a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2"/>
            <path d="M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"/>
            <path d="M20.2 20.2l1.8 1.8"/>
          `,
          microscope: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M5 21h14"/>
            <path d="M6 18h2"/>
            <path d="M7 18v3"/>
            <path d="M9 11l3 3l6 -6l-3 -3l-6 6"/>
            <path d="M10.5 12.5l-1.5 1.5"/>
            <path d="M17 3l3 3"/>
            <path d="M12 21a6 6 0 0 0 3.715 -10.712"/>
          `,
          shield: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M12 3a12 12 0 0 0 8.5 3a12 12 0 0 1 -8.5 15a12 12 0 0 1 -8.5 -15a12 12 0 0 0 8.5 -3"/>
          `,
          crosshair: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M4 8v-2a2 2 0 0 1 2 -2h2"/>
            <path d="M4 16v2a2 2 0 0 0 2 2h2"/>
            <path d="M16 4h2a2 2 0 0 1 2 2v2"/>
            <path d="M16 20h2a2 2 0 0 0 2 -2v-2"/>
            <path d="M9 12l6 0"/>
            <path d="M12 9l0 6"/>
          `,
          news: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M16 6h3a1 1 0 0 1 1 1v11a2 2 0 0 1 -4 0v-13a1 1 0 0 0 -1 -1h-10a1 1 0 0 0 -1 1v12a3 3 0 0 0 3 3h11"/>
            <path d="M8 8l4 0"/>
            <path d="M8 12l4 0"/>
            <path d="M8 16l4 0"/>
          `,
          gavel: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M13 10l7.383 7.418c.823 .82 .823 2.148 0 2.967a2.11 2.11 0 0 1 -2.976 0l-7.407 -7.385"/>
            <path d="M6 9l4 4"/>
            <path d="M13 10l-4 -4"/>
            <path d="M3 21h7"/>
            <path d="M6.793 15.793l-3.586 -3.586a1 1 0 0 1 0 -1.414l2.293 -2.293l.5 .5l3 -3l-.5 -.5l2.293 -2.293a1 1 0 0 1 1.414 0l3.586 3.586a1 1 0 0 1 0 1.414l-2.293 2.293l-.5 -.5l-3 3l.5 .5l-2.293 2.293a1 1 0 0 1 -1.414 0"/>
          `,
          tag: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M6.5 7.5a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"/>
            <path d="M3 6v5.172a2 2 0 0 0 .586 1.414l7.71 7.71a2.41 2.41 0 0 0 3.408 0l5.592 -5.592a2.41 2.41 0 0 0 0 -3.408l-7.71 -7.71a2 2 0 0 0 -1.414 -.586h-5.172a3 3 0 0 0 -3 3"/>
          `,
          cross: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M10 21h4v-9h5v-4h-5v-5h-4v5h-5v4h5l0 9"/>
          `,
          brain: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8"/>
            <path d="M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8"/>
            <path d="M17.5 16a3.5 3.5 0 0 0 0 -7h-.5"/>
            <path d="M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0"/>
            <path d="M6.5 16a3.5 3.5 0 0 1 0 -7h.5"/>
            <path d="M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10"/>
          `,
          wand: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M6 21l15 -15l-3 -3l-15 15l3 3"/>
            <path d="M15 6l3 3"/>
            <path d="M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"/>
            <path d="M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"/>
          `,
          binoculars: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M4 16a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"/>
            <path d="M14 16a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"/>
            <path d="M16.346 9.17l-.729 -1.261c-.16 -.248 -1.056 -.203 -1.117 .091l-.177 1.38"/>
            <path d="M19.761 14.813l-2.84 -5.133c-.189 -.31 -.592 -.68 -1.421 -.68c-.828 0 -1.5 .448 -1.5 1v6"/>
            <path d="M7.654 9.17l.729 -1.261c.16 -.249 1.056 -.203 1.117 .091l.177 1.38"/>
            <path d="M4.239 14.813l2.84 -5.133c.189 -.31 .592 -.68 1.421 -.68c.828 0 1.5 .448 1.5 1v6"/>
            <path d="M10 12h4v2h-4l0 -2"/>
          `,
          link: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M9 15l6 -6"/>
            <path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"/>
            <path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"/>
          `,
          leaf: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M5 21c.5 -4.5 2.5 -8 7 -10"/>
            <path d="M9 18c6.218 0 10.5 -3.288 11 -12v-2h-4.014c-9 0 -11.986 4 -12 9c0 1 0 3 2 5h3l.014 0"/>
          `,
          "user-question": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0"/>
            <path d="M6 21v-2a4 4 0 0 1 4 -4h3.5"/>
            <path d="M19 22v.01"/>
            <path d="M19 19a2.003 2.003 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483"/>
          `,
          bomb: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M15.349 5.349l3.301 3.301a1.2 1.2 0 0 1 0 1.698l-.972 .972a7.5 7.5 0 1 1 -5 -5l.972 -.972a1.2 1.2 0 0 1 1.698 0l.001 .001"/>
            <path d="M17 7l1.293 -1.293a2.414 2.414 0 0 0 .707 -1.707a1 1 0 0 1 1 -1h1"/>
            <path d="M7 13a3 3 0 0 1 3 -3"/>
          `,
          "moon-stars": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454l0 .008"/>
            <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"/>
            <path d="M19 11h2m-1 -1v2"/>
          `,
          "heart-plus": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M12 20l-7.5 -7.428a5 5 0 1 1 7.5 -6.566a5 5 0 1 1 7.96 6.053"/>
            <path d="M16 19h6"/>
            <path d="M19 16v6"/>
          `,
          eye: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0"/>
            <path d="M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6"/>
          `,
          "crystal-ball": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M6.73 17.018a8 8 0 1 1 10.54 0"/>
            <path d="M5 19a2 2 0 0 0 2 2h10a2 2 0 1 0 0 -4h-10a2 2 0 0 0 -2 2"/>
            <path d="M11 7a3 3 0 0 0 -3 3"/>
          `,
          target: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M11 12a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"/>
            <path d="M7 12a5 5 0 1 0 10 0a5 5 0 1 0 -10 0"/>
            <path d="M3 12a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/>
          `,
          ban: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 12a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"/>
            <path d="M5.7 5.7l12.6 12.6"/>
          `,
          skull: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M12 4c4.418 0 8 3.358 8 7.5c0 1.901 -.755 3.637 -2 4.96l0 2.54a1 1 0 0 1 -1 1h-10a1 1 0 0 1 -1 -1v-2.54c-1.245 -1.322 -2 -3.058 -2 -4.96c0 -4.142 3.582 -7.5 8 -7.5"/>
            <path d="M10 17v3"/>
            <path d="M14 17v3"/>
            <path d="M8 11a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"/>
            <path d="M14 11a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"/>
          `,
          sword: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M20 4v5l-9 7l-4 4l-3 -3l4 -4l7 -9l5 0"/>
            <path d="M6.5 11.5l6 6"/>
          `,
          "masks-theater": `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M13.192 9h6.616a2 2 0 0 1 1.992 2.183l-.567 6.182a4 4 0 0 1 -3.983 3.635h-1.5a4 4 0 0 1 -3.983 -3.635l-.567 -6.182a2 2 0 0 1 1.992 -2.183"/>
            <path d="M15 13h.01"/>
            <path d="M18 13h.01"/>
            <path d="M15 16.5c1 .667 2 .667 3 0"/>
            <path d="M8.632 15.982a4.037 4.037 0 0 1 -.382 .018h-1.5a4 4 0 0 1 -3.983 -3.635l-.567 -6.182a2 2 0 0 1 1.992 -2.183h6.616a2 2 0 0 1 2 2"/>
            <path d="M6 8h.01"/>
            <path d="M9 8h.01"/>
            <path d="M6 12c.764 -.51 1.528 -.63 2.291 -.36"/>
          `,
          briefcase: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 9a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v9a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2l0 -9"/>
            <path d="M8 7v-2a2 2 0 0 1 2 -2h4a2 2 0 0 1 2 2v2"/>
            <path d="M12 12l0 .01"/>
            <path d="M3 13a20 20 0 0 0 18 0"/>
          `,
          building: `
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 21l18 0"/>
            <path d="M9 8l1 0"/>
            <path d="M9 12l1 0"/>
            <path d="M9 16l1 0"/>
            <path d="M14 8l1 0"/>
            <path d="M14 12l1 0"/>
            <path d="M14 16l1 0"/>
            <path d="M5 21v-16a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v16"/>
          `,
        };

        function roleIconKey(roleId, teamFa) {
          const rid = (roleId || "").toString();
          const map = {
            // base
            citizen: "user",
            mafia: "gangster",

            // classic / general (mafia)
            mafiaBoss: "crown",
            godfather: "crown",
            swindler: "masks-theater",
            nato: "target",
            negotiator: "heart-handshake",
            natasha: "microphone-off",
            doctorLecter: "stethoscope",
            jokerMafia: "cards",
            matador: "ban",
            saulGoodman: "briefcase",

            // classic / general (city)
            detective: "detective",
            investigator: "clipboard-search",
            doctor: "stethoscope",
            watson: "stethoscope",
            researcher: "microscope",
            invulnerable: "shield",
            armored: "shield",
            sniper: "crosshair",
            professional: "crosshair",
            reporter: "news",
            representative: "building",
            hardJohn: "shield",
            psychologist: "brain",
            mayor: "building",
            seller: "tag",
            priest: "cross",
            judge: "gavel",
            commander: "building",

            // Capo (Ú©Ø§Ù¾Ùˆ/Ø¯Ù†)
            danMafia: "crown",
            witch: "wand",
            executioner: "sword",
            informant: "binoculars",
            kadkhoda: "link",
            heir: "crown",
            herbalist: "leaf",
            armorsmith: "shield",
            suspect: "user-question",

            // Zodiac
            alcapone: "crown",
            zodiac: "skull",
            magician: "masks-theater",
            bomber: "bomb",
            guard: "shield",
            ocean: "moon-stars",
            gunslinger: "crosshair",

            // Godfather (game)
            leon: "crosshair",
            constantine: "heart-plus",
            citizenKane: "eye",
            nostradamus: "crystal-ball",
          };

          if (map[rid]) return map[rid];
          if (teamFa === "Ù…Ø§ÙÛŒØ§") return "mask";
          if (teamFa === "Ø´Ù‡Ø±") return "user";
          return "skull";
        }

        function roleIconSvg(roleId, teamFa) {
          const key = roleIconKey(roleId, teamFa);
          const inner = ROLE_ICON_PATHS[key] || ROLE_ICON_PATHS.user;
          return `
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"
                 fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round">
              ${inner}
            </svg>
          `.trim();
        }

        function openRoleModal({ who, roleId, onConfirm }) {
          const scenario = (appState.draw && appState.draw.uiAtDraw && appState.draw.uiAtDraw.scenario)
            ? appState.draw.uiAtDraw.scenario
            : getScenario();
          const rBase = roles[roleId];
          const rOv = (roleScenarioOverrides[roleId] && roleScenarioOverrides[roleId][scenario]) ? roleScenarioOverrides[roleId][scenario] : null;
          const r = rBase ? { ...rBase, ...(rOv || {}) } : null;
          const teamFa = r ? (r.teamFa || "Ø´Ù‡Ø±") : "Ø´Ù‡Ø±";
          const teamCls =
            teamFa === "Ù…Ø§ÙÛŒØ§" ? "team-mafia" :
            teamFa === "Ø´Ù‡Ø±" ? "team-city" : "team-ind";
          $("modalWho").textContent = who;
          $("roleName").textContent = roleName(roleId);
          $("roleTeam").textContent = r ? `${t("lifeSheet.team")}: ${teamLabel(teamFa)}` : "â€”";

          // apply team tint classes
          const rc = $("roleCard");
          const noteEl = $("modalNote");
          rc.classList.remove("team-mafia", "team-city", "team-ind");
          noteEl.classList.remove("team-mafia", "team-city", "team-ind");
          rc.classList.add(teamCls);
          noteEl.classList.add(teamCls);

          // role icon
          const iconEl = $("roleIcon");
          if (iconEl) iconEl.innerHTML = roleIconSvg(roleId, teamFa);

          // show role description in the note area (per request)
          noteEl.textContent = roleDesc(roleId, scenario);
          noteEl.classList.remove("collapsed");

          // keep the help button; it toggles showing/hiding the description
          const helpBtn = $("roleHelpBtn");
          helpBtn.onclick = (e) => {
            if (e && e.stopPropagation) e.stopPropagation();
            openRoleHelpOverlay(roleId);
          };

          // keep roleDesc hidden (legacy element)
          const descEl = $("roleDesc");
          descEl.textContent = "";
          descEl.classList.add("collapsed");

          $("markRevealedBtn").onclick = () => {
            if (typeof onConfirm === "function") onConfirm();
            closeModal();
          };
          openModal();
        }

        function startDeal() {
          const s = readUIState();
          const res = buildRolePool(s.nPlayers, s.mafiaCount, s.toggles);
          if (!res.ok) {
            setError(res.error);
            return false;
          }
          const names = readNamesFromInputs();
          const repeated = getFirstRepeatedName(names);
          if (repeated) {
            setError(t("error.duplicateName", { name: repeated }));
            return false;
          }
          appState.ui.playerNames = names;
          saveLastNames(names);
          setError("");
          syncUIToState();
          ensureNamesLength(appState.ui.nPlayers);

          const deck = res.pool.slice(); // already shuffled
          const n = deck.length;
          appState.draw = {
            deck,
            usedCards: Array(n).fill(false),
            players: Array(n).fill(0).map(() => ({ roleId: null, revealed: false, cardIdx: null, alive: true, deathReason: null })),
            currentIdx: 0,
            createdAt: Date.now(),
            uiAtDraw: { ...appState.ui, mode: "cards" },
          };
          saveState(appState);
          renderCards();
          showCards();
          return true;
        }

        function onPickCard(cardIdx) {
          const draw = appState.draw;
          if (!draw || !draw.deck || !draw.players) return;
          const n = draw.players.length;
          const cur = draw.currentIdx || 0;
          if (cur >= n) return;
          if (draw.usedCards && draw.usedCards[cardIdx]) return;

          const who = (appState.ui.playerNames && appState.ui.playerNames[cur]) ? appState.ui.playerNames[cur] : `Ø¨Ø§Ø²ÛŒÚ©Ù† ${cur + 1}`;
          const roleId = draw.deck[cardIdx];

          // Record the pick immediately (no need to click "Seen").
          draw.usedCards[cardIdx] = true;
          const prev = draw.players[cur] || {};
          draw.players[cur] = { ...prev, roleId, revealed: true, cardIdx, alive: prev.alive !== false, deathReason: prev.deathReason || null };
          draw.currentIdx = cur + 1;
          saveState(appState);
          renderCards();

          openRoleModal({
            who,
            roleId,
            onConfirm: null,
          });
        }

        function autoAssignAllRemaining() {
          const draw = appState.draw;
          if (!draw || !draw.deck || !draw.players || !draw.usedCards) return;
          const n = draw.players.length;
          let cur = draw.currentIdx || 0;
          if (cur >= n) {
            renderCards();
            return;
          }

          const remainingCardIdxs = [];
          for (let i = 0; i < n; i++) {
            if (!draw.usedCards[i]) remainingCardIdxs.push(i);
          }
          shuffle(remainingCardIdxs);

          while (cur < n && remainingCardIdxs.length) {
            const cardIdx = remainingCardIdxs.shift();
            const roleId = draw.deck[cardIdx];
            draw.usedCards[cardIdx] = true;
            const prev = draw.players[cur] || {};
            draw.players[cur] = {
              ...prev,
              roleId,
              revealed: true,
              cardIdx,
              alive: prev.alive !== false,
              deathReason: prev.deathReason || null,
            };
            cur++;
          }

          draw.currentIdx = n;
          saveState(appState);
          renderCards();
        }

        function setPlayerLife(idx, { alive, reason }) {
          const draw = appState.draw;
          if (!draw || !draw.players || !draw.players[idx]) return;
          draw.players[idx].alive = !!alive;
          draw.players[idx].deathReason = alive ? null : (reason || "vote");
          // Track when a player died so Night UI can distinguish:
          // - dead before tonight (should not act)
          // - killed this night (pending until dawn; can still act tonight)
          try {
            if (appState.god && appState.god.flow) {
              const f = ensureFlow();
              const d = f.draft || {};
              if (!d.deadAtByIdx || typeof d.deadAtByIdx !== "object") d.deadAtByIdx = {};
              if (alive) {
                delete d.deadAtByIdx[String(idx)];
              } else {
                d.deadAtByIdx[String(idx)] = {
                  day: Number(f.day || 1),
                  phase: String(f.phase || "day"),
                  reason: String(reason || "vote"),
                  at: Date.now(),
                };
              }
              f.draft = d;
            }
          } catch {}
          syncGodStatusFromPlayers();
          saveState(appState);
        }

        function openPlayerLifeSheet(idx) {
          const draw = appState.draw;
          if (!draw || !draw.players || !draw.players[idx]) return;
          const p = draw.players[idx];
          const name = (appState.ui.playerNames && appState.ui.playerNames[idx]) ? appState.ui.playerNames[idx] : t("common.playerN", { n: idx + 1 });
          const rid = p.roleId || "citizen";
          const scenario = (appState.draw && appState.draw.uiAtDraw && appState.draw.uiAtDraw.scenario)
            ? appState.draw.uiAtDraw.scenario
            : getScenario();
          const rBase = roles[rid];
          const rOv = (roleScenarioOverrides[rid] && roleScenarioOverrides[rid][scenario]) ? roleScenarioOverrides[rid][scenario] : null;
          const r = rBase ? { ...rBase, ...(rOv || {}) } : null;
          const teamFa = r ? (r.teamFa || "Ø´Ù‡Ø±") : "Ø´Ù‡Ø±";
          const alive = p.alive !== false;
          const reason = p.deathReason || null;

          const statusText = alive
            ? t("lifeSheet.alive")
            : t("lifeSheet.dead");
          const teamCls =
            teamFa === "Ù…Ø§ÙÛŒØ§" ? "team-mafia" :
            teamFa === "Ø´Ù‡Ø±" ? "team-city" : "team-ind";
          const desc = roleDesc(rid, scenario);

          openToolModal(t("lifeSheet.title"), `
            <div class="toolBox lifeSheet ${teamCls}">
              <div class="lifeIcon" aria-hidden="true">${roleIconSvg(rid, teamFa)}</div>
              <div class="lifeName">${escapeHtml(name)}</div>
              <div class="lifeMeta">
                <span class="k">${escapeHtml(t("lifeSheet.role"))}:</span> ${escapeHtml(roleName(rid))}
                &nbsp;â€¢&nbsp;
                <span class="k">${escapeHtml(t("lifeSheet.team"))}:</span> ${escapeHtml(teamLabel(teamFa))}
                &nbsp;â€¢&nbsp;
                <span class="k">${escapeHtml(t("lifeSheet.status"))}:</span> <b>${escapeHtml(statusText)}</b>
              </div>
              <div style="height:10px"></div>
              <div class="note roleRevealNote ${teamCls}">${escapeHtml(desc)}</div>
              <div style="height:10px"></div>
              <div class="lifeActions">
                <button class="btn lifeActionBtn is-danger" id="life_shot" type="button">${escapeHtml(t("lifeSheet.actionShot"))}</button>
                <button class="btn lifeActionBtn is-ok" id="life_revive" type="button">${escapeHtml(t("lifeSheet.actionRevive"))}</button>
              </div>
            </div>
          `, { hideBottom: true });

          $("life_shot").onclick = () => { setPlayerLife(idx, { alive: false, reason: "shot" }); renderCast(); closeToolModal(); };
          $("life_revive").onclick = () => { setPlayerLife(idx, { alive: true }); renderCast(); closeToolModal(); };
        }

        function renderCast() {
          const draw = appState.draw;
          if (!draw) return;
          const pending = (() => {
            try {
              const f = (appState.god && appState.god.flow) ? ensureFlow() : null;
              if (!f || f.phase !== "night") return {};
              const ev = (f.events || []).slice().reverse().find((e) => e && e.kind === "night_actions" && e.phase === "night" && e.day === f.day && e.data);
              const payload0 = ev && ev.data ? { ...ev.data } : null;
              if (!payload0) return {};
              const idxFrom = (v) => {
                const n = parseInt(String(v ?? "").trim(), 10);
                if (!Number.isFinite(n)) return null;
                if (!draw.players) return n;
                if (n < 0 || n >= draw.players.length) return null;
                return n;
              };
              const findIdxByRole = (roleIds) => {
                const ids = Array.isArray(roleIds) ? roleIds : [roleIds];
                for (let i = 0; i < (draw.players || []).length; i++) {
                  const p = draw.players[i];
                  if (!p) continue;
                  if (ids.includes(p.roleId)) return i;
                }
                return null;
              };
              // Apply disable tonight (Magician) for pending computation
              const disabledIdx = idxFrom(payload0.Disable);
              const doctorIdx = findIdxByRole(["doctor", "watson", "doctorLecter"]);
              const detIdx = findIdxByRole(["detective"]);
              const proIdx = findIdxByRole(["professional"]);
              const bomberIdx = findIdxByRole(["bomber"]);
              const oceanIdx = findIdxByRole(["ocean"]);
              const zodiacIdx = findIdxByRole(["zodiac"]);
              if (disabledIdx !== null) {
                if (doctorIdx !== null && disabledIdx === doctorIdx) payload0.doctorSave = null;
                if (detIdx !== null && disabledIdx === detIdx) payload0.detectiveQuery = null;
                if (proIdx !== null && disabledIdx === proIdx) payload0.professionalShot = null;
                if (bomberIdx !== null && disabledIdx === bomberIdx) { payload0.bombTarget = null; payload0.bombCode = null; }
                if (oceanIdx !== null && disabledIdx === oceanIdx) payload0.oceanWake = null;
                if (zodiacIdx !== null && disabledIdx === zodiacIdx) payload0.zodiacShot = null;
              }

              const out = {};
              // Mafia pending kill (if not saved)
              const mafiaShot = idxFrom(payload0.mafiaShot);
              const doctorSave = idxFrom(payload0.doctorSave);
              if (mafiaShot !== null && !(doctorSave !== null && doctorSave === mafiaShot)) {
                out[mafiaShot] = "mafia";
              }
              // Professional pending kill
              const proShot = idxFrom(payload0.professionalShot);
              if (proIdx !== null && proShot !== null) {
                const tr = (draw.players[proShot] && draw.players[proShot].roleId) ? draw.players[proShot].roleId : "citizen";
                const teamFa = (roles[tr] && roles[tr].teamFa) ? roles[tr].teamFa : "Ø´Ù‡Ø±";
                if (tr === "zodiac") {
                  // no effect
                } else if (teamFa === "Ù…Ø§ÙÛŒØ§") {
                  out[proShot] = "pro";
                } else {
                  out[proIdx] = "pro_self";
                }
              }
              // Ocean pending self-death
              try {
                const oceanWake = (() => {
                  const v = payload0.oceanWake;
                  const arr = Array.isArray(v) ? v : (v === null || v === undefined ? [] : [v]);
                  return arr.map((x) => idxFrom(x)).filter((x) => x !== null);
                })();
                if (oceanIdx !== null && oceanWake.length) {
                  const bad = oceanWake.some((i) => {
                    const rid = (draw.players[i] && draw.players[i].roleId) ? draw.players[i].roleId : "citizen";
                    const teamFa = (roles[rid] && roles[rid].teamFa) ? roles[rid].teamFa : "Ø´Ù‡Ø±";
                    return teamFa === "Ù…Ø§ÙÛŒØ§" || rid === "zodiac";
                  });
                  if (bad) out[oceanIdx] = "ocean";
                }
              } catch {}
              return out;
            } catch {
              return {};
            }
          })();
          const mafiaHost = $("castMafia");
          const cityHost = $("castCity");
          const indHost = $("castInd");
          mafiaHost.innerHTML = "";
          cityHost.innerHTML = "";
          if (indHost) indHost.innerHTML = "";

          const entries = draw.players.map((p, idx) => {
            const rid = p.roleId || "citizen";
            const r = roles[rid];
            const name = (appState.ui.playerNames && appState.ui.playerNames[idx]) ? appState.ui.playerNames[idx] : t("common.playerN", { n: idx + 1 });
            const alive = p.alive !== false;
            const deathReason = p.deathReason || null;
            return { idx, name, roleId: rid, team: r ? r.teamFa : "Ø´Ù‡Ø±", alive, deathReason };
          });
          const mafia = entries.filter((e) => e.team === "Ù…Ø§ÙÛŒØ§");
          const city = entries.filter((e) => e.team === "Ø´Ù‡Ø±");
          const indep = entries.filter((e) => e.team !== "Ù…Ø§ÙÛŒØ§" && e.team !== "Ø´Ù‡Ø±");

          // Sort within each team by role importance (lower = higher priority).
          // Ties are resolved by original seat/order (idx).
          const byRankThenIdx = (a, b) => (roleRank(a.roleId) - roleRank(b.roleId)) || (a.idx - b.idx);
          mafia.sort(byRankThenIdx);
          city.sort(byRankThenIdx);
          indep.sort(byRankThenIdx);


          function rowHtml(e) {
            const stText = e.alive
              ? t("lifeSheet.alive")
              : t("lifeSheet.dead");
            const stCls = e.alive ? "alive" : "dead";
            const pendingTxt = (appLang === "fa") ? "Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØµØ¨Ø­" : "pending";
            const isPending = !!(e.alive && pending && pending[e.idx]);
            const teamCls =
              e.team === "Ù…Ø§ÙÛŒØ§" ? "team-mafia" :
              e.team === "Ø´Ù‡Ø±" ? "team-city" : "team-ind";
            return `
              <div class="castRow ${e.alive ? "" : "dead"} ${teamCls}" data-idx="${e.idx}">
                <div class="leftMeta">
                  <div>${escapeHtml(e.name)}</div>
                  <div style="display:flex; gap:6px; align-items:center; justify-content:flex-end">
                    <div class="statusPill ${stCls}">${escapeHtml(stText)}</div>
                    ${isPending ? `<div class="statusPill pending">${escapeHtml(pendingTxt)}</div>` : ``}
                  </div>
                </div>
                <div class="who">
                  <div class="avatar">${roleIconSvg(e.roleId, e.team)}</div>
                  <div class="role">${escapeHtml(roleName(e.roleId))}</div>
                </div>
              </div>
            `;
          }

          if (!mafia.length) mafiaHost.innerHTML = `<div class="castRow team-mafia"><div>â€”</div><div class="who"><div class="avatar">${roleIconSvg("none_mafia", "Ù…Ø§ÙÛŒØ§")}</div><div class="role">${escapeHtml(t("cast.noneMafia"))}</div></div></div>`;
          else mafiaHost.innerHTML = mafia.map(rowHtml).join("");

          if (!city.length) cityHost.innerHTML = `<div class="castRow team-city"><div>â€”</div><div class="who"><div class="avatar">${roleIconSvg("none_city", "Ø´Ù‡Ø±")}</div><div class="role">${escapeHtml(t("cast.noneCity"))}</div></div></div>`;
          else cityHost.innerHTML = city.map(rowHtml).join("");

          if (indHost) {
            indHost.style.display = indep.length ? "block" : "none";
            if (indep.length) indHost.innerHTML = indep.map(rowHtml).join("");
          }

          $("castStat").textContent = indep.length
            ? t("cast.stat.withInd", { p: entries.length, m: mafia.length, c: city.length, i: indep.length })
            : t("cast.stat.noInd", { p: entries.length, m: mafia.length, c: city.length });

          // click-to-set life status
          document.querySelectorAll("#castCard .castRow[data-idx]").forEach((el) => {
            el.addEventListener("click", () => {
              const idx = parseInt(el.getAttribute("data-idx"), 10);
              openPlayerLifeSheet(idx);
            });
          });

          // keep GOD status in sync
          syncGodStatusFromPlayers();
        }

        function resetAll() {
          // stop any running timers / close overlays
          try { stopTimerInterval(); } catch {}
          try { closeModal(); } catch {}
          try { closeToolModal(); } catch {}

          appState = {
            ui: {
              scenario: "classic",
              nPlayers: 10,
              mafiaCount: 3,
              toggles: defaultTogglesForScenario("classic"),
              playerNames: [],
              customized: false,
              namesMode: (function () {
                const last = loadLastNames();
                return (last && last.some((x) => String(x || "").trim())) ? "last" : "default";
              })(),
            },
            draw: null,
            god: {
              status: null,
              lastMove: null,
              timers: null,
              chance: null,
            },
          };
          clearState();
          applyUIFromState();
          updateQuickStat();
          showSetup();
          setError("");
          updateResumeUI();
        }

        function showHelp() {
          openToolModal(t("help.title"), `
            <div class="toolBox">
              <div style="font-weight:1100; margin-bottom:10px">${escapeHtml(t("help.quick"))}</div>
              <div style="font-weight:900; font-size:12px; line-height:1.9; color: var(--muted)">${t("help.body")}</div>
            </div>
          `);
        }

        function hasSavedGame() {
          return !!(appState.draw && appState.draw.players && appState.draw.players.length);
        }

        function clearSavedGameOnly() {
          appState.draw = null;
          if (appState.god) {
            appState.god.status = null;
            appState.god.lastMove = null;
            appState.god.timers = null;
            appState.god.chance = null;
          }
          saveState(appState);
          updateResumeUI();
        }

        function updateResumeUI() {
          const btn = $("resumeBtn");
          if (btn) btn.style.display = "none"; // legacy/hidden

          const row = $("savedGameBarRow");
          const has = hasSavedGame();
          if (row) row.style.display = has ? "grid" : "none";
        }

        function resumeGame() {
          if (!appState.draw || !appState.draw.players || !appState.draw.players.length) return;
          const mode = (appState.draw.uiAtDraw && appState.draw.uiAtDraw.mode) ? appState.draw.uiAtDraw.mode : null;
          if (mode === "cards") {
            const draw = appState.draw;
            const n = draw.players.length;
            const cur = draw.currentIdx || 0;
            const done = cur >= n;
            if (!done) {
              renderCards();
              showCards();
              return;
            }
            // If dealing is finished, resume to the final cast list (names + roles).
            renderCast();
            showCast();
            return;
          }
          // fallback
          renderCast();
          showCast();
        }

        // --- wire up ---
        renderToggles();
        fillPlayersSelect();

        // load saved
        const saved = loadState();
        if (saved && typeof saved === "object") {
          // merge lightly (avoid breaking on partial state)
          appState.ui = { ...appState.ui, ...(saved.ui || {}) };
          appState.draw = saved.draw || null;
          // IMPORTANT: restore GOD recorded state too (flow, timers, etc.)
          // Without this, clicking "Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø§Ø²ÛŒ" appears to wipe recorded flow.
          if (saved.god && typeof saved.god === "object") {
            appState.god = { ...appState.god, ...saved.god };
          }
          // drop incompatible older saved games
          if (
            appState.draw &&
            (!Array.isArray(appState.draw.deck) ||
              !Array.isArray(appState.draw.players) ||
              !Array.isArray(appState.draw.usedCards))
          ) {
            appState.draw = null;
          }
          setSaveState(true);
        } else {
          setSaveState(false);
        }

        // language init (persisted)
        try {
          const savedLang = (shouldPersist() ? (localStorage.getItem(LANG_KEY) || "fa") : "fa");
          setLanguage(savedLang === "en" ? "en" : "fa");
        } catch {
          try { setLanguage("fa"); } catch {}
        }

        // initial UI
        applyUIFromState();
        updateQuickStat();
        showSetup();
        updateResumeUI();

        $("langChip").addEventListener("click", toggleLanguage);
        $("langChip").addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") toggleLanguage();
        });
        $("langBtn").addEventListener("click", (e) => {
          e.stopPropagation();
          toggleLanguage();
        });

        $("helpChip").addEventListener("click", showHelp);
        $("helpChip").addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") showHelp();
        });
        $("scenarioDefaultsBtn").addEventListener("click", () => {
          const scenario = $("scenario").value;
          applyScenarioDefaults(scenario);
        });
        $("savedGameResumeBtn").addEventListener("click", () => resumeGame());
        $("savedGameClearBtn").addEventListener("click", () => clearSavedGameOnly());
        $("resumeBtn").addEventListener("click", resumeGame);
        $("startGameBtn").addEventListener("click", () => {
          // Validate selected scenario/roles/counts before leaving setup.
          const s = readUIState();
          const res = buildRolePool(s.nPlayers, s.mafiaCount, s.toggles);
          if (!res.ok) {
            setError(res.error || t("error.config"));
            showSetup();
            return;
          }

          // Reset all recorded game data, keep only player names.
          try {
            const keepNames = (appState.ui && Array.isArray(appState.ui.playerNames)) ? appState.ui.playerNames.slice() : [];
            // stop any running timers
            try { stopTimerInterval(); } catch {}
            // clear draw + GOD recorded state
            appState.draw = null;
            appState.god = null;
            // restore names (and length will be enforced below)
            if (!appState.ui) appState.ui = {};
            appState.ui.playerNames = keepNames;
            saveState(appState);
          } catch {}

          setError("");
          regenerateFromUI();
          ensureNamesLength(appState.ui.nPlayers);
          // if user has namesMode=last, load them now
          if (appState.ui.namesMode === "last") setNamesMode("last");
          $("playersStat").textContent = (appLang === "fa")
            ? `Ø¨Ø§Ø²ÛŒÚ©Ù†: ${appState.ui.nPlayers}`
            : `Players: ${appState.ui.nPlayers}`;
          showPlayers();
        });

        $("playersBackBtn").addEventListener("click", showSetup);
        $("dealBtn").addEventListener("click", () => startDeal());

        $("cardsBackBtn").addEventListener("click", () => showPlayers());
        $("autoAssignBtn").addEventListener("click", autoAssignAllRemaining);
        $("cardsNextBtn").addEventListener("click", () => {
          renderCast();
          showCast();
        });
        $("castBackBtn").addEventListener("click", showSetup);
        $("castNewBtn").addEventListener("click", () => {
          showSetup();
          startNewDraw({ keepUI: true });
        });

        $("modalCloseBtn").addEventListener("click", closeModal);
        $("modal").addEventListener("click", (e) => {
          if (e.target === $("modal")) closeModal();
        });

        $("toolCloseBtn").addEventListener("click", closeToolModal);
        $("toolOkBtn").addEventListener("click", closeToolModal);
        $("toolModal").addEventListener("click", (e) => {
          if (e.target === $("toolModal")) closeToolModal();
        });

        // GOD tools
        // Wake order tool removed (replaced by Flow Runner night page).
        $("toolStatus").addEventListener("click", showStatusTool);
        // Last move tool removed from toolbar (shown only after a vote-out).
        $("toolRoleChange").addEventListener("click", showRoleChangeTool);
        // Chance tool removed.
        $("toolTimer").addEventListener("click", showTimerTool);
        $("toolFlow").addEventListener("click", showFlowTool);

        $("namesDefaultBtn").addEventListener("click", () => setNamesMode("default"));
        $("namesLastBtn").addEventListener("click", () => setNamesMode("last"));
        // update mafia select based on players
        $("playersCount").addEventListener("change", () => {
          if (!applyingScenarioDefaults) appState.ui.customized = true;
          const n = parseInt($("playersCount").value, 10);
          fillMafiaSelect(n, computeSuggestedMafia(n));
          $("mafiaCount").value = String(clamp(computeSuggestedMafia(n), 1, parseInt($("mafiaCount").lastChild.value, 10)));
          appState.ui.nPlayers = n;
          ensureNamesLength(n);
          renderNameGrid();
          regenerateFromUI();
          // enforce constraints on mafia specials
          const mafiaCount = parseInt($("mafiaCount").value, 10);
          if (mafiaCount <= 1 && appState && appState.ui && appState.ui.toggles) {
            appState.ui.toggles.swindler = false;
            applyToggles(appState.ui.toggles, { disableSwindler: true, disableMafiaBoss: mafiaCount <= 0 });
          }
          updateQuickStat();
        });

        $("mafiaCount").addEventListener("change", () => {
          if (!applyingScenarioDefaults) appState.ui.customized = true;
          const mafiaCount = parseInt($("mafiaCount").value, 10);
          if (mafiaCount <= 1 && appState && appState.ui && appState.ui.toggles) {
            appState.ui.toggles.swindler = false;
            applyToggles(appState.ui.toggles, { disableSwindler: true, disableMafiaBoss: mafiaCount <= 0 });
          }
          regenerateFromUI();
        });

        $("scenario").addEventListener("change", () => {
          const scenario = $("scenario").value;
          // IMPORTANT: update state first (avoid snapping back to previous scenario)
          appState.ui.scenario = scenario;
          // capture current selections as "customized" baseline
          syncUIToState();

          // Changing scenario should NOT change player/mafia counts.
          // Only update role selections (and enforce scenario allow-list).
          if (appState.ui.customized) {
            // Keep user's current role selections, but turn off roles that aren't allowed in this scenario.
            appState.ui.toggles = normalizeTogglesForScenario(appState.ui.toggles, scenario);
          } else {
            // Not customized: switch role selections to scenario's default role-set.
            appState.ui.toggles = normalizeTogglesForScenario(defaultTogglesForScenario(scenario), scenario);
          }
          applyScenarioAvailability(scenario);
          const mafiaCount = parseInt($("mafiaCount").value, 10);
          applyToggles(appState.ui.toggles, { disableMafiaBoss: mafiaCount <= 0, disableSwindler: mafiaCount <= 1 });
          saveState(appState);
          updateQuickStat();
        });

        // Toggle cards: click anywhere toggles; only "?" opens role help.
        $("toggles").addEventListener("click", (e) => {
          const helpBtn = e && e.target && e.target.closest ? e.target.closest('button[data-rolehelp]') : null;
          if (helpBtn) {
            try { e.preventDefault(); } catch {}
            try { e.stopPropagation(); } catch {}
            const rid = helpBtn.getAttribute("data-rolehelp") || "";
            openRoleHelpOverlay(rid);
            return;
          }

          const wrap = e && e.target && e.target.closest ? e.target.closest(".toggle") : null;
          if (!wrap || wrap.classList.contains("base")) return;
          if (wrap.classList.contains("disabled")) return;
          const key = wrap.dataset.key || "";
          if (!key) return;

          wrap.classList.toggle("on");
          wrap.setAttribute("aria-pressed", wrap.classList.contains("on") ? "true" : "false");
          if (!applyingScenarioDefaults) appState.ui.customized = true;
          regenerateFromUI();
        });

        $("toggles").addEventListener("keydown", (e) => {
          const k = e && e.key ? e.key : "";
          if (k !== "Enter" && k !== " ") return;
          const wrap = e && e.target && e.target.closest ? e.target.closest(".toggle") : null;
          if (!wrap || wrap.classList.contains("base")) return;
          if (wrap.classList.contains("disabled")) return;
          const key = wrap.dataset.key || "";
          if (!key) return;
          try { e.preventDefault(); } catch {}
          wrap.classList.toggle("on");
          wrap.setAttribute("aria-pressed", wrap.classList.contains("on") ? "true" : "false");
          if (!applyingScenarioDefaults) appState.ui.customized = true;
          regenerateFromUI();
        });

        // initial scenario availability
        applyScenarioAvailability($("scenario").value);

        // final persist ui
        syncUIToState();
        if (shouldPersist()) saveState(appState);
      })();
    </script>
  </body>
</html>
